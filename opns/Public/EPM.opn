protocol EPM with Documentation
{
    ProtocolName = "Endpoint Mapper",
    ProtocolType = "rpc",
    ShortName = "EPM",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
        new Reference{Name = "X/Open C706", Link = "http://www.opengroup.org/pubs/catalog/c706.htm"},
    ],
    RevisionSummary = 
    [
        new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "03/28/2012"}
    ]
};

using ERREF;
using Technologies.IDL;
using MSRPCE;

endpoint Server over MSRPCE.Server provides ept;

contract ept
{
    accepts operation ept_insert
    {
        in optional handle_t h;
        in unsigned32 num_ents;
        in array<ept_entry_t> entries
               with Technologies.IDL.IDL{Size_is = [num_ents], Dimensions = [null]};
        in boolean32 replace with DisplayInfo{ToText = BooleanToString};
        out error_status_t status
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        
        override string ToString()
        {
            return
                "ept_insert, status: " + Win32ErrorCodesToText(status) +
                ", entries: " + entries.ToString() +
                ", replace: " + BooleanToString(replace);
        }
    }
    with Technologies.IDL.IDL{Opnum = 0};
    
    accepts operation ept_delete
    {
        in optional handle_t h;
        in unsigned32 num_ents;
        in array<ept_entry_t> entries
               with Technologies.IDL.IDL{Size_is = [num_ents], Dimensions = [null]};
        out error_status_t status
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        
        override string ToString()
        {
            return
                "ept_delete, status: " + Win32ErrorCodesToText(status) + 
                ", delete entries: " + entries.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 1};
    
    accepts operation ept_lookup
    {
        in optional handle_t h;
        in unsigned32 inquiry_type 
            where ValidationCheck(InRange<InqurityType>(value), null, DiagnosisLevel.Error, "EPM: The inquiry_type in operation ept_lookup is not applicable to InqurityType.")
            with DisplayInfo{ToText = DisplayInqurityType};
        in uuid_p_t object with IDL {PointerType = PointerKind.FullPtr};
        in rpc_if_id_p_t interface_id with IDL {PointerType = PointerKind.FullPtr};
        in unsigned32 vers_option
            where ValidationCheck(value == 0 || InRange<VersOption>(value), null, DiagnosisLevel.Error, "EPM: The vers_option in operation ept_lookup is not applicable to VersOption.")
            with DisplayInfo{ToText = DisplayVersOption};
        in out ept_lookup_handle_t entry_handle
                   with Technologies.IDL.IDL{IndirectionLevel = 1};
        in unsigned32 max_ents;
        out unsigned32 num_ents with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<ept_entry_t> entries
                with Technologies.IDL.IDL{Size_is = [max_ents],
                                          Length_is = [num_ents],
                                          Dimensions = [null]};
        out error_status_t status
                with Technologies.IDL.IDL{IndirectionLevel = 1};
                
        string VersionOptionToString()
        {
            switch(vers_option)
            {
                case VersOption.RPC_C_VERS_ALL =>
                    return " with all version";
                case VersOption.RPC_C_VERS_COMPATIBLE =>
                    if(interface_id != null)
                    {
                        return " with version greater than v" + interface_id.vers_major.ToString() + "." + interface_id.vers_minor.ToString();
                    }
                    return " with compatible version.";
                case VersOption.RPC_C_VERS_EXACT =>
                    if(interface_id != null)
                    {
                        return " with version exactly equal to v" + interface_id.vers_major.ToString() + "." + interface_id.vers_minor.ToString();
                    }
                    return " with exactly version";
                case VersOption.RPC_C_VERS_MAJOR_ONLY =>
                    if(interface_id != null)
                    {
                        return " with version exactly equal to v" + interface_id.vers_major.ToString() + ".*";
                    }
                    return " with major version.";
                case VersOption.RPC_C_VERS_UPTO =>
                    if(interface_id != null)
                    {
                        return " with version less than v" + interface_id.vers_major.ToString() + "." + interface_id.vers_minor.ToString();
                    }
                    return " with upto version";
                default=>
                    return " with unknown version type";
            }
        }
        
        override string ToString()
        {
            string summaryLine = "ept_lookup, status: " + Win32ErrorCodesToText(status);
            
            switch(inquiry_type)
            {
                case InqurityType.RPC_C_EP_ALL_ELTS =>
                    summaryLine += ", lookup all elements in the endpoint mapper";
                case InqurityType.RPC_C_EP_MATCH_BY_IF =>
                    summaryLine += ", look up elements matched by interface";
                    if(interface_id != null)
                    {
                        summaryLine += " " + interface_id.ToString();
                    }
                    else
                    {
                        summaryLine += " null";
                    }
                    summaryLine += VersionOptionToString();
                case InqurityType.RPC_C_EP_MATCH_BY_OBJ =>
                    summaryLine += ", look up elements matched by object";
                    if(object != null)
                    {
                        summaryLine += " " + UuidToText(object);
                    }
                    else
                    {
                        summaryLine += " null";
                    }
                case InqurityType.RPC_C_EP_MATCH_BY_BOTH => 
                    summaryLine += ", look up elements matched by interface";
                    if(interface_id != null)
                    {
                        summaryLine += " " + interface_id.ToString();
                    }
                    else
                    {
                        summaryLine += " null";
                    }
                    
                    summaryLine += " and by object";
                    if(object != null)
                    {
                        summaryLine += " " + UuidToText(object);
                    }
                    else
                    {
                        summaryLine += " null";
                    }
                    summaryLine += VersionOptionToString();
                default=>
                    summaryLine += " Unknown";
            }
            
            if(num_ents > 0)
            {
                summaryLine += ", and find entries: " + entries.ToString();
            }
            else
            {
                summaryLine += ", and find no entry.";
            }
            return summaryLine;
        }
    }
    with Technologies.IDL.IDL{Idempotent = true, Opnum = 2};
    
    accepts operation ept_map
    {
        in optional handle_t h;
        in uuid_p_t object with IDL {PointerType = PointerKind.FullPtr};
        in twr_p_t map_tower with IDL {PointerType = PointerKind.FullPtr};
        in out ept_lookup_handle_t entry_handle
                   with Technologies.IDL.IDL{IndirectionLevel = 1};
        in unsigned32 max_towers;
        out unsigned32 num_towers
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<twr_p_t> towers
                with Technologies.IDL.IDL{Size_is = [max_towers],
                                          Length_is = [num_towers],
                                          Dimensions = [null]};
        out error_status_t status
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        
        override string ToString()
        {           
            return
                "ept_map, status: " + Win32ErrorCodesToText(status);
        }
    }
    with Technologies.IDL.IDL{Idempotent = true, Opnum = 3};
    
    accepts operation ept_lookup_handle_free
    {
        in optional handle_t h;
        in out ept_lookup_handle_t entry_handle
                   with Technologies.IDL.IDL{IndirectionLevel = 1};
        out error_status_t status
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        
        override string ToString()
        {
            return
                "ept_lookup_handle_free, status: " + Win32ErrorCodesToText(status);
        }
    }
    with Technologies.IDL.IDL{Opnum = 4};
    
    accepts operation ept_inq_object
    {
        in optional handle_t h;
        out guid ept_object with Technologies.IDL.IDL{IndirectionLevel = 1};
        out error_status_t status
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        
        override string ToString()
        {
            return
                "ept_inq_object, status: " + Win32ErrorCodesToText(status);
        }
    }
    with Technologies.IDL.IDL{Idempotent = true, Opnum = 5};
    
    accepts operation ept_mgmt_delete
    {
        in optional handle_t h;
        in boolean32 object_speced with DisplayInfo{ToText = BooleanToString};
        in uuid_p_t object with IDL {PointerType = PointerKind.FullPtr};
        in twr_p_t tower with IDL {PointerType = PointerKind.FullPtr};
        out error_status_t status
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        
        override string ToString()
        {
            // get string of object
            string objectStr = "null";
            if(object != null)
            {
                objectStr = UuidToText(object);
            }
                       
            return
                "ept_mgmt_delete, status: " + Win32ErrorCodesToText(status) +
                ", delete object " + objectStr;
        }
    }
    with Technologies.IDL.IDL{Opnum = 6};
}
with Technologies.IDL.IDL{Uuid = {e1af8308-5d1f-11c9-91a4-08002b14a0fa},
                          Version = "3.0",
                          Pointer_default = PointerKind.FullPtr};

typedef unsigned32 = IDLUlong ;

type ept_entry_t
{
    guid object;
    twr_p_t tower
        with Technologies.IDL.IDL{ EmbedType = true};
    string @annotation
        with Technologies.IDL.IDL{Dimensions = [64], BaseStringType = TypeOf<char>()};
        
   override string ToString()
   {
       return @annotation;
   }
}

typedef uuid_p_t = guid with IDL {IndirectionLevel = 1};

typedef unsigned16 = ushort ;

typedef unsigned8 = usmall ;

typedef twr_p_t = twr_t with IDL {IndirectionLevel = 1};

type twr_t
{
    unsigned32 tower_length;
    array<byte> tower_octet_string
        with Technologies.IDL.IDL{Size_is = [tower_length], Dimensions = [null]};
}
with Technologies.IDL.IDL{DoNotGenerate = true};

typedef boolean32 = unsigned32;

typedef rpc_if_id_p_t = rpc_if_id_t with IDL{IndirectionLevel = 1} ;

type rpc_if_id_t
{
    guid uuid;
    unsigned16 vers_major;
    unsigned16 vers_minor;
    
    override string ToString()
    {
       return UuidToText(uuid);
    }
}
with Technologies.IDL.IDL{DoNotGenerate = true};

typedef ept_lookup_handle_t = ContextHandle ;

pattern InqurityType = enum unsigned32
{
    RPC_C_EP_ALL_ELTS = 0x00000000,
    RPC_C_EP_MATCH_BY_IF = 0x00000001,
    RPC_C_EP_MATCH_BY_OBJ = 0x00000002,
    RPC_C_EP_MATCH_BY_BOTH = 0x00000003,
    ...
}
with IDL{DoNotGenerate = true};

pattern VersOption = enum unsigned32
{
    RPC_C_VERS_ALL = 0x00000001,
    RPC_C_VERS_COMPATIBLE = 0x00000002,
    RPC_C_VERS_EXACT = 0x00000003,
    RPC_C_VERS_MAJOR_ONLY = 0x00000004,
    RPC_C_VERS_UPTO = 0x00000005,
    ...
}
with IDL{DoNotGenerate = true};

/*--------------------------------Utility annotations and functions -----------------------------------------------*/

string DisplayInqurityType(any input)
{
    unsigned32 temp = input as unsigned32;
    return EnumToString(temp, "EPM.InqurityType");
}

string DisplayVersOption(any input)
{
    VersOption temp = input as unsigned32;
    if(temp == 0)
    {
        return "Ignored value";
    }
    return EnumToString(temp, "EPM.VersOption");
}

string BooleanToString(any input)
{
    boolean32 temp = input as boolean32;
    if(temp == 0)
    {
        return "False";
    }
    else
    {
        return "True";
    }
}
