protocol LPR with 
BinaryEncodingDefaults{Endian = Endian.Big, TextEncoding = TextEncoding.ASCII},
Documentation
{
    ProtocolName = "Line Printer Daemon Protocol",
    ShortName = "LPR",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 1179"},
        ],
    RevisionSummary = 
        [
            new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "10/13/2011"}
        ]
};

using IANA;
using Utility;
using TCP;
using VirtualTransport;

endpoint Server
    over VirtualTransport.Server
    accepts Request
    issues Response;

client endpoint Client connected to Server;

autostart actor LPROverTCP(VirtualTransport.Server server)
{
    process server accepts s:VirtualTransport.VirtualDataSegment{DestinationPort is Port.LPR}
    {
        switch (s.Payload)
        {
            case request:Request from BinaryDecoder<Request> =>
                var node = endpoint LPR.Server over server;
                dispatch node accepts request;
            default =>
                ThrowDecodingExceptionForTCP("LPR", "Request", s#IsIncomplete, s#SegmentLost);
        }
    }
    
    process server issues s:VirtualTransport.VirtualDataSegment{SourcePort is Port.LPR}
    {
        switch (s.Payload)
        {
            case response:Response from BinaryDecoder<Response> =>
                var node = endpoint LPR.Server over server;
                dispatch node issues response;
            default =>
                ThrowDecodingExceptionForTCP("LPR", "Response", s#IsIncomplete, s#SegmentLost);
        }
    }
}

message Request
{
    optional (byte where value > 0 && value <= 5) CommandCode;
    optional ([|!(CommandCode is nothing) && CommandCode == 1|] Command01
        | [|!(CommandCode is nothing) && CommandCode == 2|] Command02
        | [|!(CommandCode is nothing) && CommandCode == 3|] Command03 
        | [|!(CommandCode is nothing) && CommandCode == 4|] SendQueueState
        | [|!(CommandCode is nothing) && CommandCode == 5|] RemoveJobs) Job;
    // Future Reference: Blocking bug has been fixed, use syntax to further decode, Bug #28383, string teminator doesn't accept other charactors,
    // use one string to consume all lines for temp.
        optional string ControlFileLine;
    
    override string ToString()
    {
        string summary = "Request";
        if (!(CommandCode is nothing))
        {
            summary = "Client's Command to Daemon";
            if ((CommandCode as byte) <= 5)
            {
                switch (Job)
                {
                    case PrintWaintingJobs =>
                        summary += ", 'Print Wainting Jobs'";
                    case ReceivePrinterJob =>
                        summary += ", 'Receive Printer Job'";
                    case SendQueueState =>
                        summary += ", 'Send Queue State'";
                    case RemoveJobs =>
                        summary += ", 'Remove Jobs'";
                    case AbortJob =>
                        summary += ", 'Abort Job'";
                    case ReceiveControlFile =>
                        summary += ", 'Receive Control File'";
                    case ReceiveDataFile =>
                        summary += ", 'Receive Data File'";
                    default =>
                }
            }
        }
        else
        {
            summary = "Data file";
        }
        
        return summary;
    }
}

message Response
{
    optional (byte where value == 0) Code;
    optional string QueueReport;
    
    override string ToString()
    {
        string summary = "Response";
        if (!(Code is nothing))
        {
            summary ="Acknowledgement From Daeman" + (Code == 0 ? ", Positive Ack" : ", Negative Ack");
        }
        return summary;
    }
}

type ResponseCode
{
    byte Code where value == 0;
}

type RequestCode
{
    byte Code where value <= 5;
}

pattern Command01 = AbortJob | PrintWaintingJobs;
pattern Command02 = ReceiveControlFile | ReceivePrinterJob;
pattern Command03 = ReceiveDataFile | SendQueueState;

// 01
type PrintWaintingJobs
{
    string Queue with BinaryEncoding{TextTerminator = "\n"};
}

// 02
type ReceivePrinterJob
{
    string Queue with BinaryEncoding{TextTerminator = "\n"};
}

// 03/04
type SendQueueState
{
    string Queue with BinaryEncoding{TextTerminator = " "};
    string List with BinaryEncoding{TextTerminator = "\n"};
}

// 05
type RemoveJobs
{
    string Queue with BinaryEncoding{TextTerminator = " "};
    string Agent with BinaryEncoding{TextTerminator = " "};
    string List with BinaryEncoding{TextTerminator = "\n"};
}

// Subcommand 01
type AbortJob
{
    byte LF where value == 10;
}

// Subcommand 02
type ReceiveControlFile
{
    string Count with BinaryEncoding{TextTerminator = " "};
    invariant Count != "" && (Count.Segment(0, 1) as char) >= '0' && (Count.Segment(0, 1) as char) <= '9';
    optional string Name with BinaryEncoding{TextTerminator = "\n"};
}

// Subcommand 03
type ReceiveDataFile
{
    string Count with BinaryEncoding{TextTerminator = " "};
    invariant Count != "" && (Count.Segment(0, 1) as char) >= '0' && (Count.Segment(0, 1) as char) <= '9';
    optional string Name with BinaryEncoding{TextTerminator = "\n"};
}

pattern ControlFileLine = 
            ControlFileLineC |
            ControlFileLineH |
            ControlFileLineI |
            ControlFileLineJ |
            ControlFileLineL |
            ControlFileLineM |
            ControlFileLineN |
            ControlFileLineP |
            ControlFileLineT |
            ControlFileLineU |
            ControlFileLineW |
            ControlFileLineS |
            ControlFileLine1 |
            ControlFileLine2 |
            ControlFileLine3 |
            ControlFileLine4 |
            ControlFileLinec |
            ControlFileLined |
            ControlFileLinef |
            ControlFileLineg |
            ControlFileLinek |
            ControlFileLinel |
            ControlFileLinen |
            ControlFileLineo |
            ControlFileLinep |
            ControlFileLiner |
            ControlFileLinet |
            ControlFileLinev |
            DataFile;

type ControlFileLineC
{
    (char where value == 'C') CommandCode;
    string BannerPageClass with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineH
{
    (char where value == 'H') CommandCode;
    string HostName with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineI
{
    (char where value == 'I') CommandCode;
    string IndentingCount with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineJ
{
    (char where value == 'J') CommandCode;
    string JobName with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineL
{
    (char where value == 'L') CommandCode;
    string BurstPagesUserName with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineM
{
    (char where value == 'N') CommandCode;
    string UserName with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineN
{
    (char where value == 'N') CommandCode;
    string FileName with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineP
{
    (char where value == 'P') CommandCode;
    string UserID with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineT
{
    (char where value == 'T') CommandCode;
    string Title with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineU
{
    (char where value == 'U') CommandCode;
    string FileToUnlink with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineW
{
    (char where value == 'W') CommandCode;
    string WidthCount with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineS
{
    (char where value == 'S') CommandCode;
    string Device with BinaryEncoding{TextTerminator = " "};
    string Inode with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLine1
{
    (char where value == '1') CommandCode;
    string FileName with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLine2
{
    (char where value == '2') CommandCode;
    string FileName with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLine3
{
    (char where value == '3') CommandCode;
    string FileName with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLine4
{
    (char where value == '4') CommandCode;
    string FileName with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLinec
{
    (char where value == 'c') CommandCode;
    string FileToPlot with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLined
{
    (char where value == 'd') CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLinef
{
    (char where value == 'f') CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineg
{
    (char where value == 'g') CommandCode;
    string FileToPlot with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLinek
{
    (char where value == 'k') CommandCode;
    string Operand with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLinel
{
    (char where value == 'l') CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLinen
{
    (char where value == 'n') CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineo
{
    (char where value == 'o') CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLinep
{
    (char where value == 'p') CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLiner
{
    (char where value == 'r') CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLinet
{
    (char where value == 't') CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLinev
{
    (char where value == 'v') CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type ControlFileLineDefault
{
    char CommandCode;
    string FileToPrint with BinaryEncoding{TextTerminator = "\n"};
}

type DataFile
{
    string File with BinaryEncoding{TextTerminator = "\n"};
}
