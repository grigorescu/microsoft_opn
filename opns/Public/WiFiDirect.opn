protocol WiFiDirect with 
BinaryEncodingDefaults {Endian = Endian.Little, TextEncoding = TextEncoding.ASCII},
Documentation
{
    ProtocolName = "WiFi Peer-to-Peer Protocol",
    ShortName = "WiFiDirect",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
        new Reference{Name = "IEEE Std 802.11", Version = "2007 Edition", Link = "http://standards.ieee.org/getieee802/download/802.11-2007.pdf"},
        new Reference{Name = "Wi-Fi Peer-to-Peer(P2P)", Version = "1.1"},
        new Reference{Name = "Wi-Fi Protected Setup Specification", Version = "1.0"}
    ],
    RevisionSummary = 
    [
        new Revision{Class = RevisionClass.Major, Version="1.0.0", Date="04/11/2013"}
    ]
};

using Standard;
using Utility;
using Ethernet;
using WiFi;
using CoreResources;
using CommonResources;

endpoint Node over WiFi.Node
    accepts NoticeOfAbsence
    accepts P2PPresenceRequest
    accepts P2PPresenceResponse
    accepts GODiscoverabilityRequest
    accepts GONegotiationRequest
    accepts GONegotiationResponse
    accepts GONegotiationConfirmation
    accepts P2PInvitationRequest
    accepts P2PInvitationResponse
    accepts DeviceDiscoverabilityRequest
    accepts DeviceDiscoverabilityResponse
    accepts ProvisionDiscoveryRequest
    accepts ProvisionDiscoveryResponse;

// Decode a WiFi.VendorSpecificInformation to a P2PIE
P2PIE DecodeP2PIE(WiFi.VendorSpecificInformation vsi)
{
    P2PIE element = null;
    if (vsi.OUI == $[506F9A])
    {
        if ((vsi.VendorSpecificContent as binary).PeekByte(0) == 0x09)
        {
            element = new P2PIE{};
            element.ElementID = 0xDD;
            element.Length = vsi.Length;
            element.OUI = vsi.OUI;
            element.OUIType = 0x09;
            switch ((vsi.VendorSpecificContent as binary).PeekBytes(8))
            {
                // WORKAROUND: BinaryDecoder can not decode type Array<A|B>,
                // so define type P2PAttributeArray to encapsulate it.
                case attrArray:P2PAttributeArray from BinaryDecoder<P2PAttributeArray> =>
                    element.P2PAttributes = attrArray.Attributes;
                default =>
                    ThrowDecodingException("WiFiDirect", "P2PAttributeArray"); 
            }
        }
    }
    return element;
}

// Decode the P2PIE contained in an array of WiFi.InformationField, will perform reassembly if needed. 
array<InformationElement> DecodeP2PIEInIEArray(array<WiFi.InformationField> elements, ref bool containP2PIE)
{
    array<InformationElement> informationElement = [];
    P2PIE element = null;
    ReassembledP2PIE reassembledElement = null;
    array<WiFi.VendorSpecificInformation> p2pies = [];
    foreach (WiFi.InformationField e in elements)
    {
        if (e is WiFi.VendorSpecificInformation)
        {
            var vsi = e as WiFi.VendorSpecificInformation;
            if (vsi.OUI == $[506F9A])
            {
                if ((vsi.VendorSpecificContent as binary).PeekByte(0) == 0x09)
                {
                    p2pies += [vsi];
                }
            }
        }
        else
        {
            informationElement += [e];
        }
    }
    
    if (p2pies.Count == 0)
    {
        containP2PIE = false;
    } 
    else if (p2pies.Count == 1)
    {
        containP2PIE = true;
        element = DecodeP2PIE(p2pies[0]);
        informationElement += [element];
    }
    else
    {
        containP2PIE = true;
        binary data = $[];
        uint length = 0;
        // reassemble the data in multiple IEs.
        foreach (WiFi.VendorSpecificInformation vsi in p2pies)
        {
            data += (vsi.VendorSpecificContent as binary).PeekBytes(1 * 8);
            length += vsi.Length;  
        }
        reassembledElement.ElementID = 0xDD;
        reassembledElement.Length = length as ushort;
        reassembledElement.OUI = $[506F9A];
        reassembledElement.OUIType = 0x09;
        switch (data)
        {
            case attrArray:P2PAttributeArray from BinaryDecoder<P2PAttributeArray> =>
                reassembledElement.P2PAttributes = attrArray.Attributes;
            default =>
                ThrowDecodingException("WiFiDirect", "P2PAttributeArray"); 
        }
        informationElement += [reassembledElement]; 
    }
    return informationElement;
}

autostart actor WiFiDirectOverWiFi(WiFi.Node node)
{
    // Parse Management Frames
    // Beacon frame
    observe node accepts m:WiFiMessage where (m.Frame is WiFi.BeaconFrame) 
    {
        var frame = m.Frame as WiFi.BeaconFrame;
        bool isP2PIE = false;
        array<InformationElement> elements = DecodeP2PIEInIEArray(frame.InformationElements, ref isP2PIE);
        if (isP2PIE)
        {
            frame.InformationElements = elements;
        }
    }

    // Probe Request frame
    observe node accepts m:WiFiMessage where (m.Frame is WiFi.ProbeRequestFrame)
    {
        var frame = m.Frame as WiFi.ProbeRequestFrame;
        bool isP2PIE = false;
        array<InformationElement> elements = DecodeP2PIEInIEArray(frame.InformationElements, ref isP2PIE);
        if (isP2PIE)
        {
            frame.InformationElements = elements;
        }
    }

    // Probe Response frame
    observe node accepts m:WiFiMessage where (m.Frame is WiFi.ProbeResponseFrame)
    {
        var frame = m.Frame as WiFi.ProbeResponseFrame;
        bool isP2PIE = false;
        array<InformationElement> elements = DecodeP2PIEInIEArray(frame.InformationElements, ref isP2PIE);
        if (isP2PIE)
        {
            frame.InformationElements = elements;
        }
    }

    // Association Request frame
    observe node accepts m:WiFiMessage where (m.Frame is WiFi.AssociationRequestFrame)
    {
        var frame = m.Frame as WiFi.AssociationRequestFrame;
        bool isP2PIE = false;
        array<InformationElement> elements = DecodeP2PIEInIEArray(frame.InformationElements, ref isP2PIE);
        if (isP2PIE)
        {
            frame.InformationElements = elements;
        }
    }

    // Reassociation Request frame
    observe node accepts m:WiFiMessage where (m.Frame is WiFi.ReassociationRequestFrame)
    {
        var frame = m.Frame as WiFi.ReassociationRequestFrame;
        bool isP2PIE = false;
        array<InformationElement> elements = DecodeP2PIEInIEArray(frame.InformationElements, ref isP2PIE);
        if (isP2PIE)
        {
            frame.InformationElements = elements;
        }
    }

    // Association Response frame
    observe node accepts m:WiFiMessage where (m.Frame is WiFi.AssociationResponseFrame)
    {
        var frame = m.Frame as WiFi.AssociationResponseFrame;
        bool isP2PIE = false;
        array<InformationElement> elements = DecodeP2PIEInIEArray(frame.InformationElements, ref isP2PIE);
        if (isP2PIE)
        {
            frame.InformationElements = elements;
        }
    }

    // Reassociation Response frame
    observe node accepts m:WiFiMessage where (m.Frame is WiFi.ReassociationResponseFrame)
    {
        var frame = m.Frame as WiFi.ReassociationResponseFrame;
        bool isP2PIE = false;
        array<InformationElement> elements = DecodeP2PIEInIEArray(frame.InformationElements, ref isP2PIE);
        if (isP2PIE)
        {
            frame.InformationElements = elements;
        }
    }

    // Deauthentication frame
    observe node accepts m:WiFiMessage where (m.Frame is WiFi.Deauthentication)
    {
        var frame = m.Frame as WiFi.Deauthentication;
        bool isP2PIE = false;
        array<InformationElement> elements = DecodeP2PIEInIEArray(frame.InformationElements, ref isP2PIE);
        if (isP2PIE)
        {
            frame.InformationElements = elements;
        }
    }

    // Disassociation frame
    observe node accepts m:WiFiMessage where (m.Frame is WiFi.DisassociationFrame)
    {
        var frame = m.Frame as WiFi.DisassociationFrame;
        bool isP2PIE = false;
        array<InformationElement> elements = DecodeP2PIEInIEArray(frame.InformationElements, ref isP2PIE);
        if (isP2PIE)
        {
            frame.InformationElements = elements;
        }
    }
    
    // P2P public action frames
    process node accepts m:WiFiMessage where (m.Frame is WiFi.PublicActionFrame)
    {
        var frame = m.Frame as WiFi.PublicActionFrame;
        if (frame.Action is WiFi.VendorSpecificForPublic)
        {
            var vsfp = frame.Action as WiFi.VendorSpecificForPublic;
            if (vsfp.OUI == $[506F9A] && vsfp.Content.PeekByte(0) == 0x09)
            {
                GeneralP2PPublicAction general = new GeneralP2PPublicAction(vsfp);
                switch (general.OUISubtype)
                {
                    case P2PPublicAtcionFrameType.GONegotiationRequest => 
                        GONegotiationRequest f = new GONegotiationRequest(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PPublicAtcionFrameType.GONegotiationResponse => 
                        GONegotiationResponse f = new GONegotiationResponse(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PPublicAtcionFrameType.GONegotiationConfirmation => 
                        GONegotiationConfirmation f = new GONegotiationConfirmation(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PPublicAtcionFrameType.P2PInvitationRequest => 
                        P2PInvitationRequest f = new P2PInvitationRequest(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PPublicAtcionFrameType.P2PInvitationResponse => 
                        P2PInvitationResponse f = new P2PInvitationResponse(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PPublicAtcionFrameType.DeviceDiscoverabilityRequest => 
                        DeviceDiscoverabilityRequest f = new DeviceDiscoverabilityRequest(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PPublicAtcionFrameType.DeviceDiscoverabilityResponse => 
                        DeviceDiscoverabilityResponse f = new DeviceDiscoverabilityResponse(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PPublicAtcionFrameType.ProvisionDiscoveryRequest => 
                        ProvisionDiscoveryRequest f = new ProvisionDiscoveryRequest(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PPublicAtcionFrameType.ProvisionDiscoveryResponse => 
                        ProvisionDiscoveryResponse f = new ProvisionDiscoveryResponse(general);
                        dispatch (endpoint Node over node) accepts f;
                    default => ThrowDecodingException("WiFiDirect", "P2PPublicAtcionFrame");
                }
            }
        }
    }
    
    // P2P action frames
    process node accepts m:WiFiMessage where (m.Frame is WiFi.VendorSpecificActionFrame)
    {
        var frame = m.Frame as WiFi.VendorSpecificActionFrame;
        if (frame.Action is WiFi.VendorSpecificFrame)
        {
            var vsf = frame.Action as WiFi.VendorSpecificFrame;
            if (vsf.OUI == $[506F9A] && vsf.Content.PeekByte(0) == 0x09)
            {
                GeneralP2PAction general = new GeneralP2PAction(vsf);
                switch (general.OUISubtype)
                {
                    case P2PActionFrameType.NoticeOfAbsence => 
                        NoticeOfAbsence f = new NoticeOfAbsence(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PActionFrameType.P2PPresenceRequest =>
                        P2PPresenceRequest f = new P2PPresenceRequest(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PActionFrameType.P2PPresenceResponse =>
                        P2PPresenceResponse f = new P2PPresenceResponse(general);
                        dispatch (endpoint Node over node) accepts f;
                    case P2PActionFrameType.GODiscoverabilityRequest =>
                        GODiscoverabilityRequest f = new GODiscoverabilityRequest(general);
                        dispatch (endpoint Node over node) accepts f;
                    default => ThrowDecodingException("WiFiDirect", "P2PActionFrame");
                }
            }
        }
    }
}

// 4.1.1 P2P IE Format
type P2PIEBase
{
    (byte where value == 0xDD) ElementID;
    byte Length;
    (binary where value == $[506F9A]) OUI;
    (byte where value == 0x09) OUIType;
}

type P2PIE : P2PIEBase
{
    array<P2PAttribute> P2PAttributes;
}

type ReassembledP2PIE
{
    (byte where value == 0xDD) ElementID;
    ushort Length;
    (binary where value == $[506F9A]) OUI;
    (byte where value == 0x09) OUIType;
    array<P2PAttribute> P2PAttributes;
}

pattern InformationElement = P2PIE | ReassembledP2PIE | WiFi.InformationField; 

pattern AttributeID = enum byte
{
    Status = 0,
    MinorReasonCode = 1,
    P2PCapability = 2,
    P2PDeviceID = 3,
    GroupOwnerIntent = 4,
    ConfigurationTimeout = 5,
    ListenChannel = 6,
    P2PGroupBSSID = 7,
    ExtendedListenTiming = 8,
    IntendedP2PInterfaceAddress = 9,
    P2PManageability = 10,
    ChannelList = 11,
    NoticeOfAbsence = 12,
    P2PDeviceInfo = 13,
    P2PGroupInfo = 14,
    P2PGroupID = 15,
    P2PGroupInterface = 16,
    OperatingChannel = 17,
    InvitationFlags = 18,
    VendorSpecific = 221,
    ...
};

type AttributeBase
{
    AttributeID AttributeID;
    ushort Length;
}

type GeneralP2PAttribute : AttributeBase
{
    binary Body with BinaryEncoding{Length = Length};
}

// 4.1.2 Status attribute
pattern StatusCode = enum byte
{
    Success = 0,
    CurrentlyUnavailable = 1,
    IncompatibleParameters = 2,
    LimitReached = 3,
    InvalidParameters = 4,
    UnableToAccommodateRequest = 5,
    ProtocolErrorOrDiscruptiveBehavior = 6,
    NoCommonChannels = 7,
    UnknownP2PGroup = 8,
    ErrorInGroupOwnerNegotiation = 9,
    IncompatibleProvisioningMethod = 10,
    RejectedByUser = 11,
    ...
};

type Status : AttributeBase
{
    StatusCode StatusCode;
    invariant AttributeID == 0;
    
    string GetSummary()
    {
        switch (StatusCode)
        {
            case StatusCode.Success => return "Status: Success";
            case StatusCode.CurrentlyUnavailable => return "Status: Fail(CurrentlyUnavailable)";
            case StatusCode.IncompatibleParameters => return "Status: Fail(IncompatibleParameters)";
            case StatusCode.LimitReached => return "Status: Fail(LimitReached)";
            case StatusCode.InvalidParameters => return "Status: Fail(InvalidParameters)";
            case StatusCode.UnableToAccommodateRequest => return "Status: Fail(UnableToAccommodateRequest)";
            case StatusCode.ProtocolErrorOrDiscruptiveBehavior => return "Status: Fail(ProtocolErrorOrDiscruptiveBehavior)";
            case StatusCode.NoCommonChannels => return "Status: Fail(NoCommonChannels)";
            case StatusCode.UnknownP2PGroup => return "Status: Fail(UnknownP2PGroup)";
            case StatusCode.ErrorInGroupOwnerNegotiation => return "Status: Fail(ErrorInGroupOwnerNegotiation)";
            case StatusCode.IncompatibleProvisioningMethod => return "Status: Fail(IncompatibleProvisioningMethod)";
            case StatusCode.RejectedByUser => return "Status: Fail(RejectedByUser)";
            default => return "Status: Reserved";
        }
    }
}

// 4.1.3 Minor Reason Code attribute
type MinorReasonCode : AttributeBase
{
    byte MinorReasonCode;
    invariant AttributeID == 1;
}

// 4.1.4 P2P Capability attribute
pattern DeviceCapabilityBitmapDefinition = flags byte
{
    ServiceDiscovery = 0x01,
    P2PClientDiscoverability = 0x02,
    ConcurrentOperation = 0x04,
    P2PInfrastructureManaged = 0x08,
    P2PDeviceLimit = 0x10,
    P2PInvitationProcedure = 0x20,
    ...
};

pattern GroupCapabilityBitmapDefinition = flags byte
{
    P2PGroupOwner = 0x01,
    PersistentP2PGroup = 0x02,
    P2PGroupLimit = 0x04,
    IntraBSSDistribution = 0x08,
    CrossConnection = 0x10,
    PersistentReconnect = 0x20,
    GroupFormation = 0x40,
    ...
};

type P2PCapability : AttributeBase
{
    DeviceCapabilityBitmapDefinition DeviceCapabilityBitmap;
    GroupCapabilityBitmapDefinition GroupCapabilityBitmap;
    invariant AttributeID == 2;
}

// 4.1.5 P2P Device ID attribute
type P2PDeviceID : AttributeBase
{
    Utility.MacAddress P2PDeviceAddress;
    invariant AttributeID == 3;
    
    string GetSummary()
    {
        return "P2PDeviceID: P2PDeviceAddress = " + (P2PDeviceAddress as string);
    }
}

// 4.1.6 Group Owner Intent attribute
type GroupOwnerIntentAttribute_GOIntent
{
    byte Intent with BinaryEncoding{Width = 7};
    byte TieBreaker with BinaryEncoding{Width = 1};
}

type GroupOwnerIntent : AttributeBase
{
    GroupOwnerIntentAttribute_GOIntent GOIntent;
    invariant AttributeID == 4;
    
    string GetSummary()
    {
        return "GroupOwnerIntent: TieBreaker = " + (GOIntent.TieBreaker as string) + ", Intent = " + (GOIntent.Intent as string);
    }
}

// 4.1.7 Configuration Timeout attribute
type ConfigurationTimeout : AttributeBase
{
    byte GOConfigurationTimeout;
    byte ClientConfigurationTimeout;
    invariant AttributeID == 5;
}

// 4.1.8 Listen Channel attribute
// WORKAROUND: bug#57548, when using BinaryDecoder<A|B>(data) , it will report ValidationCheck 
// error information of Type A, even if it can not be decoded as Type A actually.
//type ListenChannel : AttributeBase
//{
    //binary CountryString where ValidationCheck(value[2] == 0x04, null, CoreResources.WiFiDirect_STR_1)
        //with BinaryEncoding{Length = 3};
    //byte OperatingClass;
    //byte ChannelNumber;
    //invariant AttributeID == 6;
//}

type ListenChannel
{
    (AttributeID where value == 6) AttributeID;
    ushort Length;
    binary CountryString where ValidationCheck(value[2] == 0x04, null, CoreResources.WiFiDirect_STR_1)
        with BinaryEncoding{Length = 3};
    byte OperatingClass;
    byte ChannelNumber;
}

// 4.1.9 P2P Group BSSID attribute
type P2PGroupBSSID : AttributeBase
{
    Utility.MacAddress P2PGroupBSSID;
    invariant AttributeID == 7;
    
    string GetSummary()
    {
        return "P2PGroupBSSID: " + P2PGroupBSSID.ToString();
    }
}

// 4.1.10 Extended Listen Timing attribute
type ExtendedListenTiming : AttributeBase
{
    ushort AvailabilityPeriod;
    ushort AvailabilityInterval;
    invariant AttributeID == 8;
}

// 4.1.11 Intended P2P Interface Address attribute
type IntendedP2PInterfaceAddress : AttributeBase
{
    Utility.MacAddress P2PInterfaceAddress;
    invariant AttributeID == 9;
}

// 4.1.12 P2P Manageability attribute
pattern P2PManageability_ManageabilityBitmap = flags byte
{
    P2PDeviceManagement = 0x01, // The WLAN AP supports Managed P2P Device
    CrossConnectionPermitted = 0x02, // The WLAN AP permits P2P Concurrent Devices to offer cross connection
    CoexistenceOptional = 0x04, // The Primary P2P Coexistence Parameters and recommended secondary P2P Coexistence Parameters advertised by the WLAN AP are not required.
    ...
};

type P2PManageability : AttributeBase
{
    P2PManageability_ManageabilityBitmap ManageabilityBitmap;
    invariant AttributeID == 10;
}

// 4.1.13 Channel List attribute
type ChannelEntry
{
    byte OperatingClass;
    byte NumberOfChannels;
    array<byte> ChannelList with BinaryEncoding{Length = NumberOfChannels};
}

// WORKAROUND: bug#57548, when using BinaryDecoder<A|B>(data) , it will report ValidationCheck 
// error information of Type A, even if it can not be decoded as Type A actually.
type ChannelList
{
    (AttributeID where value == 11) AttributeID;
    ushort Length;
    binary CountryString where ValidationCheck(value[2] == 0x04, null, CoreResources.WiFiDirect_STR_1)
        with BinaryEncoding{Length = 3};
    array<ChannelEntry> ChannelEntryList with BinaryEncoding{WidthForComposedType = (Length - 3) * 8};
}

// 4.1.14 Notice of Absence attribute
type NoticeOfAbsence_CTWindowAndOppPSParameters
{
    byte CTWindow with BinaryEncoding{Width = 7};
    byte OppPS with BinaryEncoding{Width =1};
}

type NoticeOfAbsence_NoticeOfAbsenceDescriptor
{
    byte CountType;
    uint Duration;
    uint Interval;
    uint StartTime;
}

type NoticeOfAbsenceAttr : AttributeBase
{
    byte Index;
    NoticeOfAbsence_CTWindowAndOppPSParameters CTWindowAndOppPSParameters;
    array<NoticeOfAbsence_NoticeOfAbsenceDescriptor> NoticeOfAbsenceDescriptors with BinaryEncoding{Length = (Length - 2) / 13 as uint};
    invariant AttributeID == 12;
    
    string GetSummary()
    {
        return "NoticeOfAbsence, Index: " + (Index as string) + ", OppPS: " + (CTWindowAndOppPSParameters.OppPS as string);
    }
}

// B.2 Primary Device Type
pattern PrimaryDeviceType_CategoryID = enum ushort
{
    Computer = 1,
    InputDevice = 2,
    PrintersScannersFaxesAndCopiers = 3,
    Camera = 4,
    Storage = 5,
    NetworkInfrastructure = 6,
    Displays = 7,
    MultimediaDevices = 8,
    GamingDevices = 9,
    Telephone = 10,
    AudioDevices = 11,
    Others = 255
};

pattern ComputerSubCategory = enum ushort
{
    PC = 1,
    Server = 2,
    MediaCenter = 3,
    UltramobilePC = 4,
    Notebook = 5,
    Desktop = 6,
    MID = 7,
    Netbook = 8
};

pattern InputDeviceSubCategory = enum ushort
{
    Keyboard = 1,
    Mouse = 2,
    Joystick = 3,
    Trackball = 4,
    GamingController = 5,
    Remote = 6,
    Touchscreen = 7,
    BiometricReader = 8,
    BarcodeReader = 9
};

pattern PrintersScannersFaxesAndCopiersSubCategory = enum ushort
{
    PrinterOrPrinterServer = 1,
    Scanner = 2,
    Fax =3,
    Copier = 4,
    AllInOne = 5
};

pattern CameraSubCategory = enum ushort
{
    DigitalStillCamera = 1,
    VideoCamera = 2,
    WebCamera = 3,
    SecurityCamera = 4
};

pattern StorageSubCategory = enum ushort
{
    NAS = 1
};

pattern NetworkInfrastructureSubCategory = enum ushort
{
    AP = 1,
    Router = 2,
    Switch = 3,
    Gateway = 4
};

pattern DisplaysSubCategory = enum ushort
{
    Television = 1,
    ElectronicPictureFrame = 2,
    Projector = 3,
    Monitor = 4
};

pattern MultimediaDevicesSubCategory = enum ushort
{
    DAR = 1,
    PVR = 2,
    MCX = 3,
    SetTopBox = 4,
    MediaServerMediaAdapterMediaExtender = 5,
    PortableVideoPlayer = 6
};

pattern GamingDevicesSubCategory = enum ushort
{
    Xbox = 1,
    Xbox360 = 2,
    Playstation = 3,
    GameConsoleGameConsoleAdapter = 4,
    PortableGamingDevice = 5
};

pattern TelephoneSubCategory = enum ushort
{
    WindowsMobile = 1,
    PhoneSingleMode = 2,
    PhoneDualMode = 3,
    SmartphoneSingleMode = 4,
    SmartphoneDualMode = 5
};

pattern AudioDevicesSubCategory = enum ushort
{
    AudioTunerReceiver = 1,
    Speakers = 2,
    PortableMusicPlayer = 3,
    Headset = 4,
    Headphones = 5,
    Microphone = 6
};

type PrimaryDeviceType
{
    PrimaryDeviceType_CategoryID CategoryID;
    uint OUI with DisplayInfo{ToText = UInt2Hex};
    ([|CategoryID == PrimaryDeviceType_CategoryID.Computer|] ComputerSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.InputDevice|] InputDeviceSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.PrintersScannersFaxesAndCopiers|] PrintersScannersFaxesAndCopiersSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.Camera|] CameraSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.Storage|] StorageSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.NetworkInfrastructure|] NetworkInfrastructureSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.Displays|] DisplaysSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.MultimediaDevices|] MultimediaDevicesSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.GamingDevices|] GamingDevicesSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.Telephone|] TelephoneSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.AudioDevices|] AudioDevicesSubCategory | 
    [|CategoryID == PrimaryDeviceType_CategoryID.Others|] ushort
    ) SubCategoryID;
}
with BinaryEncodingDefaults {Endian = Endian.Big};

// Wi-Fi Protected Setup Specification Version 1.0h, section 11. Data Element Definitions
// Secondary Device Type List
typedef SecondaryDeviceType = PrimaryDeviceType;

// Config Methods
pattern ConfigMethods = flags ushort
{
    USBA = 0x0001,
    Ethernet = 0x0002,
    Label = 0x0004,
    Display = 0x0008,
    ExternalNFCToken = 0x0010,
    IntegratedNFCToken = 0x0020,
    NFCInterface = 0x0040,
    PushButton = 0x0080,
    Keypad = 0x0100
} with BinaryEncoding{Endian = Endian.Big};

// Wi-Fi Protected Setup Specification Version 1.0h, section 7.1. Wi-Fi Protected Setup TLV Data Format
type WiFiProtectedSetupTLV
{
    ushort AttributeType with DisplayInfo{ToText = UShort2Hex};
    ushort DataLength;
    string Data with BinaryEncoding{Length = DataLength};
}
with BinaryEncodingDefaults {Endian = Endian.Big};
 
// 4.1.15 P2P Device Info attribute
type P2PDeviceInfo : AttributeBase
{
    Utility.MacAddress P2PDeviceAddress;
    ConfigMethods ConfigMethods
        with DisplayInfo{ToText = UShort2Hex};
    PrimaryDeviceType PrimaryDeviceType;
    byte NumberOfSecondaryDeviceTypes;
    optional [|NumberOfSecondaryDeviceTypes > 0|] array<SecondaryDeviceType> SecondaryDeviceTypeList with BinaryEncoding{Length = NumberOfSecondaryDeviceTypes, Endian = Endian.Big};
    WiFiProtectedSetupTLV DeviceName with BinaryEncoding{WidthForComposedType = (Length - 17 - 8 * NumberOfSecondaryDeviceTypes) * 8};
    invariant AttributeID == 13;
    
    string GetSummary()
    {
        return "P2PDeviceAddress: " + P2PDeviceAddress.ToString();
    }
}

// 4.1.16 P2P Group Info attribute
type P2PClientInfoDescriptor
{
    byte Length;
    Utility.MacAddress P2PDeviceAddress;
    Utility.MacAddress P2PInterfaceAddress;
    DeviceCapabilityBitmapDefinition DeviceCapabilityBitmap;
    ConfigMethods ConfigMethods with BinaryEncoding{Endian = Endian.Big}
        with DisplayInfo{ToText = UShort2Hex};
    PrimaryDeviceType PrimaryDeviceType;
    byte NumberOfSecondaryDeviceTypes;
    optional [|NumberOfSecondaryDeviceTypes > 0|] array<SecondaryDeviceType> SecondaryDeviceTypeList with BinaryEncoding{Length = NumberOfSecondaryDeviceTypes, Endian = Endian.Big};
    WiFiProtectedSetupTLV DeviceName with BinaryEncoding{WidthForComposedType = (Length - 24 - 8 * NumberOfSecondaryDeviceTypes) * 8};
}

type P2PGroupInfo : AttributeBase
{
    Utility.MacAddress P2PDeviceAddress;
    array<P2PClientInfoDescriptor> P2PClientInfoDescriptors with BinaryEncoding{Length = Length};
    invariant AttributeID == 14;
}

// 4.1.17 P2P Group ID attribute
type P2PGroupID : AttributeBase
{
    Utility.MacAddress P2PDeviceAddress;
    optional [|Length - 6 > 0|]string SSID with BinaryEncoding{Length = (Length - 6) as uint};
    invariant AttributeID == 15;
    
    string GetSummary()
    {
        return "P2PGroupID: " + P2PDeviceAddress.ToString();
    }
}

// 4.1.18 P2P Interface attribute
type P2PInterface : AttributeBase
{
    Utility.MacAddress P2PDeviceAddress;
    byte P2PInterfaceAddressCount;
    array<Utility.MacAddress> P2PDeviceAddressList with BinaryEncoding{Length = P2PInterfaceAddressCount};
    invariant AttributeID == 16;
}

// 4.1.19 Operating Channel attribute
// WORKAROUND: bug#57548, when using BinaryDecoder<A|B>(data) , it will report ValidationCheck 
// error information of Type A, even if it can not be decoded as Type A actually.
type OperatingChannel
{
    (AttributeID where value == 17) AttributeID;
    ushort Length;
    binary CountryString where ValidationCheck(value[2] == 0x04, null, CoreResources.WiFiDirect_STR_1)
        with BinaryEncoding{Length = 3};
    byte OperatingClass;
    byte ChannelNumber;
}

// 4.1.20 Invitation Flags attribute
pattern InvitationFlagsBitmap = flags byte
{
    InvitationType = 0x01, //Set to 1 to indicate a P2P Invitation Request to re-invoke a Persistent Group, set to 0 to indicate a P2P Invitation Request to join an active P2P Group.
    ...
};

type InvitationFlags : AttributeBase
{
    WiFiDirect.InvitationFlagsBitmap InvitationFlagsBitmap;
    invariant AttributeID == 18;
}

pattern P2PAttribute = (
    Status |
    MinorReasonCode |
    P2PCapability |
    P2PDeviceID |
    GroupOwnerIntent |
    ConfigurationTimeout |
    ListenChannel |
    P2PGroupBSSID |
    ExtendedListenTiming |
    IntendedP2PInterfaceAddress |
    P2PManageability |
    ChannelList |
    NoticeOfAbsenceAttr |
    P2PDeviceInfo |
    P2PGroupInfo |
    P2PGroupID |
    P2PInterface |
    OperatingChannel |
    InvitationFlags |
    GeneralP2PAttribute);

type P2PAttributeArray
{
    array<P2PAttribute> Attributes;
}

// 4.2.8.1 General format
pattern P2PPublicAtcionFrameType = enum byte{
    GONegotiationRequest = 0,
    GONegotiationResponse = 1,
    GONegotiationConfirmation = 2,
    P2PInvitationRequest = 3,
    P2PInvitationResponse = 4,
    DeviceDiscoverabilityRequest = 5,
    DeviceDiscoverabilityResponse = 6,
    ProvisionDiscoveryRequest = 7,
    ProvisionDiscoveryResponse = 8
};

message GeneralP2PPublicActionBase
{
    (byte where value == 0x04) Category;
    (byte where value == 0x09) Action;
    (binary where value == $[506F9A]) OUI with BinaryEncoding{Length = 3};
    (byte where value == 0x09) OUIType;
    P2PPublicAtcionFrameType OUISubtype;
    byte DialogToken where ValidationCheck(value > 0, null, "WiFiDirect: DialogToken field of GeneralP2PPublicActionFrame should set to a nonzero value."); 
}

message GeneralP2PPublicAction : GeneralP2PPublicActionBase
{
    binary Data;
    
    GeneralP2PPublicAction(WiFi.VendorSpecificForPublic m)
    {
        if (m.OUI == $[506F9A] && m.Content.PeekByte(0) == 0x09)
        {
            Category = m.Category;
            Action = m.Action;
            OUI = m.OUI;
            OUIType = 0x09;
            OUISubtype = m.Content.PeekByte(1 * 8);
            DialogToken = m.Content.PeekByte(2 * 8);
            Data = m.Content.PeekBytes(3 * 8);
        }
    }
}

// This type is defined for manually decoding use.
type P2PIEOrVendorSpecificIEArray
{
    array<InformationElement> Elements;
}

// 4.2.8.2 Go Negotiation Request frame
message GONegotiationRequest : GeneralP2PPublicActionBase
{
    array<InformationElement> Elements;
    invariant OUISubtype == P2PPublicAtcionFrameType.GONegotiationRequest;

    public GONegotiationRequest(GeneralP2PPublicAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "GoNegotiationRequest");
        }
    }

    override string ToString()
    {
        string summary = "GoNegotiationRequest, DialogToken: " + (DialogToken as string);
        foreach (InformationElement ie in Elements)
        {
            array<P2PAttribute> attrs = [];
            if (ie is P2PIE)
            {
                attrs = (ie as P2PIE).P2PAttributes;
            }
            else if (ie is ReassembledP2PIE)
            {
                attrs = (ie as ReassembledP2PIE).P2PAttributes;
            }
            
            foreach (P2PAttribute a in attrs)
            {
                if (a is P2PDeviceInfo)
                {
                    summary += ", Group Owner Negotiate with a P2P Device: " + (a as P2PDeviceInfo).P2PDeviceAddress.ToString();
                }
                else if (a is GroupOwnerIntent)
                {
                    summary += ", " + (a as GroupOwnerIntent).GetSummary();
                }
            }
        }
        return summary;
    }
}

// 4.2.8.3 Go Negotiation Response Frame
message GONegotiationResponse : GeneralP2PPublicActionBase 
{
    array<InformationElement> Elements;
    invariant OUISubtype == P2PPublicAtcionFrameType.GONegotiationResponse;

    GONegotiationResponse(GeneralP2PPublicAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "GONegotiationResponse");
        }
    }

    override string ToString()
    {
        string summary = "GONegotiationResponse, DialogToken: " + (DialogToken as string);
        foreach (InformationElement ie in Elements)
        {
            array<P2PAttribute> attrs = [];
            if (ie is P2PIE)
            {
                attrs = (ie as P2PIE).P2PAttributes;
            }
            else if (ie is ReassembledP2PIE)
            {
                attrs = (ie as ReassembledP2PIE).P2PAttributes;
            }
            
            foreach (P2PAttribute a in attrs)
            {
                if (a is Status)
                {
                    summary += ", " + (a as Status).GetSummary();
                }
                else if (a is GroupOwnerIntent)
                {
                    summary += ", " + (a as GroupOwnerIntent).GetSummary();
                }
                else if (a is P2PDeviceInfo)
                {
                    summary += ", " + (a as P2PDeviceInfo).GetSummary();
                }
            }
        }
        return summary;
    }
}

// 4.2.8.3 Go Negotiation Confirmation frame
message GONegotiationConfirmation : GeneralP2PPublicActionBase 
{
    array<InformationElement> Elements;
    invariant OUISubtype == P2PPublicAtcionFrameType.GONegotiationConfirmation;
        
    GONegotiationConfirmation(GeneralP2PPublicAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "GONegotiationConfirmation");
        }
    }

    override string ToString()
    {
        string summary = "GONegotiationConfirmation, DialogToken: " + (DialogToken as string);
        foreach (InformationElement ie in Elements)
        {
            array<P2PAttribute> attrs = [];
            if (ie is P2PIE)
            {
                attrs = (ie as P2PIE).P2PAttributes;
            }
            else if (ie is ReassembledP2PIE)
            {
                attrs = (ie as ReassembledP2PIE).P2PAttributes;
            }
            
            foreach (P2PAttribute a in attrs)
            {
                if (a is Status)
                {
                    summary += ", " + (a as Status).GetSummary();
                }
                else if (a is P2PGroupID)
                {
                    summary += ", " + (a as P2PGroupID).GetSummary();
                }
            }
        }
        return summary;
    }
}

// 4.2.8.5 P2P Invitation Request frame
message P2PInvitationRequest : GeneralP2PPublicActionBase 
{
    array<InformationElement> Elements;
    invariant OUISubtype == P2PPublicAtcionFrameType.P2PInvitationRequest;
        
    P2PInvitationRequest(GeneralP2PPublicAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "P2PInvitationRequest");
        }
    }

    override string ToString()
    {
        string summary = "P2PInvitationRequest, DialogToken: " + (DialogToken as string);
        foreach (InformationElement ie in Elements)
        {
            array<P2PAttribute> attrs = [];
            if (ie is P2PIE)
            {
                attrs = (ie as P2PIE).P2PAttributes;
            }
            else if (ie is ReassembledP2PIE)
            {
                attrs = (ie as ReassembledP2PIE).P2PAttributes;
            }
            
            foreach (P2PAttribute a in attrs)
            {
                if (a is P2PDeviceInfo)
                {
                    summary += ", Invitate a P2P Device: " + (a as P2PDeviceInfo).P2PDeviceAddress.ToString();
                }
                else if (a is P2PGroupID)
                {
                    summary += " to join the P2P Group: " + (a as P2PGroupID).P2PDeviceAddress.ToString();
                }
            }
        }
        return summary;
    }
}

// 4.2.8.6 P2P Invitation Response frame
message P2PInvitationResponse : GeneralP2PPublicActionBase 
{
    array<InformationElement> Elements;
    invariant OUISubtype == P2PPublicAtcionFrameType.P2PInvitationResponse;

    P2PInvitationResponse(GeneralP2PPublicAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "P2PInvitationResponse");
        }
    }

    override string ToString()
    {
        string summary = "P2PInvitationResponse, DialogToken: " + (DialogToken as string);
        foreach (InformationElement ie in Elements)
        {
            array<P2PAttribute> attrs = [];
            if (ie is P2PIE)
            {
                attrs = (ie as P2PIE).P2PAttributes;
            }
            else if (ie is ReassembledP2PIE)
            {
                attrs = (ie as ReassembledP2PIE).P2PAttributes;
            }
            
            foreach (P2PAttribute a in attrs)
            {
                if (a is Status)
                {
                    summary += ", " + (a as Status).GetSummary();
                    break;
                }
            }
        }
        return summary;
    }
}

// 4.2.8. Device Discoverability Request frame
message DeviceDiscoverabilityRequest : GeneralP2PPublicActionBase
{
    array<InformationElement> Elements;
    invariant OUISubtype == P2PPublicAtcionFrameType.DeviceDiscoverabilityRequest;

    DeviceDiscoverabilityRequest(GeneralP2PPublicAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "DeviceDiscoverabilityRequest");
        }
    }

    override string ToString()
    {
        string summary = "DeviceDiscoverabilityRequest, DialogToken: " + (DialogToken as string);
        foreach (InformationElement ie in Elements)
        {
            array<P2PAttribute> attrs = [];
            if (ie is P2PIE)
            {
                attrs = (ie as P2PIE).P2PAttributes;
            }
            else if (ie is ReassembledP2PIE)
            {
                attrs = (ie as ReassembledP2PIE).P2PAttributes;
            }
            
            foreach (P2PAttribute a in attrs)
            {
                if (a is P2PDeviceID)
                {
                    summary += ", Discover a P2P Device: " + (a as P2PDeviceID).P2PDeviceAddress.ToString();
                }
                else if (a is P2PGroupID)
                {
                    summary += " in the P2P Group: " + (a as P2PGroupID).P2PDeviceAddress.ToString();
                }
            }
        }
        return summary;
    }
}

// 4.2.8. Device Discoverability Response frame
message DeviceDiscoverabilityResponse : GeneralP2PPublicActionBase
{
    array<InformationElement> Elements;
    invariant OUISubtype == P2PPublicAtcionFrameType.DeviceDiscoverabilityResponse;

    DeviceDiscoverabilityResponse(GeneralP2PPublicAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "DeviceDiscoverabilityResponse");
        }
    }
    
    override string ToString()
    {
        string summary = "DeviceDiscoverabilityResponse, DialogToken: " + (DialogToken as string);
        foreach (InformationElement ie in Elements)
        {
            array<P2PAttribute> attrs = [];
            if (ie is P2PIE)
            {
                attrs = (ie as P2PIE).P2PAttributes;
            }
            else if (ie is ReassembledP2PIE)
            {
                attrs = (ie as ReassembledP2PIE).P2PAttributes;
            }
            
            foreach (P2PAttribute a in attrs)
            {
                if (a is Status)
                {
                    summary += ", " + (a as Status).GetSummary();
                    break;
                }
            }
        }
        return summary;
    }
}

// 4.2.8.9 Provision Discovery Request frame
message ProvisionDiscoveryRequest : GeneralP2PPublicActionBase
{
    array<InformationElement> Elements;
    invariant OUISubtype == P2PPublicAtcionFrameType.ProvisionDiscoveryRequest;

    ProvisionDiscoveryRequest(GeneralP2PPublicAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "ProvisionDiscoveryRequest");
        }
    }

    override string ToString()
    {
        string summary = "ProvisionDiscoveryRequest, DialogToken: " + (DialogToken as string);
        foreach (InformationElement ie in Elements)
        {
            array<P2PAttribute> attrs = [];
            if (ie is P2PIE)
            {
                attrs = (ie as P2PIE).P2PAttributes;
            }
            else if (ie is ReassembledP2PIE)
            {
                attrs = (ie as ReassembledP2PIE).P2PAttributes;
            }
            
            foreach (P2PAttribute a in attrs)
            {
                if (a is P2PDeviceInfo)
                {
                    summary += ", Provision for a P2P Device: " + (a as P2PDeviceInfo).P2PDeviceAddress.ToString();
                }
                else if (a is P2PGroupID)
                {
                    summary += " in the P2P Group: " + (a as P2PGroupID).P2PDeviceAddress.ToString();
                }
            }
        }
        return summary;
    }
}

type VendorSpecificInformationArray
{
    array<WiFi.VendorSpecificInformation> IEArray;
}

// 4.2.8.10 Provision Discovery Response frame
message ProvisionDiscoveryResponse : GeneralP2PPublicActionBase
{
    array<WiFi.VendorSpecificInformation> Elements;
    invariant OUISubtype == P2PPublicAtcionFrameType.ProvisionDiscoveryResponse;

    ProvisionDiscoveryResponse(GeneralP2PPublicAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:VendorSpecificInformationArray from BinaryDecoder<VendorSpecificInformationArray> =>
                Elements = ie.IEArray;
            default =>
                ThrowDecodingException("WiFiDirect", "ProvisionDiscoveryResponse");
        }
    }

    override string ToString()
    {
        string summary = "ProvisionDiscoveryResponse, DialogToken: " + (DialogToken as string);
        return summary;
    }
}

// 4.2.9 P2P action frame
// 4.2.9.1 General format
message GeneralP2PActionBase
{
    (byte where value == 0x7F) Category;
    (binary where value == $[506F9A]) OUI with BinaryEncoding{Length = 3};
    (byte where value == 0x09) OUIType;
    P2PActionFrameType OUISubtype;
    byte DialogToken;
}

message GeneralP2PAction : GeneralP2PActionBase
{
    binary Data;
    GeneralP2PAction(WiFi.VendorSpecificFrame m)
    {
        if (m.OUI == $[506F9A] && m.Content.PeekByte(0) == 0x09)
        {
            Category = m.Category;
            OUI = m.OUI;
            OUIType = 0x09;
            OUISubtype = m.Content.PeekByte(1 * 8);
            DialogToken = m.Content.PeekByte(2 * 8);
            Data = m.Content.PeekBytes(3 * 8);
        }
    }
}

pattern P2PActionFrameType = enum byte
{
    NoticeOfAbsence = 0,
    P2PPresenceRequest = 1,
    P2PPresenceResponse = 2,
    GODiscoverabilityRequest = 3
};

// 4.2.9.2 Notice of Absence frame
message NoticeOfAbsence : GeneralP2PActionBase
{
    array<InformationElement> Elements with BinaryEncoding{Length = 1};

    NoticeOfAbsence(GeneralP2PAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "NoticeOfAbsence");
        }
    }
    
    override string ToString()
    {
        string summary = "NoticeOfAbsence, DialogToken: " + (DialogToken as string);
        return summary;
    }
}

// 4.2.9.3 P2P Presence Request frame
message P2PPresenceRequest : GeneralP2PActionBase
{
    array<InformationElement> Elements with BinaryEncoding{Length = 1};

    P2PPresenceRequest(GeneralP2PAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "P2PPresenceRequest");
        }
    }

    override string ToString()
    {
        string summary = "P2PPresenceRequest, DialogToken: " + (DialogToken as string);
        return summary;
    }
}

// 4.2.9.4 P2P Presence Response frame
message P2PPresenceResponse : GeneralP2PActionBase
{
    array<InformationElement> Elements with BinaryEncoding{Length = 1};

    P2PPresenceResponse(GeneralP2PAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
        switch (general.Data)
        {
            case ie:P2PIEOrVendorSpecificIEArray from BinaryDecoder<P2PIEOrVendorSpecificIEArray> =>
                bool containP2PIE = false;
                Elements = DecodeP2PIEInIEArray(ie.Elements, ref containP2PIE);
            default =>
                ThrowDecodingException("WiFiDirect", "P2PPresenceResponse");
        }
    }

    override string ToString()
    {
        string summary = "P2PPresenceResponse, DialogToken: " + (DialogToken as string);
        foreach (InformationElement ie in Elements)
        {
            array<P2PAttribute> attrs = [];
            if (ie is P2PIE)
            {
                attrs = (ie as P2PIE).P2PAttributes;
            }
            else if (ie is ReassembledP2PIE)
            {
                attrs = (ie as ReassembledP2PIE).P2PAttributes;
            }

            foreach (P2PAttribute a in attrs)
            {
                if (a is NoticeOfAbsence)
                {
                    summary += ", " + (a as NoticeOfAbsenceAttr).GetSummary();
                    break;
                }
            }
        }
        return summary;
    }
}

// 4.2.9.2 GO Discoverability Request frame
message GODiscoverabilityRequest : GeneralP2PActionBase
{
    // There is no Elements field in a GO Discoverability Request frame
    invariant DialogToken == 0;

    GODiscoverabilityRequest(GeneralP2PAction general)
    {
        Category = general.Category;
        OUI = general.OUI;
        OUIType = general.OUIType;
        OUISubtype = general.OUISubtype;
        DialogToken = general.DialogToken;
    }

    override string ToString()
    {
        string summary = "GODiscoverabilityRequest, DialogToken: " + (DialogToken as string);
        return summary;
    }
}

static string UInt2Hex(any i)
{
    return Utility.DecToHexFormat(i);
}

static string UShort2Hex(any i)
{
    return Utility.DecToHexFormat(i);
}
