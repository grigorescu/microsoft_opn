protocol PPTP with 
BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "Point-to-Point Tunneling Protocol",
    ShortName = "PPTP",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 2637"},
            new Reference{Name = "PPTP", Link = "http://www.networksorcery.com/enp/protocol/pptp.htm"},
        ],
    RevisionSummary =
        [
            new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "11/22/2011"}
        ]
};

using Utility;
using Standard;
using TCP;
using IANA;
using VirtualTransport;
using Reassembly;

endpoint Server over VirtualTransport.Server accepts Datagram issues Datagram;
client endpoint Client connected to Server;

autostart actor PPTPOverTCP(VirtualTransport.Server server)
{
    DecodingCache inboundCache = null;
    DecodingCache outboundCache = null;
    DecodingCache inboundCacheForTCPMistake = null;
    DecodingCache outboundCacheForTCPMistake = null;
    
    process server issues s:VirtualTransport.VirtualDataSegment where s.SourcePort == Port.PPTP
    {
        if (outboundCache == null)
        {
            outboundCache = new DecodingCache{ Dispatcher = IssueDispatcher };
        }
        
        outboundCache.Add(s);
        outboundCache.TryDecodeMsgAndDispatch();
    }
    process server accepts s:VirtualTransport.VirtualDataSegment where s.DestinationPort == Port.PPTP
    {
        if (inboundCache == null)
        {
            inboundCache = new DecodingCache{ Dispatcher = AcceptDispatcher };
        }
        
        inboundCache.Add(s);
        inboundCache.TryDecodeMsgAndDispatch();
    }
    
    // Below rules are added in case that TCP mistakes the Client for Server by port number for the trace without TCP 3-way handshake.
    process server accepts s:VirtualTransport.VirtualDataSegment where server.isMissingThreeWayHandshake && s.SourcePort == Port.PPTP
    {
        if (inboundCacheForTCPMistake == null)
        {
            inboundCacheForTCPMistake = new DecodingCache{ Dispatcher = IssueDispatcher };
        }
        
        inboundCacheForTCPMistake.Add(s);
        inboundCacheForTCPMistake.TryDecodeMsgAndDispatch();
    }
    process server issues s:VirtualTransport.VirtualDataSegment where server.isMissingThreeWayHandshake && s.DestinationPort == Port.PPTP
    {
        if (outboundCacheForTCPMistake == null)
        {
            outboundCacheForTCPMistake = new DecodingCache{ Dispatcher = AcceptDispatcher };
        }
        
        outboundCacheForTCPMistake.Add(s);
        outboundCacheForTCPMistake.TryDecodeMsgAndDispatch();
    }
    
    void AcceptDispatcher(Datagram datagram)
    {
        dispatch endpoint Server over server accepts datagram;
    }
    
    void IssueDispatcher(Datagram datagram)
    {
        dispatch endpoint Server over server issues datagram;
    }
    
    ~endpoint(VirtualTransport.Server server)
    {
        if (inboundCache != null)
        {
            inboundCache.Clear();
        }
        if (outboundCache != null)
        {
            outboundCache.Clear();
        }
        if (inboundCacheForTCPMistake != null)
        {
            inboundCacheForTCPMistake.Clear();
        }
        if (outboundCacheForTCPMistake != null)
        {
            outboundCacheForTCPMistake.Clear();
        }
    }
}

message Datagram
{
    PPTPHead PPTPHead;
    ([|PPTPHead.MessageType == 1|] ControlMessage
        | [|PPTPHead.MessageType == 2|] ManagementMessage[PPTPHead.Length - 8 as ushort]
        | Blob[PPTPHead.Length - 8 as uint]) Message;
    
    override string ToString()
    {
        string displayStr = "PPTP: ";
        switch (PPTPHead.MessageType)
        {
            case 1 => 
                displayStr += "Control Message, ";
                var msg = Message as ControlMessage;
                switch (msg.ControlMessageType)
                {
                    case 1 => displayStr += "Start Control Connection Request";
                    case 2 => displayStr += "Start Control Connection Reply";
                    case 3 => displayStr += "Stop Control Connection Request";
                    case 4 => displayStr += "Stop Control Connections Reply";
                    case 5 => displayStr += "Echo Request";
                    case 6 => displayStr += "Echo Reply";
                    case 7 => displayStr += "Outgoing Call Request";
                    case 8 => displayStr += "Outgoing Call Reply";
                    case 9 => displayStr += "Incoming Call Request";
                    case 10 => displayStr += "Incoming Call Reply";
                    case 11 => displayStr += "Incoming Call Connected";
                    case 12 => displayStr += "Call Clear Request";
                    case 13 => displayStr += "Call Disconnect Notify";
                    case 14 => displayStr += "WAN Error Notify";
                    case 15 => displayStr += "Set Link Info";
                    default => 
                        displayStr += "Unknown Control Message Type (" + (msg.ControlMessageType as string) + ")";
                }
            case 2 => displayStr += "Management Message";
            default => 
                displayStr += "Unknown Message Type (" + (PPTPHead.MessageType as string) + ")";
        }
        return displayStr;
    }
};

// Only define to handle partial message parsing.
message PartialPPTP
{
    PPTPHead PPTPHead;
    binary IncompleteData;
    
    override string ToString()
    {
        string displayStr = "PPTP Partial Message: ";
        switch (PPTPHead.MessageType)
        {
            case 1 => displayStr += "Control Message";
            case 2 => displayStr += "Management Message";
            default => 
                displayStr += "Unknown Message Type (" + (PPTPHead.MessageType as string) + ")";
        }
        return displayStr;
    }
};

type PPTPHead
{
    ushort Length;
    ushort MessageType;
    uint MagicCookie;
}

type ManagementMessage[ushort len]
{
    string Message with BinaryEncoding{Length = len, TextEncoding = TextEncoding.ASCII};
}

type ControlMessage
{
    ushort ControlMessageType;
    ushort Reserved0 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved0 in type ControlMessage must be zero.");
    ([|ControlMessageType == 1|] StartControlConnectionRequest
        | [|ControlMessageType == 2|] StartControlConnectionReply
        | [|ControlMessageType == 3|] StopControlConnectionRequest
        | [|ControlMessageType == 4|] StopControlConnectionsReply
        | [|ControlMessageType == 5|] EchoRequest
        | [|ControlMessageType == 6|] EchoReply
        | [|ControlMessageType == 7|] OutgoingCallRequest
        | [|ControlMessageType == 8|] OutgoingCallReply
        | [|ControlMessageType == 9|] IncomingCallRequest
        | [|ControlMessageType == 10|] IncomingCallReply
        | [|ControlMessageType == 11|] IncomingCallConnected
        | [|ControlMessageType == 12|] CallClearRequest
        | [|ControlMessageType == 13|] CallDisconnectNotify
        | [|ControlMessageType == 14|] WANErrorNotify
        | [|ControlMessageType == 15|] SetLinkInfo
        | UnknownMessage) MessageBody;
}

type UnknownMessage
{
    binary Data;
}

type StartControlConnectionRequest
{
    ushort ProtocolVersion;
    ushort Reserved1 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved1 in type StartControlConnectionRequest must be zero.");
    FramingCapabilities FramingCapabilities;
    BearerCapabilities BearerCapabilities;
    ushort MaximumChannels;
    ushort FirmwareRevision;
    string HostName with BinaryEncoding{Length = 64, TextEncoding = TextEncoding.ASCII};
    string VendorString with BinaryEncoding{Length = 64, TextEncoding = TextEncoding.ASCII};
}

type StartControlConnectionReply
{
    ushort ProtocolVersion;
    byte ResultCode;
    byte ErrorCode;
    FramingCapabilities FramingCapabilities;
    BearerCapabilities BearerCapabilities;
    ushort MaximumChannels;
    ushort FirmwareRevision;
    string HostName with BinaryEncoding{Length = 64, TextEncoding = TextEncoding.ASCII};
    string VendorString with BinaryEncoding{Length = 64, TextEncoding = TextEncoding.ASCII};
}

type StopControlConnectionRequest
{
    byte Reason;
    byte Reserved1 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved1 in type StopControlConnectionRequest must be zero.");
    ushort Reserved2 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved2 in type StopControlConnectionRequest must be zero.");
}

type StopControlConnectionsReply
{
    byte ResultCode;
    byte ErrorCode;
    ushort Reserved1 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved1 in type StopControlConnectionsReply must be zero.");
}

type EchoRequest
{
    uint Identifier;
}

type EchoReply
{
    uint Identifier;
    byte ResultCode;
    byte ErrorCode;
    ushort  Reserved1 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved1 in type EchoReply must be zero.");
}

type OutgoingCallRequest
{
    ushort CallID;
    ushort CallSerialNumber;
    uint MinimumBPS;
    uint MaximumBPS;
    uint BearerType;
    uint FramingType;
    ushort PacketRecvWindowSize;
    ushort PacketProcessingDelay;
    ushort PhoneNumberLength;
    ushort Reserved1 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved1 in type OutgoingCallRequest must be zero.");
    string PhoneNumber with BinaryEncoding{Length = 64, TextEncoding = TextEncoding.ASCII};
    string Subaddress with BinaryEncoding{Length = 64, TextEncoding = TextEncoding.ASCII};
}

type OutgoingCallReply
{
    ushort CallID;
    ushort PeersCallID;
    byte ResultCode;
    byte ErrorCode;
    ushort CauseCode;
    uint ConnectSpeed;
    ushort PacketRecvWindowSize;
    ushort PacketProcessingDelay;
    uint PhysicalChannelID;
}

type IncomingCallRequest
{
    ushort CallID;
    ushort CallSerialNumber;
    uint CallBearerType;
    uint PhysicalChannelID;
    ushort DialedNumberLength;
    ushort DialingNumberLength;
    string DialedNumber with BinaryEncoding{Length = 64, TextEncoding = TextEncoding.ASCII};
    string DialingNumber with BinaryEncoding{Length = 64, TextEncoding = TextEncoding.ASCII};
    string Subaddress with BinaryEncoding{Length = 64, TextEncoding = TextEncoding.ASCII};
}

type IncomingCallReply
{
    ushort CallID;
    ushort PeersCallID;
    byte ResultCode;
    byte ErrorCode;
    ushort PacketRecvWindowSize;
    ushort PacketTransmitDelay;
    ushort Reserved1 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved1 in type IncomingCallReply must be zero.");
}

type IncomingCallConnected
{
    ushort PeersCallID;
    ushort Reserved1;
    uint ConnectSpeed;
    ushort PacketRecvWindowSize;
    ushort PacketTransmitDelay;
    uint FramingType;
}

type CallClearRequest
{
    ushort CallID;
    ushort Reserved1 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved1 in type CallClearRequest must be zero.");
}

type CallDisconnectNotify
{
    ushort CallID;
    byte ResultCode;
    byte ErrorCode;
    ushort  CauseCode;
    ushort Reserved1;
    string CallStatistics with BinaryEncoding{Length = 128, TextEncoding = TextEncoding.ASCII};
}

type WANErrorNotify
{
    ushort PeersCallID;
    ushort Reserved1;
    uint CRCErrors;
    uint FramingErrors;
    uint HardwareOverruns;
    uint BufferOverruns;
    uint TimeOutErrors;
    uint AlignmentErrors;
}

type SetLinkInfo
{
    ushort PeersCallID;
    ushort Reserved1 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "PPTP: Reserved1 in type SetLinkInfo must be zero.");
    uint SendACCM;
    uint ReceiveACCM;
}

type FramingCapabilities
{
    uint Reserved with BinaryEncoding{Width = 30};
    byte SynchronousFramingSupported with BinaryEncoding{Width = 1};
    byte AsynchronousFramingSupported with BinaryEncoding{Width = 1};
}

type BearerCapabilities
{
    uint Reserved with BinaryEncoding{Width = 30};
    byte DigitalAccessSupported with BinaryEncoding{Width = 1};
    byte AnalogAccessSupported with BinaryEncoding{Width = 1}; 
}

type DecodingCache : DecodingCacheBase
{
    void(Datagram) Dispatcher;
    
    uint BufferCount()
    {
        if (Buffer == null)
            return 0;
        return Buffer.Count as uint;
    }
    
    void TryDecodeMsgAndDispatch()
    {
        while(BufferCount() >= 8)
        {
            stream s = Buffer;
            ushort msgLength = ((Buffer[0] as ushort) << 8) + Buffer[1] as ushort;
            if (msgLength > s.ByteLength)
            {
                return;
            }
            // Guarantee never decode failed.
            Datagram datagram = BinaryDecoder<Datagram>(s) as Datagram;
            if (datagram != nothing)
            {
                Dispatcher(datagram);
            }
            else
            {
                ThrowDecodingException("PPTP");
            }
            Reset(s);
        }
    }
    
    override optional any message DecodePartialMessage()
    {
        if (BufferCount() < 8)
        {
            return nothing;
        }
        // Guarantee partial message always decode successfuly.
        PartialPPTP partial = BinaryDecoder<PartialPPTP>(Buffer) as PartialPPTP;
        ReportInsufficientData(partial, DiagnosisLevel.Warning, 
                "PPTP: Incomplete PPTP payload for full reassembly, missing continuous message. Expected length: " + 
                partial.PPTPHead.Length.ToString() + ", Actual length: " + (partial.IncompleteData.Count + 8).ToString() + ".");
        return partial;
    }
}
