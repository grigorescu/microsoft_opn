protocol EAP
    with BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "Extensible Authentication Protocol",
    ShortName = "EAP",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 3748"},
            new Reference{Name = "RFC 5216"},
            new Reference{Name = "EAP", Link = "http://www.iana.org/assignments/eap-numbers/eap-numbers.xml"},
        ],
    RevisionSummary = 
        [
            new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "11/15/2011"}
        ]
};

using Standard;
using Utility;
using IANA;
using RADIUS;
using IKE;
using PPP;

endpoint Server over RADIUS.Node
            | over IKE.Node 
            | over PPP.Node accepts Packet issues Packet;

client endpoint Client connected to Server;

autostart actor EAPOverRADIUS(RADIUS.Node node)
{
    process node accepts p:RADIUS.Packet where (p.PayloadForEap != nothing && (p.PayloadForEap as binary).Count >= 2)
    {
        var server = endpoint EAP.Server over node;
        PacketDecoder(p.PayloadForEap as binary, server);
    }
}

autostart actor EAPOverIKE(IKE.Node node)
{
    process node accepts p:IKE.IKEDatagram where (HasEapInIKE(p))
    {
        EAPOverIKEProcessing(p, node);
    }
}

// PacketDecoder for EAPOverPPP and EAPOverRADIUS
void PacketDecoder(binary payload, EAP.Server server)
{
    switch (payload)
    {
        case m:EAP.Packet from BinaryDecoder<EAP.Packet> =>
            if (m.Code == EapCode.Response)
            {
                dispatch server issues m;
            }
            else
            {
                dispatch server accepts m;
            }
        default =>
            ThrowDecodingException("EAP Packet");
    }
}

void EAPOverIKEProcessing(IKE.IKEDatagram d, IKE.Node node)
{
    ushort offset = 0;
    ushort curPayloadLength = (d.Data[offset + 2] * 256 + d.Data[offset + 3]) as ushort;
    ushort totalCount = d.Data.Count as ushort;
    while (offset < totalCount - 4)
    {
        if (d.NextPayload == 48) // The first segment is eap.
        {
            var server = endpoint EAP.Server over node;
            PacketDecoder(d.Data.Segment(offset, curPayloadLength), server);
            offset = (offset + curPayloadLength) as ushort;
        }
        
        else if (d.Data[offset] == 48) // The second segment or later segment is eap.
        {
            offset = (offset + curPayloadLength) as ushort;
            curPayloadLength = (d.Data[offset + 2] * 256 + d.Data[offset + 3]) as ushort;
            var server = endpoint EAP.Server over node;
            PacketDecoder(d.Data.Segment(offset, curPayloadLength), server);
        }
        
        else // Otherwise, just move forward
        {
            offset = (offset + curPayloadLength) as ushort;
            curPayloadLength = (d.Data[offset + 2] * 256 + d.Data[offset + 3]) as ushort;
        }
    }
}

// The method is used for checking if IKE has payload of eap.
bool HasEapInIKE(IKE.IKEDatagram d)
{
    if (d.Data == $[])
    {
        return false;
    }
    else
    {
        if (d.Flags is Flagsv1) // Excluded Encryted segment.
        {
            if ((d.Flags as Flagsv1).Encryption == 1)
            {
                return false;
            }
        }
        if (d.NextPayload == 48)
        {
            return true;
        }
        ushort offset = 0; // offset begins from 0, and max value is totalCount - 1
        ushort totalCount = d.Data.Count as ushort;
        while (offset <= totalCount - 4)
        {
            if (d.Data[offset] == 48)
            {
                return true;
            }
            else
            {
                ushort curPayloadLength = (d.Data[offset + 2] * 256 + d.Data[offset + 3]) as ushort;// Get current payload's length 
                offset = (offset + curPayloadLength) as ushort;// Make offset move forward
            }
        }
        return false;
    }
}

// rfc3748, section 3.2.1
autostart actor EAPOverPPP(PPP.Node node)
{
    process node accepts p:PPP.Frame where GetPacketTypeValue(p.PacketType) == 0xC227
    {
        var server = endpoint EAP.Server over node;
        PacketDecoder(p.Payload, server);
    }
}

message Packet
{
    EapCode Code;
    byte Identifier;
    ushort Length;
    
    optional (Identity[Length]
     | Notification[Length]
     | Nak[Length]
     | MD5Challenge[Length]
     | OTP[Length]
     | GTC[Length]
     | TLS[Length]
     | ExpandedNak[Length]
     | Experimental[Length]
     | PEAP[Length]
     | Blob[(Length - 4) as uint]) Data;
    
    override string ToString()
    {
        string summary = "";
        summary += EnumToString(Code,"EAP.EapCode");
        if (!(Data is nothing))
        {
            switch (Data)
            {
                case Identity =>
                    summary += ", Identity";
                case Notification =>
                    summary += ", Notification";
                case Nak =>
                    summary += ", Nak";
                case MD5Challenge =>
                    summary += ", MD5Challenge";
                case OTP =>
                    summary += ", OTP";
                case GTC =>
                    summary += ", GTC";
                case TLS =>
                    summary += ", TLS";
                case PEAP =>
                    summary += ", PEAP";
                case ExpandedNak =>
                    summary += ", ExpandedNak";
                case Experimental =>
                    summary += ", Experimental";
                default =>
                    summary += "";
            }
        }
        return summary;
    }
}

//# rfc 3748 section 4
pattern EapCode = enum byte
{
    Request = 1,
    Response = 2,
    Success = 3,
    Failure = 4
};

// From Link: "http://www.iana.org/assignments/eap-numbers"
pattern MethodType = enum byte
{
    Identity = 1,
    Notification = 2,
    Nak = 3, // Response only
    MD5Challenge = 4,
    OTP = 5, // One Time Password (OTP)
    GenericTokenCard = 6,
    TLS = 13,
    PEAP = 25,
    ExpandedNak = 254,
    Experimental = 255
};

// 1 - Identity : rfc3748#section-5.1
type Identity[ushort Len]
{
    (MethodType where value == MethodType.Identity) Type;
    // Future Reference: Bellow type should be MBCString.
    binary TypeData with BinaryEncoding{Length = (Len - 5) as uint};
}

// 2 - Notification : rfc3748#section-5.2
type Notification[ushort Len]
{
    (MethodType where value == MethodType.Notification) Type;
    binary TypeData with BinaryEncoding{Length = (Len - 5) as uint};
}

// 3 - Nak : rfc3748#section-5.3
// The legacy Nak Type is valid only in Response messages
type Nak[ushort Len]
{
    (MethodType where value == MethodType.Nak) Type;
    binary DesiredAuthType with BinaryEncoding{Length = (Len - 5) as uint};
}

// 4 - MD5-Challenge : rfc3748#section-5.4
type MD5Challenge[ushort Len]
{
    (MethodType where value == MethodType.MD5Challenge) Type;
    byte ValueSize;
    binary Value with BinaryEncoding{Length = ValueSize};
    string Name with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = (Len - 6 - ValueSize) as uint};
}

// 5 - One-Time Password (OTP) : rfc3748#section-5.5
type OTP[ushort Len]
{
    (MethodType where value == MethodType.OTP) Type;
    binary OTPData with BinaryEncoding{Length = (Len - 5) as uint};
}

// 6 - Generic Token Card (GTC) : rfc3748#section-5.6
type GTC[ushort Len]
{
    (MethodType where value == MethodType.GenericTokenCard) Type;
    binary GTCData with BinaryEncoding{Length = (Len - 5) as uint};
}

// 13 - PPP EAP TLS Packet Format: rfc5216
type TLS[ushort Len]
{
    (MethodType where value == MethodType.TLS) Type;
    //Flag
    bool LengthIncluded with BinaryEncoding{Width = 1};
    bool MoreFragments with BinaryEncoding{Width = 1};
    bool TLSStart with BinaryEncoding{Width = 1};
    bool Reserved where ValidationCheck(value == false, null, "Reserved must be zero.") with BinaryEncoding{Width = 5};
    
    optional [|LengthIncluded|] uint TLSMessageLength;
    optional [|!(TLSMessageLength is nothing)|] binary TLSData with BinaryEncoding{Length = TLSMessageLength as uint};
}

// 254 Expanded Nak : rfc3748#section-5.3.2
type ExpandedNak[ushort Len]
{
    (MethodType where value == MethodType.ExpandedNak) Type;
    uint VendorId with BinaryEncoding{Width = 24};
    uint VendorType;
    optional [|VendorId == 0 && VendorType == 3|] uint EAPVendorId with BinaryEncoding{Width = 24};
    optional [|VendorId == 0 && VendorType == 3|] uint EAPVendorType;
    optional [|VendorId != 0 || VendorType != 3|] binary VendorData with BinaryEncoding{Length = (Len - 12) as uint};
}

// 255 Experimental : rfc3748#section-5.8
type Experimental[ushort Len]
{
    (MethodType where value == MethodType.Experimental) Type;
    binary UndefinedData with BinaryEncoding{Length = (Len - 5) as uint};
}

type PEAP[ushort Len]
{
    (MethodType where value == MethodType.PEAP) Type;
    binary PEAPData with BinaryEncoding{Length = (Len - 5) as uint};
}
