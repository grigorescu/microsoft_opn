protocol SOCKS with 
BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "SOCKS Protocol",
    ShortName = "SOCKS",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 1928"},
            new Reference{Name = "RFC 1929"},
            new Reference{Name = "RFC 1961"},
            new Reference{Name = "RFC 3089"},
            new Reference{Name = "SOCKSv4", Link = "http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol"},
        ],
    RevisionSummary =
        [
            new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "1/20/2012"}
        ]
};

using Standard;
using Utility;
using IANA;
using HTTP;
using IPv4;
using IPv6;
using TCP;
using UDP;
using FTP;
using TELNET;
using VirtualTransport;

endpoint Server
      over VirtualTransport.Server
    | over UDP.Host
    provides SOCKSv4Msg
    provides SOCKSv5Msg;

client endpoint Client connected to Server;

// Sequence:
// 1. Select the method: GSSAPI or USERNAME/PASSWORD
// 2. Client sends the command to server;

autostart actor SocksOverTCP(VirtualTransport.Server server)
{
    byte method = 0xFF; // method value is from SOCKSv5Msg.AuthNegotiateReply
    bool subnegotiationCompleted = false;
    ushort port;
    bool connectGranted = false;
    
    // Fix bug 41387 for excluding the HTTP data.
    process server accepts s:VirtualTransport.VirtualDataSegment 
        where ((s.DestinationPort == IANA.Port.SOCKS || (s.SourcePort == IANA.Port.SOCKS && s.DestinationPort != IANA.Port.HTTP)) && s.Payload.Count > 0) // Request
    {
        if (s.Payload[0] == 4) // Socksv4
        {
            switch (s.Payload)
            {
                case request:SOCKSv4Msg.Request from BinaryDecoder<SOCKSv4Msg.Request> =>
                    dispatch (endpoint Server over server) accepts request;
                    port = request.Dstport;
                default =>
                    ThrowDecodingExceptionForTCP("SOCKSv4", "Request", s#IsIncomplete, s#SegmentLost);
            }
        }
        else if (s.Payload[0] == 5) // Socksv5
        {
             // -- The client and server then enter a method-specific sub-negotiation. 0 is default value.
            if (method == 0)
            {
                switch (s.Payload)
                {
                    case authRequest:SOCKSv5Msg.AuthNegotiateRequest from BinaryDecoder<SOCKSv5Msg.AuthNegotiateRequest> =>
                        dispatch (endpoint Server over server) accepts authRequest;
                    default =>
                        ThrowDecodingExceptionForTCP("SOCKSv5", "AuthNegotiateRequest", s#IsIncomplete, s#SegmentLost);
                }
            }
            else if (method == 1) // GSSAPI
            {
                switch (s.Payload)
                {
                    case gssRequest:SOCKSv5Msg.GSSAPIRequest from BinaryDecoder<SOCKSv5Msg.GSSAPIRequest> =>
                        dispatch (endpoint Server over server) accepts gssRequest;
                    default =>
                        ThrowDecodingExceptionForTCP("SOCKSv5", "GSSAPIRequest", s#IsIncomplete, s#SegmentLost);
                }
            }
            else if (method == 2) // USERNAME/PASSWORD
            {
                switch (s.Payload)
                {
                    
                    case uNameRequest:SOCKSv5Msg.UsernamePasswordRequest from BinaryDecoder<SOCKSv5Msg.UsernamePasswordRequest> =>
                        dispatch (endpoint Server over server) accepts uNameRequest;
                    default =>
                        ThrowDecodingExceptionForTCP("SOCKSv5", "UsernamePasswordRequest", s#IsIncomplete, s#SegmentLost);
                }
            }
             // Once the method-dependent subnegotiation has completed, the client sends the request details
            else if (subnegotiationCompleted)
            {
                switch (s.Payload)
                {
                    case cmdRequest:SOCKSv5Msg.CmdRequest from BinaryDecoder<SOCKSv5Msg.CmdRequest> =>
                        dispatch (endpoint Server over server) accepts cmdRequest;
                        port = cmdRequest.DstPort;
                    default =>
                        ThrowDecodingExceptionForTCP("SOCKSv5", "CmdRequest", s#IsIncomplete, s#SegmentLost);
                }
            }
        }
        else if (connectGranted && IANA.Port.HTTP == port)
        {
            dispatch (endpoint HTTP.ReassemblyServer[server]) accepts s;
        }
        else if (connectGranted && IANA.Port.FTPControl == port)
        {
            switch (s.Payload)
            {
                case c:FTP.CommandToServer from BinaryDecoder<FTP.CommandToServer> =>
                    dispatch (endpoint FTP.Server over server) accepts c;
                default => 
                    ThrowDecodingExceptionForTCP("FTP", "CommandToServer", s#IsIncomplete, s#SegmentLost);
            }
        }
        else if (connectGranted && IANA.Port.TELNET == port)
        {
            switch (s.Payload)
            {
                case m:TELNET.Message from TelnetDecoder =>
                    dispatch (endpoint TELNET.Server over server) accepts m;
                default =>
                    ThrowDecodingExceptionForTCP("TELNET", "Message", s#IsIncomplete, s#SegmentLost);
            }
        }
        // Future Reference: Add protocol "WAIS"/"GOPHER". Which is defined in section 2 of http://tools.ietf.org/html/rfc1928.
        else
        {
            throw "No such version in SOCKS.";
        }
    }
    
    process server issues s:VirtualTransport.VirtualDataSegment 
        where (((s.DestinationPort == IANA.Port.SOCKS && s.SourcePort != IANA.Port.HTTP) || s.SourcePort == IANA.Port.SOCKS) && s.Payload.Count > 0) // Response
    {
        // Socksv4.CommandCode is in [90,91,92,93]
        if (s.Payload[1] in {90,91,92,93}) // Socksv4
        {
            switch (s.Payload)
            {
                case response:SOCKSv4Msg.Reply from BinaryDecoder<SOCKSv4Msg.Reply> =>
                    dispatch (endpoint Server over server) issues response;
                    connectGranted = (response.Cd == CommandCode.RequestGranted) ? true : false;
                default =>
                    ThrowDecodingExceptionForTCP("SOCKSv4", "Reply", s#IsIncomplete, s#SegmentLost);
            }
        }
        else if (method == 0)
        {
            switch (s.Payload)
            {
                case authReply:SOCKSv5Msg.AuthNegotiateReply from BinaryDecoder<SOCKSv5Msg.AuthNegotiateReply> =>
                    dispatch (endpoint Server over server) issues authReply;
                    method = authReply.Method;
                default =>
                    ThrowDecodingExceptionForTCP("SOCKSv5", "AuthNegotiateReply", s#IsIncomplete, s#SegmentLost);
            }
        }
        else if (method == 1) // GSSAPI req and resp use the same MessageType;
        {
            switch (s.Payload)
            {
                case gssReply:SOCKSv5Msg.GSSAPIReply from BinaryDecoder<SOCKSv5Msg.GSSAPIReply> =>
                    dispatch (endpoint Server over server) issues gssReply;
                    subnegotiationCompleted = true;
                default =>
                    ThrowDecodingExceptionForTCP("SOCKSv5", "GSSAPIReply", s#IsIncomplete, s#SegmentLost);
                    
            }
        }
        else if (method == 2)
        {
            switch (s.Payload)
            {
                case uNameReply:SOCKSv5Msg.UsernamePasswordReply from BinaryDecoder<SOCKSv5Msg.UsernamePasswordReply> =>
                    dispatch (endpoint Server over server) issues uNameReply;
                    subnegotiationCompleted = true;
                default =>
                    ThrowDecodingExceptionForTCP("SOCKSv5", "UsernamePasswordReply", s#IsIncomplete, s#SegmentLost);
            }
        }
        else if (subnegotiationCompleted)
        {
            switch (s.Payload)
            {
                case cmdReply:SOCKSv5Msg.CmdReply from BinaryDecoder<SOCKSv5Msg.CmdReply> =>
                    dispatch (endpoint Server over server) issues cmdReply;
                default =>
                    ThrowDecodingExceptionForTCP("SOCKSv5", "CmdReply", s#IsIncomplete, s#SegmentLost);
            }
        }
        else if (connectGranted && IANA.Port.HTTP == port)
        {
            dispatch (endpoint HTTP.ReassemblyServer[server]) issues s;
        }
        else if (connectGranted && IANA.Port.FTPControl == port)
        {
            switch (s.Payload)
            {
                case c:FTP.CommandToClient from BinaryDecoder<FTP.CommandToClient> =>
                    if (c.Response is FTP.ResponseType)
                    {
                        var v = c.Response as FTP.ResponseType;
                        FTP.CommandToClientDecoder(ref v);
                    }
                    else if (c.Response is FTP.ResponseMultipleLineType)
                    {
                        var v = c.Response as FTP.ResponseMultipleLineType;
                        FTP.CommandToClientDecoder(ref v);
                    }
                    dispatch (endpoint FTP.Server) issues c;
                default =>
                    ThrowDecodingExceptionForTCP("FTP", "CommandToClient", s#IsIncomplete, s#SegmentLost);
            }
        }
        else if (connectGranted && IANA.Port.TELNET == port)
        {
            switch (s.Payload)
            {
                case m:TELNET.Message from TelnetDecoder =>
                    dispatch (endpoint TELNET.Server over server) issues m;
                default =>
                    ThrowDecodingExceptionForTCP("TELNET", "Message", s#IsIncomplete, s#SegmentLost);
            }
        }
        // Future Reference: Add protocol "WAIS"/"GOPHER". Which is defined in section 2 of http://tools.ietf.org/html/rfc1928.
        else
        {
            throw "No such version in SOCKS.";
        }
    }
}

autostart actor SOCKSOverUDP(UDP.Host host)
{
    process host accepts d:UDP.Datagram where ((d.DestinationPort == IANA.Port.SOCKS || d.SourcePort == IANA.Port.SOCKS) && d.Payload.Count > 0)
    {
        switch (d.Payload)
        {
            case uDPBasedRequest:SOCKSv5Msg.UDPBasedConnectionRequest from BinaryDecoder<SOCKSv5Msg.UDPBasedConnectionRequest> =>
                dispatch (endpoint Server over host) accepts uDPBasedRequest;
            case uDPBasedReply:SOCKSv5Msg.UDPBasedConnectionReply from BinaryDecoder<SOCKSv5Msg.UDPBasedConnectionReply> =>
                dispatch (endpoint Server over host) issues uDPBasedReply;
            default =>
                ThrowDecodingException("SOCKSv5");
        }
    }
}

/*--------------------------------------------------------Messages-----------------------------------------------------------------------*/

// SOCKSv4
contract SOCKSv4Msg
{
    accepts message Request
    {
        byte Vn where value == 4;
        Command Cd;
        ushort Dstport;
        IPv4Address DstIp;
        string UserId with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
        
        override string ToString()
        {
            switch (Cd)
            {
                case 1 => return "BIND" + "to" + (DstIp as string) + "/" + (Dstport as string) + "for" + (UserId );
                case 2 => return "CONNECT" + "to" + (DstIp as string) + "/" + (Dstport as string) + "for" + (UserId);
                default => return "Unknown Command Code: "+ (Cd as string);
            }
        }
    }
    
    issues message Reply
    {
        byte Vn where value == 0;
        CommandCode Cd;
        ushort Dstport;
        IPv4Address DstIp;
        
        override string ToString()
        {
            switch (Cd)
            {
                case 90 => return "RequestGranted" + "to" + (DstIp as string) + "/" + (Dstport as string);
                case 91 => return "RequestRejectedorFailed" + "to" + (DstIp as string) + "/" + (Dstport as string);
                case 92 => return "RequestRejectedServer" + "to" + (DstIp as string) + "/" + (Dstport as string);
                case 93 => return "RequestRejectedClient"+ "to" + (DstIp as string) + "/" + (Dstport as string);
                default => return "Unknown ReplyCommand Code: "+ (Cd as string);
            }
        }
    }
} 

pattern CommandCode = enum byte
{
    RequestGranted           = 90,
    RequestRejectedorFailed  = 91,
    RequestRejectedServer    = 92,
    RequestRejectedClient    = 93
};

pattern Command = enum byte
{
    BIND     = 1,
    CONNECT  = 2,
};

// SOCKSv5
contract SOCKSv5Msg
{
    // RFC 1928
    // the method-dependent subnegotiation
    // The client connects to the server, and sends a Ver
    // identifier/method selection message
    accepts message AuthNegotiateRequest
    {
        byte Ver where value == 5;
        byte NMethods;
        binary Methods with BinaryEncoding{Length = NMethods as uint};
        
        override string ToString()
        {
            return "NMethods = " + (NMethods as string);
        }
    }
    
    issues message AuthNegotiateReply
    {
        byte Ver where value == 5;
        byte Method;
        
        override string ToString()
        {
            string summary = "Cmd = " + (Method == 0x0 ? "NO AUTHENTICATION REQUIRED" : 
                (Method == 0x1 ? "GSSAPI" : 
                (Method == 0x2 ? "USERNAME/PASSWORD" : 
                (Method == 0x3 ? "Challenge-Handshake Authentication Protocol" : 
                (Method == 0x4 ? "Unassigned" : 
                (Method == 0x5 ? "Challenge-Response Authentication Method" : 
                (Method == 0x6 ? "Secure Sockets Layer" : 
                (Method == 0x7 ? "NDS Authentication" : 
                (Method == 0x8 ? "Multi-Authentication Framework" : 
                (Method >= 0x9 && Method <= 0x7F? "Unassigned" : 
                (Method >= 0x80 && Method >= 0xFE ? "RsvD FOR PRIVATE METHODS" : "NO ACCEPTABLE METHODS")))))))))));
            return summary;
        }
    }

    accepts message CmdRequest
    {
        byte Ver where value == 5;
        Cmds Cmd;
        byte Rsv where ValidationCheck(value == 0, this, "Rsvd must be zero.");
        Atyps Atyp;
        ( [|Atyp == Atyps.IPv4Address|] IPv4Address 
        | [|Atyp == Atyps.IPv6Address|] IPv6Address 
        | [|Atyp == Atyps.DomainName|] DomainName) DstAddr;
        ushort DstPort;
        
        override string ToString()
        {
            return "Cmd = " + (Cmd == 1 ? "Connect" : (Cmd == 2 ? "Bind" : (Cmd == 3 ? "UDP" : "Unknow Data")));
        }

    }
    
    issues message CmdReply
    {
        byte Ver where value == 5;
        byte Rep;
        byte Rsv where ValidationCheck(value == 0, null, "Rsvd must be zero.");
        Atyps Atyp;
        ( [|Atyp == 1|] IPv4Address 
        | [|Atyp == 4|] IPv6Address 
        | [|Atyp == 3|] DomainName) BndAddr;
        ushort BndPort;
        
        override string ToString()
        {
            string summary = "Reply = " + (Rep == 0 ? "Succeeded" : 
                (Rep == 1 ? "General SOCKS server failure" : 
                (Rep == 2 ? "Connection not allowed by ruleset" : 
                (Rep == 3 ? "Network unreachable" : 
                (Rep == 4 ? "Host unreachable" : 
                (Rep == 5 ? "Connection refused" : 
                (Rep == 6 ? "TTL expired" : 
                (Rep == 7 ? "Cmd not supported" : 
                (Rep == 8 ? "Address type not supported" : "Unassigned")))))))));
            return summary;
        }
    }
    
    
    accepts message UDPBasedConnectionRequest
    {
        ushort Rsv where ValidationCheck(value == 0, null, "Rsvd must be zero.");
        byte Frag;
        Atyps Atyp;
        ( [|Atyp == 1|] IPv4Address 
        | [|Atyp == 4|] IPv6Address 
        | [|Atyp == 3|] DomainName) DstAddr;
        ushort DstPort;
        binary Data;
        
        override string ToString()
        {
            return "Current fragment number is " + (Frag as string);
        }
    }
    
    issues message UDPBasedConnectionReply
    {
        ushort Rsv where ValidationCheck(value == 0, null, "Rsvd must be zero.");
        byte Frag;
        Atyps Atyp;
        ( [|Atyp == 1|] IPv4Address 
        | [|Atyp == 4|] IPv6Address 
        | [|Atyp == 3|] DomainName) DstAddr;
        ushort DstPort;
        binary Data with BinaryEncoding{Length = 0};
        
        override string ToString()
        {
            return "Current fragment number is " + (Frag as string);
        }
    }
    
    // RFC 1929
    accepts message UsernamePasswordRequest
    {
        byte Ver;
        byte Ulen;
        string Uname with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = Ulen as uint};
        byte Plen;
        binary Passwd with BinaryEncoding{Length = Plen as uint};
        
        override string ToString()
        {
            return "UserName = " + (Uname as string) + "Password = " + (Passwd as string);
        }
    }
    
    issues message UsernamePasswordReply
    {
        byte Ver;
        byte Status;
        
        override string ToString()
        {
            return "Status is " + (Status == 0 ? "Success" : "Failure");
        }
    }
    
    //rfc 1961
    accepts message GSSAPIRequest
    {
        byte Ver;
        Mtyps Mtyp;
        byte Len;
        binary Token with BinaryEncoding{Length = Len as uint};
        
        override string ToString()
        {
            return "Status is " + (Mtyp as string);
        };
    }
    
    issues message GSSAPIReply
    {
        byte Ver;
        Mtyps Mtyp;
        optional [|Mtyp != 0xFF|] byte Len;
        optional [|Mtyp != 0xFF|] binary Token with BinaryEncoding{Length = Len as uint};
        
        override string ToString()
        {
            return "Status is " + (Mtyp as string);
        };
    }
}

type DomainName
{
    byte NameLength;
    string DomainName with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = NameLength as uint};
}

pattern Cmds = enum byte
{
    Connect = 1,
    Bind = 2,
    UDPAssociate = 3,
};


pattern Atyps = enum byte
{
    IPv4Address = 1,
    DomainName = 3,
    IPv6Address = 4,
};

pattern Mtyps = enum byte
{
    Authentication = 1,
    ProtectionLevelNegotiation = 2,
    EncapulatedUserData = 3,
    Abort = 0xFF,
};

