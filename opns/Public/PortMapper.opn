protocol PortMapper with 
BinaryEncodingDefaults{Endian = Endian.Big, TextEncoding = TextEncoding.ASCII},
Documentation
{
    ProtocolName = "Port Mapper Program Protocol",
    ShortName = "PortMapper",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 1833"},
            new Reference{Name = "RFC 5665"},
        ],
    RevisionSummary = 
        [
            new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "10/18/2011"}
        ]
};

using Utility;
using SunRPC;
using TCP;
using UDP;
using IANA;
using XDR;
using VirtualTransport;

endpoint Server over IntermediateServer provides OperationContract consumes OperationContract;
client endpoint Client connected to Server;

endpoint IntermediateServer over SunRPC.Node provides MessageContract consumes MessageContract;
client endpoint IntermediateClient connected to IntermediateServer;

// Global array of Mappings replied by GetPort for following frames to be parsed to SunRPC.
array<Mapping> GetPortMappings = [];

bool PortRepliedByGetPort(uint port)
{
    foreach (Mapping mapping in GetPortMappings)
    {
        if (port == mapping.Port)
        {
            return true;
        }
    }
    return false;
}

// SunRPC Over TCP actor
autostart actor SunRPCOverTCP(VirtualTransport.Server server)
{
    process server accepts s:VirtualTransport.VirtualDataSegment where (s.DestinationPort == Port.SunRPC || PortRepliedByGetPort(s.DestinationPort))
    { 
        dispatch (endpoint SunRPC.RecordMarking over server) accepts s;
    }
    
    process server issues s:VirtualTransport.VirtualDataSegment where (s.SourcePort == Port.SunRPC  || PortRepliedByGetPort(s.SourcePort))
    {
        dispatch (endpoint SunRPC.RecordMarking over server) issues s;
    }
    
    // Below rules are added in case that TCP mistakes the Client for Server by port number for the trace without TCP 3-way handshake.
    process server issues s:VirtualTransport.VirtualDataSegment where server.isMissingThreeWayHandshake && (s.DestinationPort == Port.SunRPC || PortRepliedByGetPort(s.DestinationPort))
    { 
        dispatch (endpoint SunRPC.RecordMarking over server) accepts s;
    }
    
    process server accepts s:VirtualTransport.VirtualDataSegment where server.isMissingThreeWayHandshake && (s.SourcePort == Port.SunRPC  || PortRepliedByGetPort(s.SourcePort))
    {
        dispatch (endpoint SunRPC.RecordMarking over server) issues s;
    }
}

// SunRPC Over UDP actor
autostart actor SunRPCOverUDP(UDP.Host host)
{
    process host accepts d:UDP.Datagram where (d.Payload.Count > 0 && (d.DestinationPort == Port.SunRPC || d.SourcePort == Port.SunRPC || PortRepliedByGetPort(d.DestinationPort) || PortRepliedByGetPort(d.SourcePort)))
    {
        dispatch (endpoint SunRPC.RecordMarking over host) accepts d;
    }
}

// Port Mapper Over SunRPC
autostart actor PortMapperOverSunRPC(SunRPC.Node sunRPCNode)
{
    // mapProcedureByXID recodes the Procedure number, and its key is RpcMsg.Xid.
    // Xid  -- ProcedureID
    map<uint, uint> mapProcedureByXID = {};
    // Xid --- Request message
    map<uint, any message> requestsMap = {};
    
    ~endpoint(SunRPC.Node sunRPCNode)
    {
        foreach (var msg in requestsMap.Values)
        {
            DisplayTopLevelMessage(msg);
        }
    }
    
    // Server request/response
    // The second parameter "false/true" is to denote the lower layer bellow SunRPC is UDP or not.
    process sunRPCNode accepts r:RpcMsg where (r.MType == MsgType.Call && (r.Body as CallBody).Prog == 100000 && (r.Body as CallBody).Vers == 2)
    {
        mapProcedureByXID[r.Xid] = (r.Body as CallBody).Proc;
        PortMapperMessageProcessing(mapProcedureByXID[r.Xid], r, ref requestsMap, AcceptsDispatcher);
    }
    // accepts Reply from UDP, reverse accept/issues direction for operation set up.
    process sunRPCNode accepts r:RpcMsg where ((r.MType == MsgType.Reply) && (r.Xid in mapProcedureByXID) && (r.Body as ReplyBody).Stat == ReplyStat.MsgAccepted)
    {
        PortMapperMessageProcessing(mapProcedureByXID[r.Xid], r, ref requestsMap, IssuesDispatcher);
    }
    process sunRPCNode issues r:RpcMsg where ((r.MType == MsgType.Reply) && (r.Xid in mapProcedureByXID) && (r.Body as ReplyBody).Stat == ReplyStat.MsgAccepted)
    {
        PortMapperMessageProcessing(mapProcedureByXID[r.Xid], r, ref requestsMap, IssuesDispatcher);
    }

    void AcceptsDispatcher(any message m)
    {
        dispatch (endpoint IntermediateServer over sunRPCNode) accepts m;
    }
    
    void IssuesDispatcher(any message m)
    {
        dispatch (endpoint IntermediateServer over sunRPCNode) issues m;
    }
}

void PortMapperMessageProcessing(uint procedureNumber, SunRPC.RpcMsg r, ref map<uint, any message> requests, void(any message) dispatcher)
{
    if (r.MType == MsgType.Call) // request
    {
        binary binCallVal = ((r.Body as CallBody).CallData as BinaryCallDataType).Data; 
        switch (procedureNumber)
        {
            case 1 =>
                switch (binCallVal)
                {
                    case m:MessageContract.SetRequest from BinaryDecoder<MessageContract.SetRequest> =>
                       dispatcher(m);
                       requests[r.Xid] = m;

                    default =>
                        ThrowDecodingException("PortMapper", "SetRequest");
                }
            case 2 =>
                switch (binCallVal)
                {
                    case m:MessageContract.UnsetRequest from BinaryDecoder<MessageContract.UnsetRequest> =>
                       dispatcher(m);
                       requests[r.Xid] = m;
                        
                    default =>
                        ThrowDecodingException("PortMapper", "UnsetRequest");
                }
            case 3 =>
                switch (binCallVal)
                {
                    case m:MessageContract.GetPortRequest from BinaryDecoder<MessageContract.GetPortRequest> =>
                       dispatcher(m);
                       requests[r.Xid] = m;
                        
                    default =>
                        ThrowDecodingException("PortMapper", "GetPortRequest");
                }
            case 4 =>
                //reqeusts[r.Xid] = null;
                break;
            case 5 =>
                switch (binCallVal)
                {
                    case m:MessageContract.CallItRequest from BinaryDecoder<MessageContract.CallItRequest> =>
                        dispatcher(m);
                        requests[r.Xid] = m;
                        
                    default =>
                        ThrowDecodingException("PortMapper", "CallItRequest");
                }
            default =>
                ThrowDecodingException("PortMapper");
        }
    }
    
    else // response
    {
        binary binReplyVal = ((r.Body as ReplyBody).Reply as AcceptedReply).ReplyData as binary;
        
        switch (procedureNumber)
        {
            case 1 =>
                switch (binReplyVal)
                {
                    case response:MessageContract.SetResponse from BinaryDecoder<MessageContract.SetResponse> =>
                        requests = requests.Remove(r.Xid);
                        dispatcher(response);
                        
                    default =>
                        ThrowDecodingException("PortMapper", "SetResponse");
                }
            case 2 =>
                switch (binReplyVal)
                {
                    case response:MessageContract.UnsetResponse from BinaryDecoder<MessageContract.UnsetResponse> =>
                        requests = requests.Remove(r.Xid);
                        dispatcher(response);
                        
                    default =>
                        ThrowDecodingException("PortMapper", "UnsetResponse");
                }
            case 3 =>
                switch (binReplyVal)
                {
                    case response:MessageContract.GetPortResponse from BinaryDecoder<MessageContract.GetPortResponse> =>
                        if (r.Xid in requests)
                        {
                            requests = requests.Remove(r.Xid);
                        }
                        dispatcher(response);
                        
                    default =>
                        ThrowDecodingException("PortMapper", "GetPortResponse");
                }
            case 4 =>
                switch (binReplyVal)
                {
                    case response:MessageContract.DumpResponse from BinaryDecoder<MessageContract.DumpResponse> =>
                        if (r.Xid in requests)
                        {
                            requests = requests.Remove(r.Xid);
                        }
                        dispatcher(response);
                        
                    default =>
                        ThrowDecodingException("PortMapper", "DumpResponse");
                }
            case 5 =>
                switch (binReplyVal)
                {
                    case response:MessageContract.CallItResponse from BinaryDecoder<MessageContract.CallItResponse> =>
                        if (r.Xid in requests)
                        {
                            requests = requests.Remove(r.Xid);
                        }
                        dispatcher(response);
                        
                    default =>
                        ThrowDecodingException("PortMapper", "CallItResponse");
                }
            default =>
                ThrowDecodingException("PortMapper");
        }
    }
}

contract OperationContract
{
    accepts operation Set
    {
        in Call Call;
        out Reply Reply;
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper Set Service (1)";
        }
    }
    
    accepts operation Unset
    {
        in Call Call;
        out Reply Reply;
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper Unset Service (2)";
        }
     }
     
    accepts operation GetPort
    {
        in Call Call;
        out XdrUnsignedInt MappedPort; 
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper GetPort Service (3)";
        }
    }
   
    accepts operation Dump
    {
        out DumpReply DumpReply;
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper Dump Service (4)";
        }
    }
    
    accepts operation CallIt
    {
        in CallArguments CallArguments;
        out CallResults CallResults;
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper CallIt Service (5)";
        }
    }
}

contract MessageContract
{
    accepts message SetRequest
    {
        Call Call;
        
        override string ToString()
        {
           return "PortMapper: Version2 PortMapper Set Request Message (1)";
        }
    }
    
    issues message SetResponse
    {
        Reply Reply;
        
        override string ToString()
        {
           return "PortMapper: Version2 PortMapper Set Response Message (1)";
        }
    }
    
    accepts message UnsetRequest
    {
        Call Call;
        
        override string ToString()
        {
           return "PortMapper: Version2 PortMapper Unset Request Message (2)";
        }
    }
    
    issues message UnsetResponse
    {
        Reply Reply;
        
        override string ToString()
        {
           return "PortMapper: Version2 PortMapper Unset Response Message (2)";
        }
    }
    
    accepts message GetPortRequest
    {
        Call Call;
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper GetPort Request Message (3)";
        }
    }
    
    issues message GetPortResponse
    {
        XdrUnsignedInt MappedPort;
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper GetPort Response Message (3)";
        }
    }
    
    issues message DumpResponse
    {
        DumpReply DumpReply; 
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper Dump Response Message (4)";
        }
    }
    
    accepts message CallItRequest
    { 
        CallArguments CallArguments;
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper CallIt Request Message (5)";
        }
    }
    
    issues message CallItResponse
    {
        CallResults CallResults;
        
        override string ToString()
        {
            return "PortMapper: Version2 PortMapper CallIt Response Message (5)";
        }
    }
}

autostart actor OperationContractActor(IntermediateServer node)
{
    MessageContract.SetRequest setRequest = null;
    MessageContract.UnsetRequest unsetRequest = null;
    MessageContract.GetPortRequest getPortRequest = null;
    MessageContract.DumpResponse dumpResponse = null;
    MessageContract.CallItRequest callItRequest = null;

    // Set request
    process node accepts req:MessageContract.SetRequest
    {
        if (setRequest == null)
        {
            setRequest = req;
        }
        else
        {
            ValidationCheck(false, setRequest, "PortMapper: Incomplete Set operation due to missing Set response.");
            setRequest = null;
            setRequest = req;
        }
    }
    
    // response
    process node issues res:MessageContract.SetResponse
    {
        if (setRequest == null)
        {
            ValidationCheck(false, res, "PortMapper: Incomplete Set operation due to missing Set request.");
            reject;
        }
        else
        {
            var setOp = new OperationContract.Set
            {
                Call = setRequest.Call,
                Reply = res.Reply
            };
            setOp.Origins = [setRequest as any message, res as any message];
            setRequest = null;
            dispatch (endpoint Server over node) accepts setOp;
        }
    }
    
    // Unset Request
    process node accepts req:MessageContract.UnsetRequest
    {
        if (unsetRequest == null)
        {
            unsetRequest = req;
        }
        else
        {
            ValidationCheck(false, unsetRequest, "PortMapper: Incomplete Unset operation due to missing UnSet response.");
            unsetRequest = null;
            unsetRequest = req;
        }
    }
    
    // response
    process node issues res:MessageContract.UnsetResponse
    {
        if (unsetRequest == null)
        {
            ValidationCheck(false, res, "PortMapper: Incomplete UnSet operation due to missing UnSet request.");
            reject;
        }
        else
        {
            var unsetOp = new OperationContract.Unset
            {
                Call = unsetRequest.Call,
                Reply = res.Reply
            };
            unsetOp.Origins = [unsetRequest as any message, res as any message];
            unsetRequest = null;
            dispatch (endpoint Server over node) accepts unsetOp;
        }
    }
    
    // GetPort Request
    process node accepts req:MessageContract.GetPortRequest
    {
        if (getPortRequest == null)
        {
            getPortRequest = req;
        }
        else
        {
            ValidationCheck(false, getPortRequest, "PortMapper: Incomplete GetPort operation due to missing GetPort response.");
            getPortRequest = null;
            getPortRequest = req;
        }
    }
    
    // response
    process node issues res:MessageContract.GetPortResponse
    {
        if (getPortRequest == null)
        {
            ValidationCheck(false, res, "PortMapper: Incomplete GetPort operation due to missing GetPort request.");
            reject;
        }
        else
        {
            var getPortOp = new OperationContract.GetPort
            {
                Call = getPortRequest.Call,
                MappedPort = res.MappedPort,
            };
            // added for following frames using the replied port
            Mapping mapping = new Mapping();
            mapping.ProgramNumber = getPortRequest.Call.Mapping.ProgramNumber;
            mapping.ProgramVersion = getPortRequest.Call.Mapping.ProgramVersion;
            mapping.ProtocolType = getPortRequest.Call.Mapping.ProtocolType;
            mapping.Port = res.MappedPort;
            GetPortMappings += [mapping];
            getPortOp.Origins = [getPortRequest as any message, res as any message];
            getPortRequest = null;
            dispatch (endpoint Server over node) accepts getPortOp;
        }
    }
    
    // Dump response
    process node issues res:MessageContract.DumpResponse
    {
        var dumpOp = new OperationContract.Dump
        {
            DumpReply = res.DumpReply
        };
        dumpOp.Origins = [ res as any message];
        dispatch (endpoint Server over node) accepts dumpOp;
      
    }
    
    // CallIt Request
    process node accepts req:MessageContract.CallItRequest
    {
        if (callItRequest == null)
        {
            callItRequest = req;
        }
        else
        {
            ValidationCheck(false, callItRequest, "PortMapper: Incomplete CallIt operation due to missing CallIt response.");
            callItRequest = null;
            callItRequest = req;
        }
    }
    
    // response
    process node issues res:MessageContract.CallItResponse
    {
        if (callItRequest == null)
        {
            ValidationCheck(false, res, "PortMapper: Incomplete CallIt operation due to missing CallIt request.");
            reject;
        }
        else
        {
            var callItOp = new OperationContract.CallIt
            {
                CallArguments = callItRequest.CallArguments,
                CallResults = res.CallResults
            };
            callItOp.Origins = [callItRequest as any message, res as any message];
            callItRequest = null;
            dispatch (endpoint Server over node) accepts callItOp;
        }
    }
}

type Call
{
    Mapping Mapping;
}

type Reply
{
    XDRBool ReturnValue;
}

type Mapping
{
    XdrUnsignedInt ProgramNumber;
    XdrUnsignedInt ProgramVersion;
    ProType ProtocolType;
    XdrUnsignedInt Port;
}

pattern ProType = enum uint
{
    TCP = 6,
    UDP = 17
};

type DumpReply
{
    XDRBool Pointer;
    optional [|Pointer == XDRBool.TRUE|] MappingList MappingList;
}

type MappingList
{
    Mapping Map;
    XDRBool Next;
    optional [|Next == XDRBool.TRUE|] MappingList NextMap;
}

type CallArguments
{
    XdrUnsignedInt ProgramNumber;
    XdrUnsignedInt ProgramVersion;
    XdrUnsignedInt Procedure;
    XdrOpaqueVariable Arguments;
}

type CallResults
{
    XdrUnsignedInt Port;
    XdrOpaqueVariable Results;
}

