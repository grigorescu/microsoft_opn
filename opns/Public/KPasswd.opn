protocol KPasswd with 
BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "Microsoft Windows 2000 Kerberos Change Password and Set Password Protocols",
    ShortName = "KPasswd",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 3244"},
        ],
    RevisionSummary = 
        [
            new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "09/27/2011"}
        ]
};

using Standard;
using Utility;
using IANA;
using UDP;
using TCP;
using KerberosV5;
using VirtualTransport;
using Reassembly;

endpoint Server
    over UDP.Host | over VirtualTransport.Server
    accepts DatagramOverTCP issues DatagramOverTCP
    accepts DatagramOverUDP issues DatagramOverUDP;

client endpoint Client connected to Server;

autostart actor KerberosOverKPasswd(KPasswd.Server server)
{
    process server accepts s:KPasswd.DatagramOverTCP
    {
        KerberosOverKPasswdDecoder(s.KPasswdMessage, server);
    }
    
    process server issues s:KPasswd.DatagramOverTCP
    {
        KerberosOverKPasswdDecoder(s.KPasswdMessage, server);
    }
    
    process server accepts s:KPasswd.DatagramOverUDP
    {
        KerberosOverKPasswdDecoder(s.KPasswdMessage, server);
    }
    
    process server issues s:KPasswd.DatagramOverUDP
    {
        KerberosOverKPasswdDecoder(s.KPasswdMessage, server);
    }
}

void KerberosOverKPasswdDecoder((KPasswd.Reply | KPasswd.Request) kPasswdMessage, KPasswd.Server server)
{
    binary apRepData = $[];
    binary krbMessage = $[];
    if (kPasswdMessage is KPasswd.Reply)
    {
        var reply = kPasswdMessage as KPasswd.Reply;
        if(reply.ApRepData != nothing)
        {
            apRepData = reply.ApRepData as binary;
        }
        krbMessage = reply.KrbMessage;
    }
    else if (kPasswdMessage is Request)
    {
        var request = kPasswdMessage as KPasswd.Request;
        if (request.ApReqData != nothing)
        {
            apRepData = request.ApReqData as binary;
        }
        krbMessage = request.KrbMessage;
    }
        
    // Decode ApRepData
    if (apRepData != $[])
    {
        switch(apRepData)
        {
            case krbMsg:KrbMessage from Asn1BerDecoder<KrbMessage> =>
                PADataDecoder(krbMsg);
                dispatch (endpoint KerberosV5.Server over server) issues krbMsg;
            default =>
                ThrowDecodingException("KerberosV5 Message");
        }
    }
        
    // Decode KrbMessage
    if (krbMessage != $[])
    {
        switch(krbMessage)
        {
            case krbMsg:KrbMessage from Asn1BerDecoder<KrbMessage> =>
                PADataDecoder(krbMsg);
                dispatch (endpoint KerberosV5.Server over server) issues krbMsg;
            default =>
                ThrowDecodingException("KerberosV5 Message");
        }
    }
}

autostart actor KPasswdOverUDP(UDP.Host host)
{
    process host accepts d:UDP.Datagram {DestinationPort is Port.KPasswd}
    {
        switch (d.Payload)
        {
            case kp:DatagramOverUDP from BinaryDecoder<DatagramOverUDP> =>
                var node = endpoint Server over host;
                dispatch node accepts kp;
            default =>
                ThrowDecodingException("KPasswd", "DatagramOverUDP");
        }
    }
     
    process host accepts d:UDP.Datagram{SourcePort is Port.KPasswd}
    {
        switch (d.Payload)
        {
            case kp:DatagramOverUDP from BinaryDecoder<DatagramOverUDP> =>
                var node = endpoint Server over host;
                dispatch node issues kp;
            default =>
                ThrowDecodingException("KPasswd", "DatagramOverUDP");
        }
    }
}

autostart actor PasswdOverTCP(VirtualTransport.Server server)
{
    bool IsFirstFrame = true;
    uint Length;
    DecodingCache cache = new DecodingCache{};
    process server accepts d:VirtualTransport.VirtualDataSegment{DestinationPort is Port.KPasswd}
    {
       if (IsFirstFrame == true)
       {
           Length = (d.Payload.Segment(8,2)[0] as uint) * 256 + (d.Payload.Segment(8,2)[1] as uint);
           cache.Buffer = d.Payload;
           cache.Origins = [d];
       }
       else
       {
           cache.Buffer += d.Payload;
           cache.Origins += [d];
       }
       
       if (Length <= cache.Buffer.Count - 10)
       {
           var node = endpoint Server over server;
           switch (cache.Buffer)
           {
               case kp:DatagramOverTCP from BinaryDecoder<DatagramOverTCP> =>
                   IsFirstFrame = true;
                   kp.Origins = cache.Origins;
                   dispatch node accepts kp;
               default =>
                   IsFirstFrame = true;
                   ThrowDecodingException("KPasswd", "DatagramOverTCP");
           }
       }
       else
       {
           IsFirstFrame = false;
       }
    }
    
    process server issues d:VirtualTransport.VirtualDataSegment{SourcePort is Port.KPasswd}
    { 
        if (IsFirstFrame == true)
        {
            Length = (d.Payload.Segment(8,2)[0] as uint) * 256 + (d.Payload.Segment(8,2)[1] as uint);
            cache.Buffer = d.Payload;
            cache.Origins = [d];
            
        }
        else
        {
            cache.Buffer += d.Payload;
            cache.Origins += [d];
        }
        
        if (Length <= cache.Buffer.Count - 10)
        {
            var node = endpoint Server over server;
            switch (cache.Buffer)
            {
                case kp:DatagramOverTCP from BinaryDecoder<DatagramOverTCP> =>
                    IsFirstFrame = true;
                    kp.Origins = cache.Origins;
                    dispatch node issues kp;
                default =>
                    IsFirstFrame = true;
                    ThrowDecodingException("KPasswd", "DatagramOverTCP");
            }
        }
        else
        {
            IsFirstFrame = false;
        } 
    }
    
    ~endpoint(VirtualTransport.Server e)
    {
        cache.Clear();
    }
}

type DecodingCache : DecodingCacheBase
{
}

message DatagramOverTCP
{
    uint Header;
    (Reply | Request) KPasswdMessage;
    
    override string ToString()
    {
        if (KPasswdMessage is Request)
        {
            return "Request";
        }
        else
        {
            return "Reply";
        }
    } 
}

message DatagramOverUDP
{
    (Request | Reply) KPasswdMessage;
    
    override string ToString()
    {
        if (KPasswdMessage is Request)
        {
            return "Request";
        }
        else
        {
            return "Reply";
        }
    }
}

type Request
{
    ushort MessageLength;
    (ushort where value == 0xff80) ProtocolVersionNumber;
    ushort ApReqLength;
    optional [|ApReqLength > 0|] binary ApReqData with BinaryEncoding{Length = ApReqLength};
    binary KrbMessage;
}

type Reply
{
    ushort MessageLength;
    (ushort where value == 0x0001) ProtocolVersionNumber;
    ushort ApRepLength;
    optional [|ApRepLength > 0|] binary ApRepData with BinaryEncoding{Length = ApRepLength};
    binary KrbMessage;
}

type EData
{
   ResultCode ResultCode;
   string ResultString with BinaryEncoding{TextEncoding = TextEncoding.UTF8};
}

pattern ResultCode = enum ushort
{
     KrbsKpasswdSuccess                = 0,
     KrbsKapasswdMalFormed             = 1,
     KrbsKpasswdHardError              = 2,
     KrbsKpasswdAuthError              = 3,
     KrbsKpasswdSoftError              = 4,
     KrbsKpasswdAccessDenied           = 5,
     KrbsKpasswdBadVersion             = 6,
     KrbsKpasswdInitialFlageNeeded     = 7,
     RequestFailsWithOtherReason       = 0xFFFF    
};


string GetName(ResultCode code)
{
    switch (code)
    {
       case 0 => return "request succeeds ";
       case 1 => return "request fails due to being malformed";
       case 2 => return "request fails due to 'hard' error in processing the request";
       case 3 => return "request fails due to an error in authentication processing";
       case 4 => return "request fails due to 'soft' error in processing the request";
       case 5 => return "requestor not authorized";
       case 6 => return "protocol version unsupported";
       case 7 => return "initial flag required";
       case 0xFFFF => return "request fails with some other reason";
       default => return "Unknown Result Code" + (code as string);
    }
}
