module PAC with
BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "Privilege Attribute Certificate Data Structure",
    ShortName = "PAC",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
        new Reference{Name = "MS-PAC", Version = "14.0", ProgramName = ProgramName.WSPP},
    ],
    RevisionSummary = 
      [
         new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "03/30/2012"} 
      ]
};

using Standard;
using DTYP;
using Utility;
using Technologies.IDL;

// Future Reference: Need to refactor PAC with IDL definition

//pattern PacInfoBufferUlType = enum uint {
        //LogonInformation = 0x00000001,
        //CredentialsInformation = 0x00000002,
        //ServerChecksum = 0x00000006,
        //KDCChecksum = 0x00000007,
        //ClientNameTicketInformation = 0x0000000A,
        //ConstrainedDelegationInformation = 0x0000000B,
        //UPNAndDNSInformation = 0x0000000C
//};
        //
//pattern PacCredentialInfoEncrytionType = enum uint
//{
    //DES = 0x00000001,
    //DESInCBCModeWithMD5 = 0x00000003,
    //AES128_CTS_HMAC_SHA1_96 = 0x00000011,
    //AES256_CTS_HMAC_SHA1_96 = 0x00000012,
    //RC4WithHMACKey = 0x00000017,
//};
//
//pattern PacSignatureDataSignatureType = enum uint
//{
    //KERB_CHECKSUM_HMAC_MD5 = 0xffffff76,
    //HMAC_SHA1_96_AES128 = 0x0000000f,
    //HMAC_SHA1_96_AES256 = 0x00000010
//};
//
//type Attributes
//{
    //ushort Reserved1 with BinaryEncoding{Width = 2};
    //bool E with BinaryEncoding{Width = 1};
    //uint Reserved2 with BinaryEncoding{Width = 25};
    //bool D with BinaryEncoding{Width = 1};
    //bool C with BinaryEncoding{Width = 1};
    //bool B with BinaryEncoding{Width = 1};
    //bool A with BinaryEncoding{Width = 1};
//}
//
//// KERB_SID_AND_ATTRIBUTES
//type KerbSidAndAttributes
//{
    //ULongPtr pRPCSid;
    //Attributes attributes;
//}
//
//// GROUP_MEMBERSHIP
//type GroupMembership
//{
    //uint RelativeId;
    //Attributes Attributes;
//}
//
//// PACTYPE
//type PacType
//{
    //uint BufferLength with BinaryEncoding{Endian = Endian.Little};
    //uint Version where value == 0x00000000 with BinaryEncoding{Endian = Endian.Little};
    //array<PacInfoBuffer> Buffers with BinaryEncoding{Length = BufferLength};
    //array<any> BuffersRef with Encoding{Ignore = true};
//}
//
//// PAC_INFO_BUFFER
//type PacInfoBuffer
//{
    //PacInfoBufferUlType Type with BinaryEncoding{Endian = Endian.Little};
    //uint BufferSize with BinaryEncoding{Endian = Endian.Little};
    //ulong Offset where ValidationCheck(value%8 == 0, null, "PAC: PacInfoBuffer.Offset must be a multiple of eight.") with BinaryEncoding{Endian = Endian.Little};
//}
//
//optional PacType PacTypeDecoder(stream s)
//{
    //optional PacType pacType = BinaryDecoder<PacType>(s);
//
    //array<any> bufferRefs = [];
    //foreach (var buffer in pacType.Buffers)
    //{
        //var bufferRefbinary = s.PeekBytes(s.BitPosition, s.ByteLength);
        //switch (buffer.Type)
        //{
            //case PacInfoBufferUlType.LogonInformation =>
                //var kerbValidationInfo = KerbValidationInfoDecoder(bufferRefbinary);
                //bufferRefs += [kerbValidationInfo as any];
            //case PacInfoBufferUlType.CredentialsInformation =>
                //var pacCredentialInfo = BinaryDecoder<PacCredentialInfo>(bufferRefbinary);
                //bufferRefs += [pacCredentialInfo as any];
            //case PacInfoBufferUlType.ServerChecksum =>
            //case PacInfoBufferUlType.KDCChecksum =>
                //var pacSignatureData = BinaryDecoder<PacSignatureData>(bufferRefbinary);
                //bufferRefs += [pacSignatureData as any];
            //case PacInfoBufferUlType.ClientNameTicketInformation =>
                //var pacClintInfo = BinaryDecoder<PacClintInfo>(bufferRefbinary);
                //bufferRefs += [pacClintInfo as any];
            //case PacInfoBufferUlType.ConstrainedDelegationInformation =>
                //var s4uDelegationInfo = BinaryDecoder<S4uDelegationInfo>(bufferRefbinary);
                //bufferRefs += [s4uDelegationInfo as any];
            //case PacInfoBufferUlType.UPNAndDNSInformation =>
                //var upnDnsInfo = UpnDnsInfoDecoder(bufferRefbinary);
                //bufferRefs += [upnDnsInfo as any];
            //default =>
                //ThrowDecodingException("PAC");
         //}
    //}
    //
    //pacType.BuffersRef = bufferRefs;
    //return pacType;
//}
//
//type CypherBlock
//{
    //array<byte> data with BinaryEncoding{Length = 8};
//}
//
//type UserSessionKey
//{
    //array<CypherBlock> data with BinaryEncoding{Length = 2};
//}
//
//type KerbValidationInfoUserFlags
//{
    //uint Reserved with BinaryEncoding{Width = 18};
    //uint L with BinaryEncoding{Width = 1};
    //uint K with BinaryEncoding{Width = 1};
    //uint J with BinaryEncoding{Width = 1};
    //uint I with BinaryEncoding{Width = 1};
    //uint H with BinaryEncoding{Width = 1};
    //uint G with BinaryEncoding{Width = 1};
    //uint F with BinaryEncoding{Width = 1};
    //uint E with BinaryEncoding{Width = 1};
    //uint D with BinaryEncoding{Width = 1};
    //uint Reserved1 with BinaryEncoding{Width = 1};
    //uint C with BinaryEncoding{Width = 1};
    //uint Reserved2 with BinaryEncoding{Width = 1};
    //uint B with BinaryEncoding{Width = 1};
    //uint A with BinaryEncoding{Width = 1};
//}
//
//// struct _KERB_VALIDATION_INFO
//type KerbValidationInfo
//{
    //FILETIME LogonTime;
    //FILETIME LogoffTime;
    //FILETIME KickOffTime;
    //FILETIME PasswordLastSet;
    //FILETIME PasswordCanChange;
    //FILETIME PasswordMustChange;
    //RPC_UNICODE_STRING EffectiveName; 
    //RPC_UNICODE_STRING FullName;
    //RPC_UNICODE_STRING LogonScript;
    //RPC_UNICODE_STRING ProfilePath;
    //RPC_UNICODE_STRING HomeDirectory;
    //RPC_UNICODE_STRING HomeDirectoryDrive;
    //ushort LogonCount;
    //ushort BadPasswordCount;
    //uint UserId;
    //uint PrimaryGroupId;
    //uint GroupCount;
    //ULongPtr pGroupIds;
    //KerbValidationInfoUserFlags UserFlags;
    //UserSessionKey UserSessionKey;
    //RPC_UNICODE_STRING LogonServer;
    //RPC_UNICODE_STRING LogonDomainName;
    //ULongPtr pLogonDomainId;
    //array<uint> Reserved1 with BinaryEncoding{Length = 2};
    //uint UserAccountControl;
    //uint SubAuthStatus;
    //FILETIME LastSuccessfulILogon;
    //FILETIME LastFailedILogon;
    //uint FailedILogonCount;
    //uint Reserved3;
    //uint SidCount;
    //ULongPtr pExtraSids;
    //ULongPtr pResourceGroupDomainSid;
    //uint ResourceGroupCount;
    //ULongPtr pResourceGroupIds;
    //optional [|EffectiveName.pBuffer != 0|] RPCUnicodeStringRef EffectiveNameRef;
    //optional [|FullName.pBuffer != 0|] RPCUnicodeStringRef FullNameRef;
    //optional [|LogonScript.pBuffer != 0|] RPCUnicodeStringRef LogonScriptRef;
    //optional [|ProfilePath.pBuffer != 0|] RPCUnicodeStringRef ProfilePathRef;
    //optional [|HomeDirectory.pBuffer != 0|] RPCUnicodeStringRef HomeDirectoryRef;
    //optional [|HomeDirectoryDrive.pBuffer != 0|] RPCUnicodeStringRef HomeDirectoryDriveRef;
    //optional [|pGroupIds != 0|] uint GroupIdSize;
    //optional [|pGroupIds != 0|] array<GroupMembership> GroupIds with BinaryEncoding{Length = GroupIdSize as uint};
    //optional [|LogonServer.pBuffer != 0|] RPCUnicodeStringRef LogonServerRef;
    //optional [|LogonDomainName.pBuffer != 0|] RPCUnicodeStringRef LogonDomainNameRef;
    //optional [|pLogonDomainId != 0|] RPC_SID LogonDomainId;
    //array<any> ExtraSids;
    //any ResourceGroupDomainSid;
    //array<any> ResourceGroupIds;
//}
//
//optional KerbValidationInfo KerbValidationInfoDecoder(stream s)
//{
    //KerbValidationInfo kerbValidationInfo = BinaryDecoder<KerbValidationInfo>(s);
    //
    //if (kerbValidationInfo.pExtraSids as uint > 0)
    //{
        //var size = BinaryDecoder<uint>(s);
        //array<any> extraSids = [];
        //extraSids += [size as any];
        //if (size > 0)
        //{
            //int sidCount = 0;
            //for(int i = 0; i < size; i++)
            //{
                //var extraSid = BinaryDecoder<KerbSidAndAttributes>(s);
                //if (extraSid.pRPCSid as uint > 0)
                //{
                    //sidCount++;
                //}
                //extraSids += [extraSid as any];
            //}
            //for(; sidCount> 0; sidCount--)
            //{
                //var sid = BinaryDecoder<RPC_SID>(s);
                //extraSids += [sid as any];
            //}
        //}
        //kerbValidationInfo.ExtraSids = extraSids;
    //}
    //
    //if (kerbValidationInfo.pResourceGroupDomainSid as uint > 0)
    //{
        //var resourceGroupDomainSid = BinaryDecoder<RPC_SID>(s);
        //kerbValidationInfo.ResourceGroupDomainSid = resourceGroupDomainSid;
    //}
    //
    //if (kerbValidationInfo.pResourceGroupIds as uint > 0)
    //{
        //var resourceGroupCount = BinaryDecoder<uint>(s);
        //array<any> resourceGroupIds = [];
        //resourceGroupIds += [resourceGroupCount as any];
        //if (resourceGroupCount as uint > 0)
        //{
            //for(; resourceGroupCount > 0; resourceGroupCount--)
            //{
                //var groupMembership = BinaryDecoder<GroupMembership>(s);
                //resourceGroupIds += [groupMembership as any];
            //}
        //}
        //kerbValidationInfo.ResourceGroupIds = resourceGroupIds;
    //}
    //
    //return kerbValidationInfo;
//}
//
//// PAC_CREDENTIAL_INFO
//type PacCredentialInfo
//{
    //uint Version where value == 0x00000000 with BinaryEncoding{Endian = Endian.Little};
    //PacCredentialInfoEncrytionType EncrytionType with BinaryEncoding{Endian = Endian.Little};
    //binary SerializedData;
//}
//
//// PAC_CLIENT_INFO
//type PacClintInfo
//{
    //FILETIME ClientId with BinaryEncoding{Endian = Endian.Little};
    //ushort NameLength with BinaryEncoding{Endian = Endian.Little};
    //string Name with BinaryEncoding{Length = (NameLength as uint)/2};
//}
//
//// PAC_SIGNATURE_DATA
//type PacSignatureData 
//{
    //PacSignatureDataSignatureType SignatureType;
    //array<byte> Signature with BinaryEncoding{Length = ((SignatureType == 0xffffff76)?16:12)};
    //ushort RODCIdentifier;
//}
//
//// struct _S4U_DELEGATION_INFO
//type S4uDelegationInfo
//{
    //RPC_UNICODE_STRING S4U2proxyTarget;
    //uint TransitedListSize;
    //ULongPtr  pS4UTransitedServices;
    //array<RPC_UNICODE_STRING> S4UTransitedServices with BinaryEncoding{Length = TransitedListSize};
//}
//
//// UPN_DNS_INFO
//type UpnDnsInfo
//{
    //ushort UpnLength with BinaryEncoding{Endian = Endian.Little};
    //ushort UpnOffset with BinaryEncoding{Endian = Endian.Little};
    //ushort DnsDomainNameLength with BinaryEncoding{Endian = Endian.Little};
    //ushort DnsDomainNameOffset with BinaryEncoding{Endian = Endian.Little};
    //ulong Flags with BinaryEncoding{Endian = Endian.Little};
    //any UPN;
    //any DnsDomainName;
//}
//
//optional UpnDnsInfo UpnDnsInfoDecoder(binary binaryValue)
//{
    //var f = BinaryDecoder<UpnDnsInfo>(binaryValue);
    //var upnDnsInfo = f as UpnDnsInfo;
    //upnDnsInfo.UPN = BinaryDecoder<string>(binaryValue.Segment(f.UpnOffset as int, f.UpnLength as int));
    //upnDnsInfo.DnsDomainName = BinaryDecoder<string>(binaryValue.Segment(f.DnsDomainNameOffset as int, f.DnsDomainNameLength as int));
    //return upnDnsInfo;
//}
//
//// NDR related type
//type RPCUnicodeStringRef
//{
    //array<WCHAR> Buffer with IDL{String = true};
//}
