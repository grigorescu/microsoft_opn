protocol MPA with 
BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "Marker PDU Aligned Framing for TCP Specification",
    ShortName = "MPA",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 5044"},
        ],
    RevisionSummary =
        [
            new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "28/04/2012"}
        ]
};

using TCP;
using Utility;
using IANA;
using VirtualTransport;

endpoint Node over VirtualTransport.Server
    accepts MpaRequestFrame
    issues MpaRequestFrame
    accepts MpaReplyFrame
    issues MpaReplyFrame
    accepts Fpdu
    issues Fpdu;

autostart actor MpaOverTcp(Server server)
{
    bool receiveFpdu = false;
    Flag requestFlag;
    Flag replyFlag;

    // 7.1.1  MPA Request and Reply Frame Format
    process server accepts f:VirtualTransport.VirtualDataSegment where f.Payload.Count >= 16 && f.Payload.Segment(0, 16) == $[4D504120494420526571204672616D65] // The binary means :"MPA ID Req Frame"
    {
        switch (f.Payload)
        {
            case m:MpaRequestFrame from BinaryDecoder<MpaRequestFrame> =>
                requestFlag = m.Flag;
                dispatch (endpoint MPA.Node over server) accepts m;
            default => 
                ThrowDecodingExceptionForTCP("MPA", "MpaRequestFrame", f#IsIncomplete, f#SegmentLost);
        }
    }

    // 7.1.1  MPA Request and Reply Frame Format
    process server issues f:VirtualTransport.VirtualDataSegment where f.Payload.Count >= 16 && f.Payload.Segment(0, 16) == $[4D504120494420526571204672616D65] // The binary means :"MPA ID Req Frame"
    {
        switch (f.Payload)
        {
            case m:MpaRequestFrame from BinaryDecoder<MpaRequestFrame> =>
                replyFlag = m.Flag;
                dispatch (endpoint MPA.Node over server) issues m;
            default => 
                ThrowDecodingExceptionForTCP("MPA", "MpaRequestFrame", f#IsIncomplete, f#SegmentLost);
        }
    }

    // 7.1.1  MPA Request and Reply Frame Format 
    process server accepts f:VirtualTransport.VirtualDataSegment where f.Payload.Count >= 16 && f.Payload.Segment(0, 16) == $[4D504120494420526570204672616D65] // The binary means :"MPA ID Rep Frame"
    {
        switch (f.Payload)
        {
            case m:MpaRequestFrame from BinaryDecoder<MpaRequestFrame> =>
                replyFlag = m.Flag;
                dispatch (endpoint MPA.Node over server) accepts m;
                if(!m.Flag.R)
                {
                    receiveFpdu = true;
                }
            default => 
                ThrowDecodingExceptionForTCP("MPA", "MpaRequestFrame", f#IsIncomplete, f#SegmentLost);
        }
    }

    process server issues f:VirtualTransport.VirtualDataSegment where f.Payload.Count >= 16 && f.Payload.Segment(0, 16) == $[4D504120494420526570204672616D65] // The binary means :"MPA ID Rep Frame"
    {
        switch (f.Payload)
        {
            case m:MpaRequestFrame from BinaryDecoder<MpaRequestFrame> =>
                replyFlag = m.Flag;
                dispatch (endpoint MPA.Node over server) issues m;
                if(!m.Flag.R)
                {
                    receiveFpdu = true;
                }
            default => 
                ThrowDecodingExceptionForTCP("MPA", "MpaRequestFrame", f#IsIncomplete, f#SegmentLost);
        }
    }
    
    process server accepts f:VirtualTransport.VirtualDataSegment where receiveFpdu && !(f.SourcePort is Port) && !(f.DestinationPort is Port) && f.Payload.Count > 6
    {
        optional Fpdu fpdu = MpaFpduDecoder(f.Payload, requestFlag, replyFlag);
        if (fpdu != nothing)
        {
            dispatch (endpoint MPA.Node over server) accepts (fpdu as Fpdu);
        }
        else
        {
            ThrowDecodingExceptionForTCP("MPA", "Fpdu", f#IsIncomplete, f#SegmentLost);
        }
    }

    process server issues f:VirtualTransport.VirtualDataSegment where receiveFpdu && !(f.SourcePort is Port) && !(f.DestinationPort is Port) && f.Payload.Count > 6
    {
        optional Fpdu fpdu = MpaFpduDecoder(f.Payload, requestFlag, replyFlag);
        if (fpdu != nothing)
        {
            dispatch (endpoint MPA.Node) issues (fpdu as Fpdu);
        }
        else
        {
            ThrowDecodingExceptionForTCP("MPA", "Fpdu", f#IsIncomplete, f#SegmentLost);
        }
    }
}

type Flag
{
    bool M with BinaryEncoding{Width = 1};      // declares that Markers are REQUIRED(1) or not(0)
    bool C with BinaryEncoding{Width = 1};      // 0 CRCs MUST not be checked and need not be generated by either endpoint
    bool R with BinaryEncoding{Width = 1};      // In the MPA Reply Frame, this bit is the Rejected Connection bit, set by the Responders ULP to indicate acceptance '0', or rejection '1', of the connection parameters provided in the Private Data.
    byte Res where ValidationCheck(value == 0, null, "The Flag.Res field is set to zero.") with BinaryEncoding{Width = 5};
}

// 7.1.1  MPA Request and Reply Frame Format
message MpaRequestFrame
{
    string Key with BinaryEncoding{Length = 16, TextEncoding = TextEncoding.ASCII};
    Flag Flag;
    (byte where value == 1) Rev;
    ushort PDLength;
    binary PrivateData with BinaryEncoding{Length = (PDLength as uint)};

    override string ToString()
    {
        return "Key=" + Key
            + " M="+ (Flag.M as string)
            + " C="+ (Flag.C as string)
            + " R="+ (Flag.R as string)
            + " Rev=" + (Rev as string)
            + " PDLength=" + (PDLength as string);
    }
}

message MpaReplyFrame
{
    string Key with BinaryEncoding{Length = 16, TextEncoding = TextEncoding.ASCII};
    Flag Flag;
    (byte where value == 1) Rev;
    ushort PDLength;
    binary PrivateData with BinaryEncoding{Length = (PDLength as uint)};

    override string ToString()
    {
        return "Key=" + Key
            + " M="+ (Flag.M as string)
            + " C="+ (Flag.C as string)
            + " R="+ (Flag.R as string)
            + " Rev=" + (Rev as string)
            + " PDLength=" + (PDLength as string);
    }
}

message Fpdu
{
    (ushort where value != 0) UlpduLength;
    binary Ulpdu with BinaryEncoding{Length = UlpduLength};
    binary Pad with BinaryEncoding{Length = (UlpduLength + 2) % 4 == 0 ? 0 : (4 - (UlpduLength + 2) % 4) as uint};
    uint Crc;
    optional array<Marker> Marker with Encoding{Ignore = true};
    
    override string ToString()
    {
        return "UlpduLength=" + (UlpduLength as string) + " Crc=" + (Crc as string);
    }
}

type Marker
{
    ushort Reserved;
    ushort FpduPtr;
}

optional Fpdu MpaFpduDecoder(binary binVaule, Flag requestFlag, Flag replyFlag)
{
    optional Fpdu resultOptional = nothing;
    if (binVaule == null || binVaule == $[])
    {
        return nothing;
    }
    else
    {
        binary binaryValue = binVaule;
        array<Marker> markerArray = [];
        if(requestFlag.M || replyFlag.M)
        {
            uint count = 0;
            for (int i = 0; i < binVaule.Count - 3; i++)
            {
                if (binaryValue[i] == 0 && binaryValue[i + 1] == 0 && (binaryValue[i + 2] << 8 + binaryValue[i + 3]) == count)
                {
                    Marker markerTemp = new Marker{};
                    markerTemp.Reserved = 0;
                    markerTemp.FpduPtr = i as ushort;
                    markerArray += [markerTemp];
                    binaryValue = binaryValue.Segment(0, i) + binaryValue.Segment(i + 4, binaryValue.Count - i - 4);
                    i = i + 507; // 512 - 4 - 1
                    count = count + 511; // 512 - 1
                }
                count ++;
            }
        }
        
        resultOptional = BinaryDecoder<Fpdu>(binaryValue);
        if (resultOptional != nothing)
        {
            var result = resultOptional as Fpdu;
            if (markerArray == [])
            {
                result.Marker = nothing;
            }
            else
            {
                result.Marker = markerArray;
            }
        }
    }
    return resultOptional;
}
