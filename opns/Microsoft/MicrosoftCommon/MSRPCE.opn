protocol MSRPCE with 
BinaryEncodingDefaults{Endian = Endian.Little, TextEncoding = TextEncoding.ASCII},
Documentation
{
    ProtocolName = "Microsoft Remote Procedure Call Protocol Extensions",
    ShortName = "MSRPCE",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
    [
    new Reference{Name = "X/Open C706", Link = "http://www.opengroup.org/pubs/catalog/c706.htm"},
    new Reference{Name = "MS-RPCE", Version = "25", ProgramName = ProgramName.WSPP},
    ],
    RevisionSummary =
    [
    new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "09/02/2011"}
    ]
};

using Standard;
using TCP;
using UDP;
using IANA;
using DTYP;
using Utility;
using VirtualTransport;
using TLS;

//_______________________________________________________________________Common________________________________________________________________________
pattern PDUType = enum  byte
{
    Request            = 0,
    Ping               = 1,
    Response           = 2,
    Fault              = 3,
    Working            = 4,
    NoCall             = 5,
    Reject             = 6,
    Ack                = 7,
    ClCancel           = 8,
    Fack               = 9,
    CancelAck          = 10,
    Bind               = 11,
    BindAck            = 12,
    BindNak            = 13,
    AlterContext       = 14,
    AlterContextResp   = 15,
    Auth3              = 16,
    Shutdown           = 17,
    CoCancel           = 18,
    Orphaned           = 19,
};

pattern RejectStatusCodes = enum uint
{
    // MS-RPCE section 3.2.3.5.1   Failure Semantics(for value == 0x00000005)
    ERROR_ACCESS_DENIED              = 0x00000005,
    nca_s_comm_failure               = 0x1C010001, /* unable to get response from server: */
    nca_s_op_rng_error               = 0x1C010002, /* bad operation number in call: */
    nca_s_unk_if                     = 0x1C010003, /* unknown interface: */
    nca_s_wrong_boot_time            = 0x1C010006, /* client passed server wrong server boot time: */
    nca_s_you_crashed                = 0x1C010009, /* a restarted server called back a client: */
    nca_s_proto_error                = 0x1C01000B, /* someone messed up the protocol: */
    nca_s_out_args_too_big           = 0x1C010013, /* output args too big: */
    nca_s_server_too_busy            = 0x1C010014, /* server is too busy to handle call: */
    nca_s_fault_string_too_long      = 0x1C010015, /* string argument longer than declared max len: */
    nca_s_unsupported_type           = 0x1C010017, /* no implementation of generic operation for object: */

    nca_s_fault_int_div_by_zero      = 0x1C000001,
    nca_s_fault_addr_error           = 0x1C000002,
    nca_s_fault_fp_div_zero          = 0x1C000003,
    nca_s_fault_fp_underflow         = 0x1C000004,
    nca_s_fault_fp_overflow          = 0x1C000005,
    nca_s_fault_invalid_tag          = 0x1C000006,
    nca_s_fault_invalid_bound        = 0x1C000007,
    nca_s_rpc_version_mismatch       = 0x1C000008,
    nca_s_unspec_reject              = 0x1C000009, /* call rejected, but no more detail: */
    nca_s_bad_actid                  = 0x1C00000A,
    nca_s_who_are_you_failed         = 0x1C00000B,
    nca_s_manager_not_entered        = 0x1C00000C,
    nca_s_fault_cancel               = 0x1C00000D,
    nca_s_fault_ill_inst             = 0x1C00000E,
    nca_s_fault_fp_error             = 0x1C00000F,
    nca_s_fault_int_overflow         = 0x1C000010,
    /*                   unused: 0x1C000011; */
    nca_s_fault_unspec               = 0x1C000012,
    nca_s_fault_remote_comm_failure = 0x1C000013,
    nca_s_fault_pipe_empty           = 0x1C000014,
    nca_s_fault_pipe_closed          = 0x1C000015,
    nca_s_fault_pipe_order           = 0x1C000016,
    nca_s_fault_pipe_discipline      = 0x1C000017,
    nca_s_fault_pipe_comm_error      = 0x1C000018,
    nca_s_fault_pipe_memory          = 0x1C000019,
    nca_s_fault_context_mismatch     = 0x1C00001A,
    nca_s_fault_remote_no_memory     = 0x1C00001B,
    nca_s_invalid_pres_context_id    = 0x1C00001C,
    nca_s_unsupported_authn_level    = 0x1C00001D,
    nca_s_invalid_checksum           = 0x1C00001F,
    nca_s_invalid_crc                = 0x1C000020,
    nca_s_fault_user_defined         = 0x1C000021,
    nca_s_fault_tx_open_failed       = 0x1C000022,
    nca_s_fault_codeset_conv_error   = 0x1C000023,
    nca_s_fault_object_not_found     = 0x1C000024,
    nca_s_fault_no_client_stub       = 0x1C000025,
    ...
};

// [MS-RPCE] section 3.2.3.5.1   Failure Semantics 
pattern RpcconnFaultHdrT_Status = enum uint
{
    ERROR_SUCCESS = 0x00000000,
    STATUS_GUARD_PAGE_VIOLATION = 0x80000001,
    STATUS_DATATYPE_MISALIGNMENT = 0x80000002,
    STATUS_BREAKPOINT = 0x80000003,
    STATUS_ACCESS_VIOLATION = 0xC0000005,
    STATUS_IN_PAGE_ERROR = 0xC0000006,
    STATUS_ILLEGAL_INSTRUCTION = 0xC000001D,
    STATUS_PRIVILEGED_INSTRUCTION = 0xC0000096,
    STATUS_INSTRUCTION_MISALIGNMENT = 0xC00000AA,
    STATUS_STACK_OVERFLOW = 0xC00000FD,
    STATUS_POSSIBLE_DEADLOCK = 0xC0000194,
    STATUS_HANDLE_NOT_CLOSABLE = 0xC0000235,
    STATUS_STACK_BUFFER_OVERRUN = 0xC0000409,
    STATUS_ASSERTION_FAILURE = 0xC0000420,
};
//__________________________________________________________________________Connectionless____________________________________________________________________________

message DcRpcClPktHdrT
{
    byte RpcVers where value == 4; // RPC protocol major version (4 LSB only)//
    PDUType PType;      // Packet type (5 LSB only) //
    RpcClPktHdrFlag1 Flags1;     // Packet flags //
    RpcClPktHdrFlag2 Flags2 where ValidationCheck((value & 0x3F) == 0, null, DiagnosisLevel.Error, "MSRPCE: The Flags2 in message DcRpcClPktHdrT is not expected, its Reserved04 - Reserved80 are reserved for future use, they must be set to zero.");     // Packet flags //
    // Future Reference: add NDR Format Label and decode in details.
    ClDrepFormatLabel Drep;    // Data representation format label //
    byte SerialHi;  // High byte of serial number //
    guid Object;     // Object identifier //
    guid IfId;      // Interface identifier //
    guid ActId;     // Activity identifier //
    uint  ServerBoot with DisplayInfo{ToText = ServerBootToUTC};// Server boot time //
    uint  IfVers;    // Interface version //
    uint  Seqnum;     // Sequence number //
    ushort Opnum;      // Operation number //
    ushort Ihint;      // Interface hint //
    ushort Ahint;      // Activity hint //
    ushort Len where ValidationCheck(value <= 65528, null, DiagnosisLevel.Error, "MSRPCE: The Len in message DcRpcClPktHdrT should be less than or equal to 65528, and the maximum PDU body size is 65528 bytes.");// Length of packet body //
    ushort Fragnum;    // Fragment number //
    AuthnType AuthProto;  // Authentication protocol identifier //
    byte SerialLo;  // Low byte of serial number //
    
    override string ToString()
    {
        string serialNum = Utility.DecToHexFormat(((SerialHi << 8) + SerialLo) as ushort);
        string pTypeStr;
        switch (PType)
        {
            case PDUType.Request => pTypeStr = "Request";
            case PDUType.Ping => pTypeStr = "Ping";
            case PDUType.Response => pTypeStr = "Response";
            case PDUType.Fault => pTypeStr = "Fault";
            case PDUType.Working => pTypeStr = "Working";
            case PDUType.NoCall => pTypeStr = "NoCall";
            case PDUType.Reject => pTypeStr = "Reject";
            case PDUType.Ack => pTypeStr = "Ack";
            case PDUType.ClCancel => pTypeStr = "ClCancel";
            case PDUType.Fack => 
                pTypeStr = "Fack";
                optional RpcDgFackBodyT fackBody = (this as DcRpcClFack).Body;
                if (fackBody != nothing)
                {
                    serialNum = Utility.DecToHexFormat((fackBody as RpcDgFackBodyT).SerialNum);
                }
            case PDUType.CancelAck => pTypeStr = "CancelAck";
        }
        return "DcRpcClPktHdrT, " + (this#Retransmission != nothing ? "Retransmission, " : "") + "dg: " + pTypeStr + ", Seq: " + Utility.DecToHexFormat(Seqnum) + ", Opnum: " + Utility.DecToHexFormat(Opnum) + ", Frag: " + Utility.DecToHexFormat(Fragnum) + ", Serial: " + serialNum + ", Act Id: " + UuidToText(ActId);
    }
}

string ServerBootToUTC(any input)
{
    if(!(input is uint))
    {
        return "";
    }
    uint data = input as uint;
    
    return CreateDateTime(1970, 1, 1).AddSeconds(data as double).ToString() + "  UTC";
}

bool IsLeapYear(ulong year)
{
    // multiple of 4 or multiple of 400 but not multiple of 100.
    return (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);
}

bool get IsBigEndian(this DcRpcClPktHdrT rpcclpkt)
{
    return rpcclpkt.Drep.IntegerRepresentation == IntergerFloatingPointByteOrder.BigEndian;
}

pattern RpcClPktHdrFlag1 = flags byte
{
    Reserved01  = 0x01, /* Reserved for use by implementations.*/
    Lastfrag    = 0x02, /*Meaningful in either direction. If set, the PDU is the last fragment of a multi-PDU transmission.*/
    Frag        = 0x04, /*Meaningful in either direction. If set, the PDU is a fragment of a multi-PDU transmission.*/
    Nofack      = 0x08, /* Meaningful for fragments sent in either direction. If set, the
                         *receiver is not requested to send a fack PDU for the fragment.
                         *Otherwise, if not set, the receiver acknowledges the received
                         *PDU with a fack PDU. Note that both client and server may
                         *send fack PDUs independent of the status of this flag.*/
    Maybe       = 0x10, /*Meaningful only from client to server. If set, the PDU is for a  maybe request.*/
    Idempotent  = 0x20, /*Meaningful only from client to server. If set, the PDU is for an idempotent request.*/
    Broadcast   = 0x40, /*Meaningful only from client to server. If set, the PDU is for a broadcast request.*/
    Reserved80  = 0x80, /* Reserved for use by implementations.*/
};

pattern RpcClPktHdrFlag2 = flags byte
{
    Reserved01      = 0x01,// Reserved for use by implementations.
    CancelPending   = 0x02,// Cancel pending at the call end.
    Reserved04      = 0x04,// Reserved for future use. Must be set to 0.
    Reserved08      = 0x08,// Reserved for future use. Must be set to 0.
    Reserved10      = 0x10,// Reserved for future use. Must be set to 0.
    Reserved20      = 0x20,// Reserved for future use. Must be set to 0.
    Reserved40      = 0x40,// Reserved for future use. Must be set to 0.
    Reserved80      = 0x80,// Reserved for future use. Must be set to 0.
};

// Security Providers
// The extensions could be found: http://msdn.microsoft.com/en-us/library/windows/desktop/aa373556(v=vs.85).aspx
pattern AuthnType = enum byte
{
    RpcCAuthnNone           = 0, // No Authentication
    RpcCAuthnDcePrivate     = 1, // DCE's private-key authentication is derived from Kerberos";
    RpcCAuthnDcePublic      = 2, // DCE public key authentication (reserved for future use).";
    RpcCAuthnDecPublic      = 4, // DEC public key authentication (reserved for future use).";
    RpcCAuthnGssNegotiate   = 9, // The Simple and Protected GSS-API Negotiation (SPNEGO) mechanism selects either NT LAN Manager (NTLM) or Kerberos authentication.";
    RpcCAuthnWinnt          = 10, //NTLM authentication will be used.";
    RpcCAuthnGssSchannel    = 14, // Transport Layer Security (TLS) or Secure Socket Layer (SSL) authentication for packet privacy will be used.";
    RpcCAuthnGssKerberos    = 16, // Kerberos authentication will be used.";
    RpcCAuthnDpa            = 17, // Distributed Password Authentication.  Not currently supported.";
    RpcCAuthnMsn            = 18, // Authentication protocol SSP used for the Microsoft Network (MSN). Not currently supported.";
    RpcCAuthnDigest         = 21, // Not currently supported.";
    RpcCAuthnNetlogon       = 68, // Netlogon authentication will be used.";
    RpcCAuthnMq             = 100, // This SSP provides an SSPI-compatible wrapper for the Microsoft Message Queue (MSMQ) transport-level protocol. Not currently supported.";
    RpcCAuthnDefault        = 255,
};

// Connectionless PDUs contain an authentication verifier if the PDU header field auth_proto is non-zero. Otherwise, the authentication verifier is not present.
type AuthTrailerClT 
{
    AuthnLevel ProtectionLevel;
    byte KeyVersNum;
    array<byte> Pad with BinaryEncoding{Length = (ProtectionLevel == AuthnLevel.RpcCAuthnLevelPktPrivacy ? 6 : 2)};
    ([|ProtectionLevel == AuthnLevel.RpcCAuthnLevelPkt|] PktAuthValue | array<byte>) AuthValue where ValidationCheck(value is array<byte> && (value as array<byte>).Count < 16, null, DiagnosisLevel.Error, "MSRPCE: The AuthValue in type AuthTrailerClT is not 16 bytes in length.");// with BinaryEncoding{Length = 16};
}

// Authentication Levels
// The extended protection level could be found: http://msdn.microsoft.com/en-us/library/windows/desktop/ms678435(v=vs.85).aspx
pattern AuthnLevel = enum byte
{
    RpcCAuthnLevelDefault       = 0, // MSRPC use this instead: RpcCAuthnLEVEL_DEFAULT
    RpcCAuthnLevelNone          = 1,
    RpcCAuthnLevelConnect       = 2,
    RpcCAuthnLevelCall          = 3,
    RpcCAuthnLevelPkt           = 4,
    RpcCAuthnLevelPktIntegrity  = 5,
    RpcCAuthnLevelPktPrivacy    = 6,
};

type Plaintext
{
    uint Seqnum;
    uint Fragnum;
}

type PktAuthValue
{
    Plaintext Checksum;
    array<byte> RestAuthValue where ValidationCheck(value.Count == 16, null, DiagnosisLevel.Error, "MSRPCE: The RestAuthValue in type PktAuthValue is not 8 bytes in length.");// with BinaryEncoding{Length = 8};
}

type ClDrepFormatLabel
{
    IntergerFloatingPointByteOrder IntegerRepresentation with BinaryEncoding{Width = 4};
    CharacterRepresentation CharacterRepresentation with BinaryEncoding{Width = 4};
    FloatingPointRepresentation FloatingPointRepresentation;
    byte Reserved;
}

pattern IntergerFloatingPointByteOrder = enum byte
{
    BigEndian = 0,
    LittleEndian = 1,
};

pattern CharacterRepresentation = enum byte
{
    Ascii   = 0,
    Ebcdic  = 1,
};

pattern FloatingPointRepresentation = enum byte
{
    Ieee    = 0,
    Vax     = 1,
    Cray    = 2,
    Ibm     = 3,
};

// An ack PDU contains no body data.
message DcRpcClAck : DcRpcClPktHdrT
{
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.Ack;
}

// A cancel_ack PDUs can optionally have a body.
message DcRpcClCancelAck : DcRpcClPktHdrT
{
    optional [|Len > 0|] RpcDgCancelAckBodyT Body;
    optional [|AuthProto != AuthnType.RpcCAuthnNone && Len % 8 != 0|] array<byte> Pad with BinaryEncoding{Length = ((8 - Len % 8) % 8) as uint};
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.CancelAck;
}

type RpcDgCancelAckBodyT
{
    uint Vers where value == 0; /* cancel-request body format version. This is independent of the protocol version number contained in the PDU header. This specification is for version 0. */
    uint CancelId;/* id of a cancel-request event being ack'd */
    bool ServerIsAccepting; /* server accepting cancels ? */
}

// A client sends a cancel PDU when it has incurred a cancel fault.
message DcRpcClCancel : DcRpcClPktHdrT
{
    RpcDgCancelBodyT Body;
    optional [|AuthProto != AuthnType.RpcCAuthnNone && Len % 8 != 0|] array<byte> Pad with BinaryEncoding{Length = ((8 - Len % 8) % 8) as uint};
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.ClCancel;
}

type RpcDgCancelBodyT
{
    uint Vers where value == 0; /* cancel body format version. This is independent of the protocol version number contained in the PDU header. This specification is for version 0. */
    uint CancelId;/* id of a cancel-request event */
}

// A fack PDU may contain a body with data
message DcRpcClFack : DcRpcClPktHdrT
{
    optional [|Len > 0|] RpcDgFackBodyT[Len] Body;
    optional [|AuthProto != AuthnType.RpcCAuthnNone && Len % 8 != 0|] array<byte> Pad with BinaryEncoding{Length = ((8 - Len % 8) % 8) as uint};
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.Fack;
}

type RpcDgFackBodyT[ushort Len]
{
    // Windows implementation always set Vers = 1. ref: http://msdn.microsoft.com/en-us/library/9039a59f-3075-4680-9517-19239bebf155(v=prot.13)#id48
    byte Vers; /* Fack packet body version */ 
    byte Pad1;
    ushort WindowSize;   /* Sender's receive window size (in pkts) */
    uint MaxTsdu;      /* largest local TPDU size */
    uint MaxFragSize; /* largest TPDU not fragmented */
    ushort SerialNum;    /* serial # of packet that induced this fack */
    ushort SelackLen;    /* number of elements in the selack array    */
    array<uint> Selack with BinaryEncoding{Length = SelackLen};     /* variable number of 32 bit selective ack bit masks. */
    optional [|(Len - 16 - 4 * SelackLen) > 0|] binary BodyPadding with BinaryEncoding{Length = (Len - 16 - 4 * SelackLen) as ushort};
}

// A server sends a fault PDU if an operation incurs a fault while executing on the server side.
message DcRpcClFault : DcRpcClPktHdrT
{
    RpcDgFaultBodyT Body;
    optional [|AuthProto != AuthnType.RpcCAuthnNone && Len % 8 != 0|] array<byte> Pad with BinaryEncoding{Length = ((8 - Len % 8) % 8) as uint};
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.Fault;
}

type RpcDgFaultBodyT
{
    RejectStatusCodes St where ErrorCodeIf(InRange<RejectStatusCodes>(value), null, "MSRPCE: The Status of the message is St(" + EnumToString(value as uint, "MSRPCE.RejectStatusCodes") + "). Please refer to St in Technical Document MS-RPCE."); /*status code */
}

// A server sends a nocall PDU in reply to a ping PDU. A nocall PDU can optionally carry a body whose format is the same as the optional fack PDU body.
message DcRpcClNocall: DcRpcClPktHdrT
{
    optional [|Len > 0|] RpcDgFackBodyT Body;
    optional [|AuthProto != AuthnType.RpcCAuthnNone && Len % 8 != 0|] array<byte> Pad with BinaryEncoding{Length = ((8 - Len % 8) % 8) as uint};
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.NoCall;
}

// A ping PDU contains no body data.
message DcRpcClPing: DcRpcClPktHdrT
{
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.Ping;
}

// The reject PDU body format is the same as that of the fault PDU. A server sends a reject PDU if an RPC request is rejected.
message DcRpcClReject: DcRpcClPktHdrT
{
    RpcDgFaultBodyT Body;
    optional [|AuthProto != AuthnType.RpcCAuthnNone && Len % 8 != 0|] array<byte> Pad with BinaryEncoding{Length = ((8 - Len % 8) % 8) as uint};
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.Reject;
}

// The body of a request PDU consists of an NDR representation of the input parameters for the request.
message DcRpcClRequest : DcRpcClPktHdrT
{
    binary Body with BinaryEncoding{Length = Len};
    optional [|AuthProto != AuthnType.RpcCAuthnNone && Len % 8 != 0|] array<byte> Pad with BinaryEncoding{Length = ((8 - Len % 8) % 8) as uint};
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.Request;
}

// The body of a response PDU consists of the NDR representation of the output parameters for the response.
message DcRpcClResponse : DcRpcClPktHdrT
{
    binary Body with BinaryEncoding{Length = Len};
    optional [|AuthProto != AuthnType.RpcCAuthnNone && Len % 8 != 0|] array<byte> Pad with BinaryEncoding{Length = ((8 - Len % 8) % 8) as uint};
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.Response;
}

// A server sends a working PDU in reply to a ping PDU. A working PDU contains no body data.
message DcRpcClWorking : DcRpcClPktHdrT
{
    optional [|AuthProto != AuthnType.RpcCAuthnNone|] AuthTrailerClT AuthVerifier;
    invariant PType == PDUType.Working;
}

// Identifier for Connectionless DCERPC, Pre-check and if successfully decode then parse the whole payload according to PDUType
type ClMessageIdentifier
{
    byte RpcVers where value == 4; // RPC protocol major version (4 LSB only)//
    byte PType where value <= 10; // Packet type (5 LSB only) //
    RpcClPktHdrFlag1 Flags1; // Packet flags //
    RpcClPktHdrFlag2 Flags2 where (value & 0x3F) == 0; // Packet flags //
    array<byte> Drep with BinaryEncoding{Length = 3};
    invariant (Drep[0] & 0xEE) == 0 && Drep[1] < 4 && Drep[2] == 0;
}

//____________________________________________________________________Connection-oriented_________________________________________________________________

pattern PContextIdT = ushort;

type PSyntaxIdT 
{
    guid IfUuid;
    uint IfVersion;
}

type PContElemT
{
    PContextIdT PContId;
    byte NTransferSyn; /* number of items */
    byte Reserved where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "MSRPCE: The Reserved in type PContElemT must be zero.");/* alignment pad, m.b.z. */
    PSyntaxIdT AbstractSyntax;
    array<PSyntaxIdT> TransferSyntaxes with BinaryEncoding{Length = NTransferSyn}; /* transfer syntax list */
}

type PContListT
{
    byte NContextElem; /* number of items */
    byte Reserved where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "MSRPCE: The Reserved in type PContListT must be zero."); /* alignment pad, m.b.z. */
    ushort Reserved2 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "MSRPCE: The Reserved2 in type PContListT must be zero."); /* alignment pad, m.b.z. */
    array<PContElemT> PContElem with BinaryEncoding{Length = NContextElem};
}

pattern PContDefResultT = enum short
{
    Acceptance,
    UserRejection,
    ProviderRejection,
    NegotiateAck // [MSRPCE] 2.2.2.4, These extensions specify a new member, negotiate_ack, which is added to the p_cont_def_result_t enumeration (specified in [C706] section 12.6), with the numeric value of 3.
};

pattern PProviderReasonT = enum short
{
    ReasonNotSpecified,
    AbstractSyntaxNotSupported,
    ProposedTransferSyntaxesNotSupported,
    LocalLimitExceeded
};

type PResultT
{
    PContDefResultT Result;
    PProviderReasonT Reason; /* only relevant if result != acceptance */
    PSyntaxIdT TransferSyntax where ValidationCheck(Result == PContDefResultT.Acceptance ||
    (value.IfUuid == {00000000-0000-0000-0000-000000000000} && value.IfVersion == 0),
    null, DiagnosisLevel.Error, "MSRPCE: The TransferSyntax in type PResultT should be zero if the Result in type PResultT is not Acceptance.");/* tr syntax selected 0 if result not accepted */
}

/* Same order and number of elements as in bind request */
type PResultListT
{
    byte NResults; /* count */
    byte Reserved where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "MSRPCE: The Reserved in type PResultListT must be zero."); /* alignment pad, m.b.z. */
    ushort Reserved2 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "MSRPCE: The Reserved2 in type PResultListT must be zero."); /* alignment pad, m.b.z. */
    array<PResultT> PResults with BinaryEncoding{Length = NResults};
}

type VersionT
{
    byte Major;
    byte Minor;
}

// The run-time version data type Is synonymous:
pattern PRtVersionT = VersionT ;

type PRtVersionsSupportedT
{
    byte NProtocols; /* count */
    array<PRtVersionT> PProtocols with BinaryEncoding{Length = NProtocols};
}

type PortAnyT
{
    ushort Length;// The length includes the C NULL string termination.
    string PortSpec with BinaryEncoding{Length = Length};
}

// Reasons for rejection of association return in the BindNak PDU
pattern PRejectReasonT = enum ushort
{
    ReasonNotSpecified              = 0,
    TemporaryCongestion             = 1,
    LocalLimitExceeded              = 2,
    CalledPaddrUnknown              = 3, /* not used */
    ProtocolVersionNotSupported     = 4,
    DefaultContextNotSupported      = 5, /* not used */
    UserDataNotReadable             = 6, /* not used */
    NoPsapAvailable                 = 7, /* not used */
    AuthenticationTypeNotRecognized = 8,
    InvalidChecksum                 = 9,
};

pattern RpcrtReasonCodeT = ushort; /* 0..65535 */

type RpcrtOptionalDataT
{
    byte RpcVers;
    byte RpcVersMinor;
    ushort Reserved1 where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "MSRPCE: The Reserved1 in type RpcrtOptionalDataT must be zero.") with BinaryEncoding{Length = 2};/* must be zero */
    array<byte> PackedDrep with BinaryEncoding{Length = 4};
    uint RejectStatus;
    array<byte> Reserved2 with BinaryEncoding{Length = 4};
}

// Future Reference: find the reference places.
type RpcconnRejectOptionalDataT
{
    RpcrtReasonCodeT ReasonCode; /* 0..65535 */
    RpcrtOptionalDataT RpcInfo; /* may be RPC specific */
}

// Future Reference: find the reference places.
type RpcconnDiscOptionalDataT
{
    RpcrtReasonCodeT ReasonCode; /* 0..65535 */
    RpcrtOptionalDataT RpcInfo; /* may be RPC-specific */
}

pattern AuthnSvc = enum byte
{
    RpcCAuthnNone = 0,
    RpcCAuthnDceSecret = 1,
    RpcCAuthnDefault = 2,
};

type AuthVerifierCoT[ushort AuthLength, byte AuthPadLengthValue]
{
    /* restore 4 byte Alignment */
    array<byte> AuthPad with BinaryEncoding{Length = AuthPadLengthValue}; /* align(4) */
    AuthnType AuthType; /* :01 which authent service */
    AuthnLevel AuthLevel; /* :01 which level within service */
    byte AuthPadLength; /* :01 */
    byte AuthReserved where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "MSRPCE: The AuthReserved in type AuthVerifierCoT must be zero."); /* :01 reserved, m.b.z. */
    uint AuthContextId; /* :04 */
    (TLS.ApplicationData | TLS.ChangeCipherSpec | TLS.HandshakeWorkaround | binary | any) AuthValue with BinaryEncoding{Length = AuthLength}; /* credentials */
    /* The auth_value field may contain a variety of security-related data. For the bind, bind_ack,
     *alter_context and alter_context_response PDUs, this field encodes credentials. For other PDUs,
     *this field holds checksums and other per-PDU security data that depend on the protection level. */
}

type SecTrailer
{
    AuthnType AuthType; // MUST contain an authentication type.
    AuthnLevel AuthLevel; // MUST contain one of the authentication levels as specified in section 2.2.1.1.8.
    byte AuthPadLength; // The number of padding octets, used to 4-byte align the sec_trailer structure,
    byte AuthReserved where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "MSRPCE: The AuthReserved in type SecTrailer should be zero on store, and should be ignored on read.");
    uint AuthContextId;
}

pattern RpcCoPfcFlags = flags byte
{
    PfcFirstFrag          = 0x01,/* First fragment */
    PfcLastFrag           = 0x02,/* Last fragment */
    $"PfcPendingCancel | PfcSupportHeaderSign"      = 0x04,/* Cancel was pending at sender */
    PfcReserved1          = 0x08,
    PfcConcMpx            = 0x10,/* supports concurrent multiplexing  of a single connection. */
    PfcDidNotExecute      = 0x20,/* only meaningful on ‘fault’ packet; if true, guaranteed call did not execute. */
    PfcMaybe              = 0x40,/* ‘maybe’ call semantics requested */
    PfcObjectUuid         = 0x80,/* if true, a non-nil object UUID
                                  * was specified in the handle, and
                                  * is present in the optional object
                                  * field. If false, the object field
                                  * is omitted. */
};

type CoDrepFormatLabel
{
    IntergerFloatingPointByteOrder IntegerRepresentation with BinaryEncoding{Width = 4};
    CharacterRepresentation CharacterRepresentation with BinaryEncoding{Width = 4};
    FloatingPointRepresentation FloatingPointRepresentation;
    byte Reserved;
    byte Reserved2;
}

// Identifier for Connection-Oriented DCERPC, Pre-check and if successfully decode then parse the whole payload according to PDUType
type CoMessageIdentifier
{
    byte RpcVers where value == 5;/* 00:01 RPC version */ 
    byte RpcVersMinor where (value == 0 || value == 1); /* 01:01 minor version */
    byte PTYPE where (value == 0 || value == 2 || value == 3 || (value >= 11 && value <= 19)); /* 02:01 packet type */
    RpcCoPfcFlags PfcFlags; /* 03:01 flags (see PFC_... ) */
    array<byte> PackedDrep with BinaryEncoding{Length = 4}; /* 04:04 NDR data rep format label*/
    ushort FragLength where value >= 16;
    invariant ((PackedDrep[0] & 0xEE) == 0) && (PackedDrep[1] < 4) && (PackedDrep[2] == 0) && (PackedDrep[3] == 0);
}

message RpcconnCommonHdrT
{
    /* start 8-octet aligned */
    /* common fields */
    byte RpcVers where value == 5;/* 00:01 RPC version */
    byte RpcVersMinor where value == 0 || value == 1; /* 01:01 minor version */
    PDUType PTYPE; /* 02:01 packet type */
    RpcCoPfcFlags PfcFlags; /* 03:01 flags (see PFC_... ) */
    CoDrepFormatLabel PackedDrep; /* 04:04 NDR data rep format label*/
    ushort FragLength; /* 08:02 total length of fragment */
    ushort AuthLength; /* 10:02 length of authValue */
    uint CallId; /* 12:04 call identifier */
    /* end common fields */
}

bool get IsBigEndian(this RpcconnCommonHdrT rpcconn)
{
    return rpcconn.PackedDrep.IntegerRepresentation == IntergerFloatingPointByteOrder.BigEndian;
}

message RpcconnRpcAuth3HdrT : RpcconnCommonHdrT
{
    binary Pad with BinaryEncoding{Length = 4};
    optional [|AuthLength != 0|] SecTrailer SecTrailer;
    optional [|AuthLength != 0|] (binary | any) AuthenticationTokens with BinaryEncoding{Length = AuthLength};
    
    invariant PTYPE == PDUType.Auth3;
    
    override string ToString()
    {
        return "RpcconnRpcAuth3HdrT, " + (this#PContextUuid == nothing ? "" : (GetRPCUuidString(this#PContextUuid as guid) + ", UUID: " + UuidToText(this#PContextUuid as guid))) + ", Call: " + Utility.DecToHexFormat(CallId);
    }
}

message RpcconnAlterContextHdrT : RpcconnCommonHdrT
{
    ushort MaxXmitFrag; /* ignored */
    ushort MaxRecvFrag; /* ignored */
    uint AssocGroupId; /* ignored */
    /* presentation context list */
    PContListT PContextElem; /* variable size */
    /* optional authentication verifier */
    /* following fields present iff authLength != 0 */
    optional ([|AuthLength != 0|] AuthVerifierCoT | binary) AuthVerifier with Encoding{Ignore = true};
    
    invariant PTYPE == PDUType.AlterContext;
    
    override string ToString()
    {
        return "RpcconnAlterContextHdrT, " + (this#PContextUuid == nothing ? "" : (GetRPCUuidString(this#PContextUuid as guid) + ", UUID: " + UuidToText(this#PContextUuid as guid))) + ", Call: " + Utility.DecToHexFormat(CallId);
    }
}

message RpcconnAlterContextResponseHdrT : RpcconnCommonHdrT
{
    ushort MaxXmitFrag; /* ignored */
    ushort MaxRecvFrag; /* ignored */
    uint AssocGroupId; /* ignored */
    PortAnyT SecAddr; /* ignored */
    /* restore 4-octet alignment */
    array<byte> Pad2 with BinaryEncoding{Length = ((4 -(SecAddr.Length + 26) % 4) % 4) as uint};
    /* presentation context result list, including hints */
    PResultListT PResultList; /* variable size */
    /* optional authentication verifier */
    /* following fields present iff authLength != 0 */
    optional ([|AuthLength != 0|] AuthVerifierCoT | binary) AuthVerifier with Encoding{Ignore = true}; /* xx:yy */
    
    invariant PTYPE == PDUType.AlterContextResp;
    
    override string ToString()
    {
        return "RpcconnAlterContextResponseHdrT, " + (this#PContextUuid == nothing ? "" : (GetRPCUuidString(this#PContextUuid as guid) + ", UUID: " + UuidToText(this#PContextUuid as guid))) + ", Call: " + Utility.DecToHexFormat(CallId) + ", AssocGrp: " + Utility.DecToHexFormat(AssocGroupId) + ", Xmit: " + Utility.DecToHexFormat(MaxXmitFrag) + ", Recv: " + Utility.DecToHexFormat(MaxRecvFrag);
    }
}

message RpcconnBindHdrT : RpcconnCommonHdrT
{    
    ushort MaxXmitFrag; /* 16:02 max transmit frag size, bytes */
    ushort MaxRecvFrag; /* 18:02 max receive frag size, bytes */
    uint AssocGroupId; /* 20:04 incarnation of client-server
    * assoc group */
    /* presentation context list */
    PContListT PContextElem; /* variable size */
    /* optional authentication verifier */
    /* following fields present iff authLength != 0 */
    optional ([|AuthLength != 0|] AuthVerifierCoT | binary) AuthVerifier with Encoding{Ignore = true};
    invariant PTYPE == PDUType.Bind;
    
    override string ToString()
    {
        return "RpcconnBindHdrT, " + (this#PContextUuid == nothing ? "" : (GetRPCUuidString(this#PContextUuid as guid) + ", UUID: " + UuidToText(this#PContextUuid as guid))) + ", Call: " + Utility.DecToHexFormat(CallId) + ", AssocGrp: " + Utility.DecToHexFormat(AssocGroupId) + ", Xmit: " + Utility.DecToHexFormat(MaxXmitFrag) + ", Recv: " + Utility.DecToHexFormat(MaxRecvFrag);
    }
}

message RpcconnBindAckHdrT : RpcconnCommonHdrT
{
    ushort MaxXmitFrag; /* 16:02 max transmit frag size */
    ushort MaxRecvFrag; /* 18:02 max receive frag size */
    uint AssocGroupId; /* 20:04 returned assocGroupId */
    PortAnyT SecAddr; /* 24:yy optional secondary address
    * for process incarnation; local port
    * part of address only */
    /* restore 4-octet alignment */
    array<byte> Pad2 with BinaryEncoding{Length = ((4 -(SecAddr.Length + 26) % 4) % 4) as uint};
    /* presentation context result list, including hints */
    PResultListT PResultList; /* variable size */
    /* optional authentication verifier */
    /* following fields present iff authLength != 0 */
    optional ([|AuthLength != 0|] AuthVerifierCoT | binary) AuthVerifier with Encoding{Ignore = true}; /* xx:yy */
    
    invariant PTYPE == PDUType.BindAck;
    
    override string ToString()
    {
        return "RpcconnBindAckHdrT, " + (this#PContextUuid == nothing ? "" : (GetRPCUuidString(this#PContextUuid as guid) + ", UUID: " + UuidToText(this#PContextUuid as guid))) + ", Call: " + Utility.DecToHexFormat(CallId) + ", AssocGrp: " + Utility.DecToHexFormat(AssocGroupId) + ", Xmit: " + Utility.DecToHexFormat(MaxXmitFrag) + ", Recv: " + Utility.DecToHexFormat(MaxRecvFrag);
    }
}

message RpcconnBindNakHdrT : RpcconnCommonHdrT
{
    PRejectReasonT ProviderRejectReason; /* 16:02 presentation
    context reject */
    PRtVersionsSupportedT Versions; /* 18:yy array of protocol
    * versions supported */
    
    invariant PTYPE == PDUType.BindNak;
    
    override string ToString()
    {
        return "RpcconnBindNakHdrT" + ", Call: " + Utility.DecToHexFormat(CallId);
    }
}

message RpcconnCancelHdrT : RpcconnCommonHdrT
{
    /* optional authentication verifier
    * following fields present iff authLength != 0 */
    optional [|AuthLength != 0|] AuthVerifierCoT AuthVerifier with Encoding{Ignore = true}; /* xx:yy */
    
    invariant PTYPE == PDUType.CoCancel;
    
    override string ToString()
    {
        return "RpcconnCancelHdrT" + ", Call: " + Utility.DecToHexFormat(CallId);
    }
}

message RpcconnFaultHdrT : RpcconnCommonHdrT
{
    /* needed for request, response, fault */
    uint AllocHint; /* 16:04 allocation hint */
    PContextIdT PContId; /* 20:02 pres context, i.e. data rep */
    /* needed for response or fault */
    byte CancelCount; /* 22:01 received cancel count */
    byte Reserved; /* 23:01 reserved, m.b.z. */ // These extensions specify the least significant bit of the reserved field to be a flag indicating the presence of RPC extended error information.
    // So removed these ValidationCheck:  where ValidationCheck(value == 0, this, "RpcconnFaultHdrT.Reserved, reserved, must be zero.")
    /* fault code */
    RejectStatusCodes Status where ErrorCodeIf(InRange<RejectStatusCodes>(value), this, "MSRPCE: The Status in message RpcconnFaultHdrT is " + EnumToString(value as uint, "MSRPCE.RejectStatusCodes") + ".")
        && ValidationCheck(!(value is RpcconnFaultHdrT_Status), this, "MSRPCE: The Status in message RpcconnFaultHdrT must not send status code " + EnumToString(value as uint, "MSRPCE.RpcconnFaultHdrT_Status") + " to the client. The status codes have special significance, and it presence in the status field may be flagged as a protocol error by the client."); /* 24:04 run-time fault code or zero */
    /* always pad to next 8-octet boundary */
    // Reserved2 is optional, because 'If a non-zero value is present, no stub data is allowed.'
    optional binary Reserved2 with BinaryEncoding{Length = 4}; /* 28:04 reserved padding, m.b.z. */
    /* stub data here, 8-octet aligned... */
    optional [|Status > 0|] binary StubData with Encoding{Ignore = true}; // If a non-zero value is present, no stub data is allowed.
    /* optional authentication verifier */
    /* following fields present iff authLength != 0 */
    optional [|AuthLength != 0|] AuthVerifierCoT AuthVerifier with Encoding{Ignore = true}; /* xx:yy */
    
    invariant PTYPE == PDUType.Fault;
    
    override string ToString()
    {
        string statusToText;
        if(InRange<RejectStatusCodes>(Status))
            statusToText = EnumToString(Status as uint, "MSRPCE.RejectStatusCodes");
        else if(Status is RpcconnFaultHdrT_Status)
            statusToText = EnumToString(Status as uint, "MSRPCE.RpcconnFaultHdrT_Status");
        else
            statusToText = DecToHexFormat(Status);
        return "RpcconnFaultHdrT" + ", Call: " + Utility.DecToHexFormat(CallId) + ", Context: " + Utility.DecToHexFormat(PContId) + ", Status: " + statusToText + ", Cancels: " + Utility.DecToHexFormat(CancelCount);
    }
}

message RpcconnOrphanedHdrT : RpcconnCommonHdrT
{
    /* optional authentication verifier
    * following fields present iff authLength != 0 */
    optional [|AuthLength != 0|] AuthVerifierCoT AuthVerifier with Encoding{Ignore = true}; /* xx:yy */
    
    invariant PTYPE == PDUType.Orphaned;
    
    override string ToString()
    {
        return "RpcconnOrphanedHdrT" + ", Call: " + Utility.DecToHexFormat(CallId);
    }
}

message RpcconnRequestHdrT : RpcconnCommonHdrT
{   
    // needed on request, response, fault //
    uint AllocHint; // 16:04 allocation hint //
    PContextIdT PContId; // 20:02 pres context, i.e. data rep //
    ushort Opnum; // 22:02 operation # within the interface //
    // optional field for request, only present if the PfcObjectUuid field is non-zero //
    optional [|(PfcFlags & RpcCoPfcFlags.PfcObjectUuid) == RpcCoPfcFlags.PfcObjectUuid|] guid Object; // 24:16 object UID 
    // stub data, 8-octet aligned //
    binary StubData with Encoding{Ignore = true};
    // optional authentication verifier //
    // following fields present iff authLength != 0 //
    optional [|AuthLength != 0|] AuthVerifierCoT AuthVerifier with Encoding{Ignore = true}; // xx:yy //
    
    invariant PTYPE == PDUType.Request;
    
    override string ToString()
    {
        return "RpcconnRequestHdrT, " + (this#PContextUuid == nothing ? "" : GetRPCUuidString(this#PContextUuid as guid) + " " + UuidToText(this#PContextUuid as guid)) + ", Call: " + Utility.DecToHexFormat(CallId) + ", Opnum: " + Utility.DecToHexFormat(Opnum) + ", Context: " + Utility.DecToHexFormat(PContId) + ", Hint: " + Utility.DecToHexFormat(AllocHint);
    }
}

bool get IsEncrypted(this RpcconnRequestHdrT request)
{
    return request.AuthLength > 0 && (request.AuthVerifier as AuthVerifierCoT).AuthLevel >= 6; // greater than AuthnLevel.RpcCAuthnLevelPktPrivacy
}

message RpcconnResponseHdrT : RpcconnCommonHdrT
{
    /* needed for request, response, fault */
    uint AllocHint; /* 16:04 allocation hint */
    PContextIdT PContId; /* 20:02 pres context, i.e.* data rep */
    /* needed for response or fault */
    byte CancelCount; /* 22:01 cancel count */
    byte Reserved; /* 23:01 reserved, m.b.z. */
    /* stub data here, 8-octet aligned */
    binary StubData with Encoding{Ignore = true};
    /* optional authentication verifier */
    /* following fields present iff authLength != 0 */
    optional [|AuthLength != 0|] AuthVerifierCoT AuthVerifier with Encoding{Ignore = true}; /* xx:yy */
    
    invariant PTYPE == PDUType.Response;
    
    override string ToString()
    {
        return "RpcconnResponseHdrT, " + (this#PContextUuid == nothing ? "" : GetRPCUuidString(this#PContextUuid as guid) + " " + UuidToText(this#PContextUuid as guid)) + ", Call: " + Utility.DecToHexFormat(CallId) + ", Context: " + Utility.DecToHexFormat(PContId) + ", Hint: " + Utility.DecToHexFormat(AllocHint)  + ", Cancels: " + Utility.DecToHexFormat(CancelCount);
    }
}

bool get IsEncrypted(this RpcconnResponseHdrT response)
{
    return response.AuthLength > 0 && (response.AuthVerifier as AuthVerifierCoT).AuthLevel >= 6; // greater than AuthnLevel.RpcCAuthnLevelPktPrivacy
}

message RpcconnShutdownHdrT : RpcconnCommonHdrT
{
    invariant PTYPE == PDUType.Shutdown;
    
    override string ToString()
    {
        return "RpcconnShutdownHdrT" + ", Call: " + Utility.DecToHexFormat(CallId);
    }
}

type PresentationContext
{
    guid AbstractSyntax; // guid, equal with guid used throughout MSRPCE which is referenced from DTYP
    uint AbstractSyntaxVersion;
    guid TransferSyntax; // guid, equal with guid used throughout MSRPCE which is referenced from DTYP
    uint TransferSyntaxVersion;
}

//_______________________________________________________________________Endpoint & Actors_____________________________________________________________________

//_______________________________________________________________________Connection-oriented Functions_____________________________________________________________________

// for nested rpc case2 (server callback client as issues request and accepts response), the conversation is just converted without any other Bind/BindAck,
// for nested rpc case1 (server call another server and then give response the the original caller), it will be covered in another RPC call endpoint as normal client -> server with Bind/BindAck/Request/Response.
endpoint Server over UDP.Host | over VirtualTransport.Server | over ServerOverNamedpipe | over ClRpcServerReassembly | over CoRpcServerReassembly
// Connection-oriented
accepts RpcconnBindHdrT issues RpcconnBindAckHdrT issues RpcconnBindNakHdrT
accepts RpcconnAlterContextHdrT accepts RpcconnRpcAuth3HdrT issues RpcconnAlterContextResponseHdrT
accepts RpcconnRequestHdrT issues RpcconnResponseHdrT
issues RpcconnRequestHdrT accepts RpcconnResponseHdrT //Nested RPC
accepts RpcconnCancelHdrT
issues RpcconnFaultHdrT
accepts RpcconnOrphanedHdrT
issues RpcconnShutdownHdrT
// Connectionless
accepts DcRpcClRequest issues DcRpcClResponse
accepts DcRpcClAck
accepts DcRpcClCancel issues DcRpcClCancelAck
accepts DcRpcClFack issues DcRpcClFack
issues DcRpcClFault
accepts DcRpcClPing issues DcRpcClNocall issues DcRpcClWorking
issues DcRpcClReject
{
    // A table of PresentationContext that have been negotiated for this connection.
    // indexed by the presentation context ID which is same as the value
    // of the p_cont_id field in the request PDU header, as specified in [C706] section 12.6.4.9
    map<ushort, PresentationContext> NegotiatedPresentationContexts = {};
    // this Nonegotiated cache used for only Bind/AlterContext request exist in traffic but without BindAck/AlterContextResp.
    // we can benefit from this that following RPC Request/Response could be parsed successfully as possible as we can.
    map<ushort, PresentationContext> NonegotiatedPresentationContexts = {};
    // A caching table of Ndr64 encoding indexed by the presentation context ID
    map<ushort, bool> Ndr64Map = {};
    // CallId -> Opnum for Response#RpcOpnum
    map<uint, ushort> OpnumMap = {};
    // Cached Bind/AlterContext, waiting Ack/Response, then complete the NegotiatedPresentationContexts
    RpcconnBindHdrT CachedBindMsg;
    RpcconnAlterContextHdrT CachedAlterContextMsg;
    
    // Function that check whether a context id is NDR64 encoded
    bool IsNdr64(ushort contextId)
    {
        if (contextId in Ndr64Map)
        {
            return Ndr64Map[contextId];
        }
        var isNdr64 = false;
        if (contextId in NegotiatedPresentationContexts)
        {
            var context = NegotiatedPresentationContexts[contextId];
            if (context != null)
            {
                isNdr64 = context.TransferSyntax == NDR64TransferSyntaxIdentifier
                && context.TransferSyntaxVersion == NDR64TransferSyntaxVersion;
            }
        }
        if (!isNdr64)
        {
            if (contextId in NonegotiatedPresentationContexts)
            {
                var context = NonegotiatedPresentationContexts[contextId];
                if (context == null)
                {
                    Ndr64Map[contextId] = false;
                    return false;
                }
                var isNdr64InStandalone = context.TransferSyntax == NDR64TransferSyntaxIdentifier
                && context.TransferSyntaxVersion == NDR64TransferSyntaxVersion;
                Ndr64Map[contextId] = isNdr64InStandalone;
                return isNdr64InStandalone;
            }
            Ndr64Map[contextId] = false;
            return false;
        }
        Ndr64Map[contextId] = true;
        return true;
    }
        
    // Function that check whether the given context id, uuid and version matches 
    // one of the negotiated presentation contexts or one of standalone presentation contexts.
    bool MatchInterface(ushort contextId, guid uuid, uint version)
    {
        bool negotiatedInterfaceMatch = false;
        if (contextId in NegotiatedPresentationContexts)
        {
            var context = NegotiatedPresentationContexts[contextId];
            if (context != null)
            {
                negotiatedInterfaceMatch = uuid == context.AbstractSyntax && MatchVersion(context.AbstractSyntaxVersion, version);
            }
        }
        if (!negotiatedInterfaceMatch)
        {
            if (contextId in NonegotiatedPresentationContexts)
            {
                var context = NonegotiatedPresentationContexts[contextId];
                if (context == null)
                {
                    return false;
                }
                var nonegotiatedInterfaceMatch = uuid == context.AbstractSyntax && MatchVersion(context.AbstractSyntaxVersion, version);
                if (nonegotiatedInterfaceMatch) 
                { 
                    ReportInsufficientData(null, DiagnosisLevel.Warning, 
                    "MSRPCE: Incomplete MSRPCE binding, missing context acceptance for this PContId: " + (contextId as string) + ", Abstract Syntax: " + (uuid as string) + ", and Version: " + (version as string) + ".");
                    return true; 
                }
                else 
                { 
                    var onlyMatchObjectUuidInRequest = (uuid == context.AbstractSyntax) 
                            && context.AbstractSyntaxVersion == 0 
                            && context.TransferSyntax is {00000000-0000-0000-0000-000000000000} 
                            && context.TransferSyntaxVersion == 0; 
                    if (onlyMatchObjectUuidInRequest) 
                    { 
                        ReportInsufficientData(null, DiagnosisLevel.Warning, 
                        "MSRPCE: Incomplete MSRPCE binding, missing context acceptance and only match the Object Uuid in Request for this PContId: " + (contextId as string) + ", Abstract Syntax: " + (uuid as string) + ", and Version: " + (version as string) + ".");
                        return true; 
                    } 
                }
            }
            return false;
        }
        return true;
    }
    
    bool MatchVersion(uint decodedVersion, uint docVersion)
    {
        if (decodedVersion == docVersion)
        {
            return true;
        }
        // Compare major version, should be the same
        if ((decodedVersion & 0xFFFF) != (docVersion & 0xFFFF))
        {
            return false;
        }
        // Compare minor Version, docVersion.minor >= decodedVersion.minor is acceptable
        // Since major versions are the same, compare the combined version here
        return decodedVersion < docVersion;
    }

    observe this accepts bind:RpcconnBindHdrT
    {
        CachedBindMsg = bind;
        ObserveNegotiateRequest(bind.PContextElem, bind);
    }
    
    observe this issues bindAck:RpcconnBindAckHdrT
    {
        if (CachedBindMsg != null)
        {
            ObserveNegotiateResponse(bindAck.PResultList, CachedBindMsg.PContextElem, CachedBindMsg, bindAck);
        }
    }
    
    observe this accepts alterContext:RpcconnAlterContextHdrT
    {
        CachedAlterContextMsg = alterContext;
        ObserveNegotiateRequest(alterContext.PContextElem, alterContext);
    }
    
    observe this issues alterContextResp:RpcconnAlterContextResponseHdrT
    {
        if (CachedAlterContextMsg != null)
        {
            ObserveNegotiateResponse(alterContextResp.PResultList, CachedAlterContextMsg.PContextElem, CachedAlterContextMsg, alterContextResp);
        }
    }
    
    void ObserveNegotiateRequest(PContListT pContList, RpcconnCommonHdrT requestMsg)
    {
        bool allConsistentSyntax = true;
        guid? annotationContextUuid = null;
        foreach (PContElemT contElem in pContList.PContElem)
        {
            NonegotiatedPresentationContexts[contElem.PContId] = new PresentationContext
            {
                AbstractSyntax = contElem.AbstractSyntax.IfUuid,
                AbstractSyntaxVersion = contElem.AbstractSyntax.IfVersion,
            };
            // so far, the first TransferSyntax in array is always the right one.
            if (contElem.TransferSyntaxes.Count > 0)
            {
                NonegotiatedPresentationContexts[contElem.PContId].TransferSyntax = contElem.TransferSyntaxes[0].IfUuid;
                NonegotiatedPresentationContexts[contElem.PContId].TransferSyntaxVersion = contElem.TransferSyntaxes[0].IfVersion;
            }
            if (annotationContextUuid == null)
            {
                annotationContextUuid = contElem.AbstractSyntax.IfUuid;
            }
            else if (annotationContextUuid != contElem.AbstractSyntax.IfUuid)
            {
                allConsistentSyntax = false;
            }
        }
        if (allConsistentSyntax && annotationContextUuid != null)
        {
            requestMsg#PContextUuid = annotationContextUuid;
        }
    }
    
    // Function that is used for adding PresentationContext to NegotiatedPresentationContexts
    void ObserveNegotiateResponse(PResultListT pResultList, PContListT pContList, RpcconnCommonHdrT cachedRequestMsg, RpcconnCommonHdrT currentResponseMsg)
    {
        int index = 0; // We assume the AckResult using the same PResults index coincide with PContElem in CachedBindMsg.
        guid? acceptedUuid = null;
        for (; index < pResultList.NResults; index++)
        {
            PResultT result = pResultList.PResults[index];
            if (result.Result == PContDefResultT.Acceptance)
            {
                acceptedUuid = result.TransferSyntax.IfUuid;
            }
        }
        if (acceptedUuid != null)
        {
            foreach (PContElemT contElem in pContList.PContElem)
            {
                foreach (PSyntaxIdT syntaxId in contElem.TransferSyntaxes)
                {
                    if (acceptedUuid == syntaxId.IfUuid)
                    {
                        NegotiatedPresentationContexts[contElem.PContId] = new PresentationContext
                        {
                            AbstractSyntax = contElem.AbstractSyntax.IfUuid,
                            AbstractSyntaxVersion = contElem.AbstractSyntax.IfVersion,
                            TransferSyntax = acceptedUuid as guid,
                            TransferSyntaxVersion = syntaxId.IfVersion,
                        };
                        cachedRequestMsg#PContextUuid = contElem.AbstractSyntax.IfUuid;
                        currentResponseMsg#PContextUuid = contElem.AbstractSyntax.IfUuid;
                        break;
                    }
                }
            }
        }
    }
    
    observe this accepts request:RpcconnRequestHdrT
    {
        OpnumMap[request.CallId] = request.Opnum;
        if (request.PContId in NegotiatedPresentationContexts)
        {
            request#PContextUuid = NegotiatedPresentationContexts[request.PContId].AbstractSyntax;
        }
        else if (request.PContId in NonegotiatedPresentationContexts)
        {
            var onlyMatchObjectUuidInRequest = NonegotiatedPresentationContexts[request.PContId].AbstractSyntaxVersion == 0 
                            && NonegotiatedPresentationContexts[request.PContId].TransferSyntax is {00000000-0000-0000-0000-000000000000} 
                            && NonegotiatedPresentationContexts[request.PContId].TransferSyntaxVersion == 0; 
            if (!onlyMatchObjectUuidInRequest)
            {
                request#PContextUuid = NonegotiatedPresentationContexts[request.PContId].AbstractSyntax;
            }
        }
        else if (request.Object != nothing)
        {
            if (!(request.PContId in NonegotiatedPresentationContexts))
            {
                NonegotiatedPresentationContexts[request.PContId] = new PresentationContext
                        {
                            AbstractSyntax = request.Object as guid,
                            // leave other fields AbstractSyntaxVersion, TransferSyntax, TransferSyntaxVersion as default value, because we can't get it.
                        };
            }
        }
    }
    
    observe this issues response:RpcconnResponseHdrT
    {
        if (response.CallId in OpnumMap)
        {
            response#RpcOpnum = OpnumMap[response.CallId];
        }
        if (response.PContId in NegotiatedPresentationContexts)
        {
            response#PContextUuid = NegotiatedPresentationContexts[response.PContId].AbstractSyntax;
        }
        else if (response.PContId in NonegotiatedPresentationContexts)
        {
            var onlyMatchObjectUuidInRequest = NonegotiatedPresentationContexts[response.PContId].AbstractSyntaxVersion == 0 
                            && NonegotiatedPresentationContexts[response.PContId].TransferSyntax is {00000000-0000-0000-0000-000000000000} 
                            && NonegotiatedPresentationContexts[response.PContId].TransferSyntaxVersion == 0; 
            if (!onlyMatchObjectUuidInRequest)
            {
                response#PContextUuid = NonegotiatedPresentationContexts[response.PContId].AbstractSyntax;
            }
        }
    }
}

client endpoint Client connected to Server;

void CoReassemblyAcceptsDispatcher((CoRpcServerReassembly | ServerOverNamedpipe) reassemblyServer, RpcconnCommonHdrT rpcconnCommonHdrT)
{
    if (reassemblyServer is ServerOverNamedpipe)
    {
        dispatch (reassemblyServer as ServerOverNamedpipe) accepts rpcconnCommonHdrT;
    }
    else
    {
        dispatch (reassemblyServer as CoRpcServerReassembly) accepts rpcconnCommonHdrT;
    }
}

void CoReassemblyIssuesDispatcher((CoRpcServerReassembly | ServerOverNamedpipe) reassemblyServer, RpcconnCommonHdrT rpcconnCommonHdrT)
{
    if (reassemblyServer is ServerOverNamedpipe)
    {
        dispatch (reassemblyServer as ServerOverNamedpipe) issues rpcconnCommonHdrT;
    }
    else
    {
        dispatch (reassemblyServer as CoRpcServerReassembly) issues rpcconnCommonHdrT;
    }
}

// Identifies that whether it's MSPRCE protocol data or not
bool IsRpcconnCommonHdrT(binary data)
{
    // 16 is RpcconnCommonHdrT content length and larger than CoMessageIdentifier's content length
    return data.Count >= 16 && BinaryDecoder<CoMessageIdentifier>(data.Segment(0, 10)) != nothing;
}

// Convert when server.isMissingThreeWayHandshake is true? But this will mix the Nested Request/Response for MissingThreeWayHandshake scenario, but this mixture could be rarely seen.
bool NeedConvertDirectionForAcceptsCoRpc(VirtualTransport.Server server, PDUType pduType)
{
    return server.isMissingThreeWayHandshake 
    && (pduType == PDUType.Response || pduType == PDUType.Fault || pduType == PDUType.BindAck
    || pduType == PDUType.BindNak || pduType == PDUType.AlterContextResp || pduType == PDUType.Shutdown);
}

// Convert when server.isMissingThreeWayHandshake is true? But this will mix the Nested Request/Response for MissingThreeWayHandshake scenario, but this mixture could be rarely seen.
bool NeedConvertDirectionForIssuesCoRpc(VirtualTransport.Server server, PDUType pduType)
{
    return server.isMissingThreeWayHandshake 
    && (pduType == PDUType.Request || pduType == PDUType.Bind || pduType == PDUType.AlterContext
    || pduType == PDUType.Auth3 || pduType == PDUType.CoCancel || pduType == PDUType.Orphaned);
}

void DispatchOriginsToRevive(ref array<any message> msgOrigins)
{
    foreach (var msg in msgOrigins)
    {
        DisplayTopLevelMessage(msg);
    }
    msgOrigins = [];
}

autostart actor MsrpceOverTcpServer(VirtualTransport.Server server)
{
    binary incompleteRPCSourceData = $[];
    uint expectedIncompleteSequenceNum = 0;
    array<any message> msgOrigins = [];
    int dispatchedLengthInLastSegment = 0;
    
    // 16 is RpcconnCommonHdrT content length and larger than CoMessageIdentifier's content length;
    process server accepts s:VirtualTransport.VirtualDataSegment
        where s.Payload.Count >= 16 && (s.SourcePort == Port.DCERPC || s.DestinationPort == Port.DCERPC || s.SequenceNumber == expectedIncompleteSequenceNum || IsRpcconnCommonHdrT(s.Payload))
    {
        var reassblyServer = endpoint CoRpcServerReassembly over server;
        var reassemblyDispatcher = NeedConvertDirectionForAcceptsCoRpc(server, s.Payload[2]) ? CoReassemblyIssuesDispatcher : CoReassemblyAcceptsDispatcher;
        MsrpceProcessTcpMessages(reassblyServer, s.Payload, ref incompleteRPCSourceData, ref expectedIncompleteSequenceNum, ref dispatchedLengthInLastSegment, ref msgOrigins, s, reassemblyDispatcher);
    }

    // 16 is RpcconnCommonHdrT content length and larger than CoMessageIdentifier's content length;
    process server issues s:VirtualTransport.VirtualDataSegment
        where s.Payload.Count >= 16 && (s.SourcePort == Port.DCERPC || s.DestinationPort == Port.DCERPC || s.SequenceNumber == expectedIncompleteSequenceNum || IsRpcconnCommonHdrT(s.Payload))
    {
        var reassblyServer = endpoint CoRpcServerReassembly over server;
        var reassemblyDispatcher = NeedConvertDirectionForIssuesCoRpc(server, s.Payload[2]) ? CoReassemblyAcceptsDispatcher : CoReassemblyIssuesDispatcher;
        MsrpceProcessTcpMessages(reassblyServer, s.Payload, ref incompleteRPCSourceData, ref expectedIncompleteSequenceNum, ref dispatchedLengthInLastSegment, ref msgOrigins, s, reassemblyDispatcher);
    }
    
    ~endpoint(VirtualTransport.Server server)
    {
        DispatchOriginsToRevive(ref msgOrigins);
    }
}

// Proces normal case: one TCP VirtualDataSegment contains one rpc message
// and incomplete RPC source data which are possibly distributed in multi TCP segment,
// the complext case is:TCP VirtualDataSegment T1,T2,T3, and RPC msg R1,R2,R3, 
// R1 embedded in T1 payload, and R2 partially embedded in the rest of T1 payload and T2's begginning payload. R3 embedded in the rest of T3 payload
void MsrpceProcessTcpMessages(CoRpcServerReassembly reasseblyServer, binary payloadData, ref binary incompleteRPCSourceData, ref uint expectedIncompleteSequenceNum, ref int dispatchedLengthInLastSegment, ref array<any message> origins, VirtualTransport.VirtualDataSegment msg, void((VirtualTransport.Server | ServerOverNamedpipe), RpcconnCommonHdrT) reassemblyDispatcher)
{
    // case: incomplete RPC source data distributed in multi TCP Segment.
    if (incompleteRPCSourceData.Count > 0)
    {
        incompleteRPCSourceData += payloadData;
        origins += [msg];
        int completeFragmentLength = BinaryDecoder<ushort>(incompleteRPCSourceData.Segment(8, 2)) as ushort;
        if (completeFragmentLength <= incompleteRPCSourceData.Count)
        {
            expectedIncompleteSequenceNum = 0;
            payloadData = incompleteRPCSourceData;
            incompleteRPCSourceData = $[];
        }
        else
        {
            expectedIncompleteSequenceNum = msg.NextSequenceNumber;
            return; // return and wait for the next imcomplete frame arriving.
        }
    }
    
    // case: the first frame of a new RPC messages with the payloadData, but the payloadData maybe have been reassembled previously.
    int fragmentLength = BinaryDecoder<ushort>(payloadData.Segment(8, 2)) as ushort;
    while (fragmentLength <= payloadData.Count)
    {
        // case: RPC source data embedded totally in the payloadData.
        if (!((msg as any message) in origins))
        {
            origins += [msg];
        }
        ProcessConnectionOrientedRpc(reasseblyServer, payloadData, fragmentLength, origins, reassemblyDispatcher);
        if (fragmentLength == payloadData.Count)
        {
            origins = [];
            dispatchedLengthInLastSegment = 0;
            return;
        }
        else
        {
            int lengthFromLastDispatch = dispatchedLengthInLastSegment + fragmentLength;
            int tempLength = 0;
            int index = 0;
            for (; index < origins.Count; index++)
            {
                VirtualTransport.VirtualDataSegment segment = origins[index] as VirtualTransport.VirtualDataSegment;
                tempLength += segment.Payload.Count;
                if (tempLength > lengthFromLastDispatch)
                {
                    origins = origins.Segment(index);
                    int undispatchedLengthInLastSegment = tempLength - lengthFromLastDispatch;
                    dispatchedLengthInLastSegment = (origins[0] as VirtualTransport.VirtualDataSegment).Payload.Count - undispatchedLengthInLastSegment;
                    break;
                }
            }
        }
        // payloadData contains more than one RPC messages.
        payloadData = payloadData.Segment(fragmentLength);
        if (IsRpcconnCommonHdrT(payloadData))
        {
            fragmentLength = BinaryDecoder<ushort>(payloadData.Segment(8, 2)) as ushort;
        }
        else
        {
            ValidationCheck(false, msg, DiagnosisLevel.Warning, "MSRPCE: The TCP payload may contain multiple RPC messages, but the trailing data is invalid RPC message format.");
            // set IncompleteCache to empty, then all the following incomplet TCP messages should not be processed by MSRPCE, 
            // and possibly all completed normal messages could be parsed successfully with correct origins.
            incompleteRPCSourceData = $[];
            dispatchedLengthInLastSegment = 0;
            DispatchOriginsToRevive(ref origins);
            return;
        }
    }
    // case: incomplete RPC source data distributed in multi TCP Segment.
    if (fragmentLength > payloadData.Count)
    {
        if (msg is VirtualTransport.VirtualDataSegment && (msg as VirtualDataSegment)#IsIncomplete != nothing && (msg as VirtualDataSegment)#IsIncomplete as bool)
        {
            DispatchOriginsToRevive(ref origins);
            DisplayTopLevelMessage(msg);
            incompleteRPCSourceData = $[]; // set IncompleteCache to empty, then all the following incomplet TCP messages should not be processed by MSRPCE
            expectedIncompleteSequenceNum = 0;
            throw "MSRPCE: Messages over TCP cannot be decoded successfully due to incomplete TCP segments.";
        }
        else
        {
            incompleteRPCSourceData += payloadData;
            if (!((msg as any message) in origins))
            {
                origins += [msg];
            }
            expectedIncompleteSequenceNum = msg.NextSequenceNumber;
        }
    }
}

// Proces normal case: one SMB/SMB2 frame contains one rpc message
// and incomplete RPC source data which are possibly distributed in multi SMB/SMB2 frames,
// SMB messages with the same direction but differnct message types, they can be combined or reassembled as one RPC message.
// and support the same partial embedded case like TCP.
void MsrpceProcessSmbMessages(ServerOverNamedpipe reassebmlyServer, binary payloadData, ref binary incompleteRPCSourceData, optional NTSTATUS status, ref array<any message> origins, any message msg, void((CoRpcServerReassembly | ServerOverNamedpipe), RpcconnCommonHdrT) reassemblyDispatcher)
{
    // case: incomplete RPC source data distributed in multi SMB/SMB2 Segment.
    if (incompleteRPCSourceData.Count > 0)
    {
        incompleteRPCSourceData += payloadData;
        origins += [msg];
        int completeFragmentLength = BinaryDecoder<ushort>(incompleteRPCSourceData.Segment(8, 2)) as int;
        if (completeFragmentLength <= incompleteRPCSourceData.Count)
        {
            ValidationCheck(status == nothing || status == 0, msg, DiagnosisLevel.Warning, "MSRPCE: Fragment data is complete, whereas the NTStatus is not Success.");
            payloadData = incompleteRPCSourceData;
            incompleteRPCSourceData = $[];
        }
    }
    int fragmentLength = BinaryDecoder<ushort>(payloadData.Segment(8, 2)) as int;
    // case normal: NTSTATUS."Success", and all data arrived
    while (fragmentLength <= payloadData.Count && (status == nothing || status == 0))
    {
        // case: RPC source data embedded totally in the payloadData.
        if (!(msg in origins))
        {
            origins += [msg];
        }
        ProcessConnectionOrientedRpc(reassebmlyServer, payloadData, fragmentLength, origins, reassemblyDispatcher);
        if (fragmentLength == payloadData.Count)
        {
            origins = [];
            return;
        }
        // payloadData contains more than one RPC messages.
        payloadData = payloadData.Segment(fragmentLength);
        if (IsRpcconnCommonHdrT(payloadData))
        {
            fragmentLength = BinaryDecoder<ushort>(payloadData.Segment(8, 2)) as int;
        }
        else
        {
            ValidationCheck(false, msg, DiagnosisLevel.Warning, "MSRPCE: The underlying payload may contain multiple RPC messages, but the trailing data is invalid RPC message format.");
            // set IncompleteCache to empty, then all the following incomplet SMB messages should not be processed by MSRPCE, 
            // and possibly all completed normal messages could be parsed successfully with correct origins.
            incompleteRPCSourceData = $[];
            DispatchOriginsToRevive(ref origins);
            return;
        }
    }
    // case: incomplete RPC source data distributed in multi SMB Messages.
    if (fragmentLength > payloadData.Count && (status == nothing || status == 0x80000005)) // NTSTATUS."STATUS_BUFFER_OVERFLOW",
    {
        incompleteRPCSourceData += payloadData;
        if (!(msg in origins))
        {
            origins += [msg];
        }
        return;
    }
    // case: NTSTATUS."Success", but still incomplete data
    else if (fragmentLength > payloadData.Count && status == 0) 
    {
        ReportInsufficientData(msg, DiagnosisLevel.Error, "MSRPCE: Incomplete payload for MSRPCE parsing SMB/SMB2 messages.");
    }
    else
    {
        ValidationCheck(false, msg, DiagnosisLevel.Warning, "MSRPCE: The underlying payload cannot be totally parsed into MSRPCE, due to invalid data or status.");
    }
    DispatchOriginsToRevive(ref origins);
    DisplayTopLevelMessage(msg);
}

// Parse normal MRRPCE connection-oriented messages
void ProcessConnectionOrientedRpc((CoRpcServerReassembly | ServerOverNamedpipe) reasseblyServer, binary payloadData, int fragmentLength, array<any message> origins, void((CoRpcServerReassembly | ServerOverNamedpipe), RpcconnCommonHdrT) reassemblyDispatcher)
{
    byte pduType = payloadData[2];
    byte pfcFlags = payloadData[3];
    ushort authLength = BinaryDecoder<ushort>(payloadData.Segment(10, 2)) as ushort;
    // If authLength not zero, then get authPadLength and authVerifierLength from Payload.
    byte authPadLength = 0; 
    int authVerifierLength = 0;
    // referencing C706, 13.2.6, The verifier is present if and only if the auth_length field in the PDU is non-zero.
    // But while Bind, BindAck, AlterContext, AlterContextResp reassembling, payloadData.Segment() or other indexing operation will get exception.
    if (authLength != 0 && (((pfcFlags & 0x03) == 0x03) || (pduType != PDUType.Bind && pduType != PDUType.BindAck && pduType != PDUType.AlterContext && pduType != PDUType.AlterContextResp)))
    {
        authPadLength = payloadData[fragmentLength - authLength - 6];
        authVerifierLength = authPadLength + 8 + authLength; 
    }
    stream payloadStream = payloadData;
    switch (pduType)
    {
        case PDUType.Bind =>
        optional RpcconnBindHdrT bindOptional = BinaryDecoder<RpcconnBindHdrT>(payloadStream);
        if (bindOptional != nothing)
        {
            RpcconnBindHdrT bind = bindOptional as RpcconnBindHdrT;
            bind.Origins = origins;
            if ((bind.PfcFlags & 0x03) != 0x03) // need reassemble on AuthVerifier
            {
                bind.AuthVerifier = payloadData.Segment(payloadStream.BytePosition, bind.FragLength - payloadStream.BytePosition);
                AssociateFieldPosition(bind, "AuthVerifier", payloadStream, payloadStream.BitPosition, bind.FragLength * 8 - payloadStream.BitPosition);
            }
            else if (authVerifierLength > 0)
            {
                int authBeginPosition = payloadStream.BitPosition;
                bind.AuthVerifier = BinaryDecoder<AuthVerifierCoT[bind.AuthLength, authPadLength]>(payloadStream);
                AssociateFieldPosition(bind, "AuthVerifier", payloadStream, authBeginPosition);
            }
            reassemblyDispatcher(reasseblyServer, bind);
        }
        else
        {
            ThrowCoMSRPCEDecodingException("Bind", origins);
        }
        case PDUType.AlterContext =>
        optional RpcconnAlterContextHdrT alterContextOptional = BinaryDecoder<RpcconnAlterContextHdrT>(payloadStream);
        if (alterContextOptional != nothing)
        {
            RpcconnAlterContextHdrT alterContext = alterContextOptional as RpcconnAlterContextHdrT;
            alterContext.Origins = origins;
            if ((alterContext.PfcFlags & 0x03) != 0x03) // need reassemble on AuthVerifier
            {
                alterContext.AuthVerifier = payloadData.Segment(payloadStream.BytePosition, alterContext.FragLength - payloadStream.BytePosition);
                AssociateFieldPosition(alterContext, "AuthVerifier", payloadStream, payloadStream.BitPosition, alterContext.FragLength * 8 - payloadStream.BitPosition);
            }
            else if (authVerifierLength > 0)
            {
                int authBeginPosition = payloadStream.BitPosition;
                alterContext.AuthVerifier = BinaryDecoder<AuthVerifierCoT[alterContext.AuthLength, authPadLength]>(payloadStream);
                AssociateFieldPosition(alterContext, "AuthVerifier", payloadStream, authBeginPosition);
            }
            reassemblyDispatcher(reasseblyServer, alterContext);
        }
        else
        {
            ThrowCoMSRPCEDecodingException("AlterContext", origins);
        }
        case PDUType.Auth3 =>
            optional RpcconnRpcAuth3HdrT auth3Optional = BinaryDecoder<RpcconnRpcAuth3HdrT>(payloadStream);
            if (auth3Optional != nothing)
            {
                RpcconnRpcAuth3HdrT auth3 = auth3Optional as RpcconnRpcAuth3HdrT;
                auth3.Origins = origins;
                reassemblyDispatcher(reasseblyServer, auth3);
            }
            else
            {
                ThrowCoMSRPCEDecodingException("Auth3", origins);
            }
        case PDUType.Request =>
        optional RpcconnRequestHdrT requestOptional = BinaryDecoder<RpcconnRequestHdrT>(payloadStream);
        if (requestOptional != nothing)
        {
            RpcconnRequestHdrT request = requestOptional as RpcconnRequestHdrT;
            request.Origins = origins;
            int stubBeginPosition = payloadStream.BitPosition;
            request.StubData = (BinaryDecoder<Blob[(request.FragLength - payloadStream.BytePosition - authVerifierLength) as uint]>(payloadStream) as Blob).Data;
            AssociateFieldPosition(request, "StubData", payloadStream, stubBeginPosition);
            if (authVerifierLength > 0)
            {
                int authBeginPosition = payloadStream.BitPosition;
                request.AuthVerifier = BinaryDecoder<AuthVerifierCoT[request.AuthLength, authPadLength]>(payloadStream);
                AssociateFieldPosition(request, "AuthVerifier", payloadStream, authBeginPosition);
            }
            reassemblyDispatcher(reasseblyServer, request);
        }
        else
        {
            ThrowCoMSRPCEDecodingException("CoRequest", origins);
        }
        case PDUType.Orphaned =>
            optional RpcconnOrphanedHdrT orphanedOptional = BinaryDecoder<RpcconnOrphanedHdrT>(payloadStream);
            if (orphanedOptional != nothing)
            {
                RpcconnOrphanedHdrT orphaned = orphanedOptional as RpcconnOrphanedHdrT;
                orphaned.Origins = origins;
                reassemblyDispatcher(reasseblyServer, orphaned);
            }
            else
            {
                ThrowCoMSRPCEDecodingException("Orphaned", origins);
            }
        case PDUType.CoCancel =>
            optional RpcconnCancelHdrT cancelOptional = BinaryDecoder<RpcconnCancelHdrT>(payloadStream);
            if (cancelOptional != nothing)
            {
                RpcconnCancelHdrT cancel = cancelOptional as RpcconnCancelHdrT;
                cancel.Origins = origins;
                reassemblyDispatcher(reasseblyServer, cancel);
            }
            else
            {
                ThrowCoMSRPCEDecodingException("CoCancel", origins);
            }
        case PDUType.BindAck =>
        optional RpcconnBindAckHdrT bindAckOptional = BinaryDecoder<RpcconnBindAckHdrT>(payloadStream);
        if (bindAckOptional != nothing)
        {
            RpcconnBindAckHdrT bindAck = bindAckOptional as RpcconnBindAckHdrT;
            bindAck.Origins = origins;
            if ((bindAck.PfcFlags & 0x03) != 0x03) // need reassemble on AuthVerifier
            {
                bindAck.AuthVerifier = payloadData.Segment(payloadStream.BytePosition, bindAck.FragLength - payloadStream.BytePosition);
                AssociateFieldPosition(bindAck, "AuthVerifier", payloadStream, payloadStream.BitPosition, bindAck.FragLength * 8 - payloadStream.BitPosition);
            }
            else if (authVerifierLength > 0)
            {
                int authBeginPosition = payloadStream.BitPosition;
                bindAck.AuthVerifier = BinaryDecoder<AuthVerifierCoT[bindAck.AuthLength, authPadLength]>(payloadStream);
                AssociateFieldPosition(bindAck, "AuthVerifier", payloadStream, authBeginPosition);
            }
            reassemblyDispatcher(reasseblyServer, bindAck);
        }
        else
        {
            ThrowCoMSRPCEDecodingException("BindAck", origins);
        }
        case PDUType.AlterContextResp =>
        optional RpcconnAlterContextResponseHdrT alterContextRespOptional = BinaryDecoder<RpcconnAlterContextResponseHdrT>(payloadStream);
        if (alterContextRespOptional != nothing)
        {
            RpcconnAlterContextResponseHdrT alterContextResp = alterContextRespOptional as RpcconnAlterContextResponseHdrT;
            alterContextResp.Origins = origins;
            if ((alterContextResp.PfcFlags & 0x03) != 0x03) // need reassemble on AuthVerifier
            {
                alterContextResp.AuthVerifier = payloadData.Segment(payloadStream.BytePosition, alterContextResp.FragLength - payloadStream.BytePosition);
                AssociateFieldPosition(alterContextResp, "AuthVerifier", payloadStream, payloadStream.BitPosition, alterContextResp.FragLength * 8 - payloadStream.BitPosition);
            }
            else if (authVerifierLength > 0) // no need reassemble, decode using value parameter
            {
                int authBeginPosition = payloadStream.BitPosition;
                alterContextResp.AuthVerifier = BinaryDecoder<AuthVerifierCoT[alterContextResp.AuthLength, authPadLength]>(payloadStream);
                AssociateFieldPosition(alterContextResp, "AuthVerifier", payloadStream, authBeginPosition);
            }
            reassemblyDispatcher(reasseblyServer, alterContextRespOptional as RpcconnAlterContextResponseHdrT);
        }
        else
        {
            ThrowCoMSRPCEDecodingException("AlterContextResp", origins);
        }
        case PDUType.Response =>
        optional RpcconnResponseHdrT responseOptional = BinaryDecoder<RpcconnResponseHdrT>(payloadStream);
        if (responseOptional != nothing)
        {
            RpcconnResponseHdrT response = responseOptional as RpcconnResponseHdrT;
            response.Origins = origins;
            int stubBeginPosition = payloadStream.BitPosition;
            response.StubData = ((BinaryDecoder<Blob[(response.FragLength - payloadStream.BytePosition - authVerifierLength) as uint]>(payloadStream)) as Blob).Data;
            AssociateFieldPosition(response, "StubData", payloadStream, stubBeginPosition);
            if (authVerifierLength > 0)
            {
                int authBeginPosition = payloadStream.BitPosition;
                response.AuthVerifier = BinaryDecoder<AuthVerifierCoT[response.AuthLength, authPadLength]>(payloadStream);
                AssociateFieldPosition(response, "AuthVerifier", payloadStream, authBeginPosition);
            }
            reassemblyDispatcher(reasseblyServer, response);
        }
        else
        {
            ThrowCoMSRPCEDecodingException("CoResponse", origins);
        }
        case PDUType.Fault =>
            optional RpcconnFaultHdrT faultOptional = BinaryDecoder<RpcconnFaultHdrT>(payloadStream);
            if (faultOptional != nothing)
            {
                RpcconnFaultHdrT fault = faultOptional as RpcconnFaultHdrT;
                fault.Origins = origins;
                if (fault.Reserved2 != nothing)
                {
                    ValidationCheck(fault.Reserved2 == $[00000000], fault, DiagnosisLevel.Error, "MSRPCE: The Reserved2 in message RpcconnFaultHdrT must be zero.");
                    int stubBeginPosition = payloadStream.BitPosition;
                    fault.StubData = (BinaryDecoder<Blob[(fault.FragLength - payloadStream.BytePosition - authVerifierLength) as uint]>(payloadStream) as Blob).Data;
                    AssociateFieldPosition(fault, "StubData", payloadStream, stubBeginPosition);
                    if (authVerifierLength > 0)
                    {
                        int authBeginPosition = payloadStream.BitPosition;
                        fault.AuthVerifier = BinaryDecoder<AuthVerifierCoT[fault.AuthLength, authPadLength]>(payloadStream);
                        AssociateFieldPosition(fault, "AuthVerifier", payloadStream, authBeginPosition);
                    }
                }
                reassemblyDispatcher(reasseblyServer, fault);
            }
            else
            {
                ThrowCoMSRPCEDecodingException("CoFault", origins);
            }
        case PDUType.Shutdown =>
            optional RpcconnShutdownHdrT shutdownOptional = BinaryDecoder<RpcconnShutdownHdrT>(payloadStream);
            if (shutdownOptional != nothing)
            {
                RpcconnShutdownHdrT shutdown = shutdownOptional as RpcconnShutdownHdrT;
                shutdown.Origins = origins;
                reassemblyDispatcher(reasseblyServer, shutdown);
            }
            else
            {
                ThrowCoMSRPCEDecodingException("Shutdown", origins);
            }
        case PDUType.BindNak =>
            optional RpcconnBindNakHdrT bindNakOptional = BinaryDecoder<RpcconnBindNakHdrT>(payloadStream); 
            if (bindNakOptional != nothing)
            {
                RpcconnBindNakHdrT bindNak = bindNakOptional as RpcconnBindNakHdrT;
                bindNak.Origins = origins;
                reassemblyDispatcher(reasseblyServer, bindNak);
            }
            else
            {
                ThrowCoMSRPCEDecodingException("BindNak", origins);
            }
        default =>
            ThrowDecodingException("MSRPCE");
    }
}

void ThrowCoMSRPCEDecodingException(string messageTypeString, array<any message> origins)
{
    if (origins.Count > 0)
    {
        foreach (var m in origins)
        {
            DisplayTopLevelMessage(m);
        }
    }
    ThrowDecodingException("MSRPCE", messageTypeString);
}

void AssignCoFieldEncodingInfo(RpcconnCommonHdrT coMsg, binary sourceData)
{
    coMsg.SourceData = sourceData;
    coMsg.AssignFieldEncodingInfo("RpcVers", 0, 8);
    coMsg.AssignFieldEncodingInfo("RpcVersMinor", 8, 8);
    coMsg.AssignFieldEncodingInfo("PTYPE", 16, 8);
    coMsg.AssignFieldEncodingInfo("PfcFlags", 24, 8);
    coMsg.AssignFieldEncodingInfo("PackedDrep", 32, 32);
    coMsg.AssignFieldEncodingInfo("FragLength", 64, 16);
    coMsg.AssignFieldEncodingInfo("AuthLength", 80, 16);
    coMsg.AssignFieldEncodingInfo("CallId", 96, 32);
}

client endpoint CoRpcClientReassembly connected to CoRpcServerReassembly;

endpoint ServerOverNamedpipe[ulong FileId]
    accepts RpcconnCommonHdrT issues RpcconnCommonHdrT
{
    process this accepts m:RpcconnCommonHdrT
    {
        dispatch (endpoint CoRpcServerReassembly over this) accepts m;
    }
    process this issues m:RpcconnCommonHdrT
    {
        dispatch (endpoint CoRpcServerReassembly over this) issues m;
    }
};

endpoint CoRpcServerReassembly over VirtualTransport.Server | over ServerOverNamedpipe
accepts RpcconnBindHdrT issues RpcconnBindAckHdrT issues RpcconnBindNakHdrT
accepts RpcconnAlterContextHdrT accepts RpcconnRpcAuth3HdrT issues RpcconnAlterContextResponseHdrT
accepts RpcconnRequestHdrT issues RpcconnResponseHdrT
issues RpcconnRequestHdrT accepts RpcconnResponseHdrT //Nested RPC
accepts RpcconnCancelHdrT
issues RpcconnFaultHdrT
accepts RpcconnOrphanedHdrT
issues RpcconnShutdownHdrT
{
    void ServerAcceptsDispatcher(RpcconnCommonHdrT rpcconnCommonHdrT)
    {
        dispatch (endpoint Server over this) accepts rpcconnCommonHdrT;
    }
    
    void ServerIssuesDispatcher(RpcconnCommonHdrT rpcconnCommonHdrT)
    {
        dispatch (endpoint Server over this) issues rpcconnCommonHdrT;
    }
    
    array<RpcconnCommonHdrT> coRequestArray4Reassembly = [];
    array<RpcconnCommonHdrT> coResponseArray4Reassembly = [];
    array<RpcconnCommonHdrT> coFaultArray4Reassembly = [];
    array<RpcconnCommonHdrT> coBindArray4Reassembly = [];
    array<RpcconnCommonHdrT> coBindAckArray4Reassembly = [];
    array<RpcconnCommonHdrT> coAlterContextArray4Reassembly = [];
    array<RpcconnCommonHdrT> coAuth3Array4Reassembly = [];
    array<RpcconnCommonHdrT> coAlterContextResponseArray4Reassembly = [];
    
    process this accepts bind:RpcconnBindHdrT
    {
        ReassembleCoBind(ref coBindArray4Reassembly, bind, ServerAcceptsDispatcher);
    }
    
    process this issues bindAck:RpcconnBindAckHdrT
    {
        ReassembleCoBindAck(ref coBindAckArray4Reassembly, bindAck, ServerIssuesDispatcher);
    }
    
    process this issues bindNak:RpcconnBindNakHdrT
    {
        ServerIssuesDispatcher(bindNak);
    }
    
    process this accepts alterContext:RpcconnAlterContextHdrT
    {
        ReassembleCoAlterContext(ref coAlterContextArray4Reassembly, alterContext, ServerAcceptsDispatcher);
    }
    
    process this accepts auth3:RpcconnRpcAuth3HdrT
    {
        ReassembleCoAuth3(ref coAuth3Array4Reassembly, auth3, ServerAcceptsDispatcher);
    }
    
    process this issues alterContextResp:RpcconnAlterContextResponseHdrT
    {
        ReassembleCoAlterContextResponse(ref coAlterContextResponseArray4Reassembly, alterContextResp, ServerIssuesDispatcher);
    }
    
    process this accepts request:RpcconnRequestHdrT
    {
        ReassembleCoRequest(ref coRequestArray4Reassembly, request, ServerAcceptsDispatcher);
    }
    
    process this issues request:RpcconnRequestHdrT
    {
        ReassembleCoRequest(ref coRequestArray4Reassembly, request, ServerIssuesDispatcher);
    }
    
    process this accepts response:RpcconnResponseHdrT
    {
        ReassembleCoResponse(ref coResponseArray4Reassembly, response, ServerAcceptsDispatcher);
    }
    
    process this issues response:RpcconnResponseHdrT
    {
        ReassembleCoResponse(ref coResponseArray4Reassembly, response, ServerIssuesDispatcher);
    }
    
    process this accepts cancel:RpcconnCancelHdrT
    {
        ServerAcceptsDispatcher(cancel);
    }
    
    process this issues fault:RpcconnFaultHdrT
    {
        ReassembleCoFault(ref coFaultArray4Reassembly, fault, ServerIssuesDispatcher);
    }
    
    process this accepts orphaned:RpcconnOrphanedHdrT
    {
        ServerAcceptsDispatcher(orphaned);
    }
    
    process this issues shutdown:RpcconnShutdownHdrT
    {
        ServerIssuesDispatcher(shutdown);
    }
}

autostart actor ObserveCoRpcServerReassemblyDestructor(CoRpcServerReassembly e)
{
    ~endpoint(CoRpcServerReassembly e)
    {
        ClearRpcconnCommonHdrTArrayCache(ref e.coRequestArray4Reassembly);
        ClearRpcconnCommonHdrTArrayCache(ref e.coResponseArray4Reassembly);
        ClearRpcconnCommonHdrTArrayCache(ref e.coFaultArray4Reassembly);
        ClearRpcconnCommonHdrTArrayCache(ref e.coBindArray4Reassembly);
        ClearRpcconnCommonHdrTArrayCache(ref e.coBindAckArray4Reassembly);
        ClearRpcconnCommonHdrTArrayCache(ref e.coAlterContextArray4Reassembly);
        ClearRpcconnCommonHdrTArrayCache(ref e.coAuth3Array4Reassembly);
        ClearRpcconnCommonHdrTArrayCache(ref e.coAlterContextResponseArray4Reassembly);
    }
    
    void ClearRpcconnCommonHdrTArrayCache(ref array<RpcconnCommonHdrT> coRpcMsgArray)
    {
        if (coRpcMsgArray != null && coRpcMsgArray.Count > 0)
        {
            foreach (RpcconnCommonHdrT coRpcMsg in coRpcMsgArray)
            {
                DisplayTopLevelMessage(coRpcMsg);
            }
            coRpcMsgArray = [];
        }
    }
}

// Reassembly for connection-oriented Bind, including Nested Bind RPC
bool IsReadyToCoReassemble(ref array<RpcconnCommonHdrT> coArray4Reassembly, RpcconnCommonHdrT coRpcMsg, void(RpcconnCommonHdrT) dispatcher)
{
    // if no need reassemble, dispatch directly.
    if ((coRpcMsg.PfcFlags & 0x03) == 0x03) // (coRpcMsg.PfcFlags & RpcCoPfcFlags.PfcLastFrag) == RpcCoPfcFlags.PfcLastFrag && (coRpcMsg.PfcFlags & RpcCoPfcFlags.PfcFirstFrag) == RpcCoPfcFlags.PfcFirstFrag
    {
        dispatcher(coRpcMsg);
    }
    else
    {
        // First fragment
        if ((coRpcMsg.PfcFlags & 0x01) == 0x01) //(coRpcMsg.PfcFlags & RpcCoPfcFlags.PfcFirstFrag) == RpcCoPfcFlags.PfcFirstFrag)
        {
            if (coArray4Reassembly.Count > 0)
            {
                foreach (RpcconnCommonHdrT bindFrag in coArray4Reassembly)
                {
                    dispatcher(bindFrag);
                }
            }
            coArray4Reassembly = [coRpcMsg];
        }
        //Last fragment, (coRpcMsg.PfcFlags & RpcCoPfcFlags.PfcLastFrag) == RpcCoPfcFlags.PfcLastFrag
        else if ((coRpcMsg.PfcFlags & 0x02) == 0x02 && coArray4Reassembly.Count > 0 && (coArray4Reassembly[0].PfcFlags & 0x01) == 0x01) //(coArray4Reassembly[0].PfcFlags & RpcCoPfcFlags.PfcFirstFrag) == RpcCoPfcFlags.PfcFirstFrag)
        {
            return true;
        }
        else// other fragments need reassemble
        {
            coArray4Reassembly += [coRpcMsg];
        }
    }
    return false;
}

void AssignRpcconnCommonHdrTFields(RpcconnCommonHdrT coRpcMsgReassembled, RpcconnCommonHdrT coRpcMsg, PDUType pduType, bool keepFragLength)
{
    coRpcMsgReassembled.RpcVers = 5;
    coRpcMsgReassembled.PTYPE = pduType;
    coRpcMsgReassembled.PfcFlags = (coRpcMsg.PfcFlags | 0x03) as byte; // Set RpcCoPfcFlags.PfcFirstFrag and RpcCoPfcFlags.PfcLastFrag as 1
    coRpcMsgReassembled.PackedDrep = coRpcMsg.PackedDrep;
    // For Bind, BindAck, AlterContext, AlterContextResp, No other flags or fields will change while reassembling the authentication data. Auth3 ? currently keep consistent with Bind.
    // For Request and Response, the reassembled FragLength should be assigned according to the actual fragments, instead of assigning 'coRpcMsg.FragLength' here; Fault? currently keep consistent with Response.
    coRpcMsgReassembled.FragLength = keepFragLength ? coRpcMsg.FragLength : 0;
    coRpcMsgReassembled.AuthLength = coRpcMsg.AuthLength;
    coRpcMsgReassembled.CallId = coRpcMsg.CallId;
}

// Reassembly for connection-oriented Bind, including Nested Bind RPC
void ReassembleCoBind(ref array<RpcconnCommonHdrT> coBindArray4Reassembly, RpcconnBindHdrT bind, void(RpcconnCommonHdrT) dispatcher)
{
    if (IsReadyToCoReassemble(ref coBindArray4Reassembly, bind, dispatcher))
    {
        coBindArray4Reassembly += [bind];
        RpcconnBindHdrT bindReassembled = new RpcconnBindHdrT {};
        AssignRpcconnCommonHdrTFields(bindReassembled, bind, PDUType.Bind, true);
        bindReassembled.MaxXmitFrag = bind.MaxXmitFrag;
        bindReassembled.MaxRecvFrag = bind.MaxRecvFrag;
        bindReassembled.AssocGroupId = bind.AssocGroupId;
        bindReassembled.PContextElem = bind.PContextElem;
        binary authBinary = $[];
        binary sourceData = $[];
        foreach (RpcconnCommonHdrT commonFrag in coBindArray4Reassembly)
        {
            RpcconnBindHdrT frag = commonFrag as RpcconnBindHdrT;
            authBinary += (frag.AuthVerifier as binary);
            bindReassembled.Origins += [frag];
            if (sourceData.Count == 0)
            {
                sourceData += (frag.SourceData as binary);
            }
            else
            {
                sourceData += (frag.AuthVerifier as binary);
            }
        }
        bindReassembled.AuthVerifier = BinaryDecoder<AuthVerifierCoT[bindReassembled.AuthLength, authBinary[bindReassembled.FragLength - bindReassembled.AuthLength - 6]]>(authBinary as stream);
        AssignCoFieldEncodingInfo(bindReassembled, sourceData);
        bindReassembled.AssignFieldEncodingInfo("MaxXmitFrag", 128, 16);
        bindReassembled.AssignFieldEncodingInfo("MaxRecvFrag", 144, 16);
        bindReassembled.AssignFieldEncodingInfo("AssocGroupId", 160, 32);
        bindReassembled.AssignFieldEncodingInfo("PContextElem", 192, (bindReassembled.FragLength - 24 - authBinary.Count) * 8);
        bindReassembled.AssignFieldEncodingInfo("AuthVerifier", (bindReassembled.FragLength - authBinary.Count) * 8, authBinary.Count * 8);
        dispatcher(bindReassembled);
        coBindArray4Reassembly = [];
    }
}

// Reassembly for connection-oriented BindAck, including Nested BindAck RPC
void ReassembleCoBindAck(ref array<RpcconnCommonHdrT> coBindAckArray4Reassembly, RpcconnBindAckHdrT bindAck, void(RpcconnCommonHdrT) dispatcher)
{
    if (IsReadyToCoReassemble(ref coBindAckArray4Reassembly, bindAck, dispatcher))
    {
        coBindAckArray4Reassembly += [bindAck];
        RpcconnBindAckHdrT bindAckReassembled = new RpcconnBindAckHdrT {};
        AssignRpcconnCommonHdrTFields(bindAckReassembled, bindAck, PDUType.BindAck, true);
        bindAckReassembled.MaxXmitFrag = bindAck.MaxXmitFrag;
        bindAckReassembled.MaxRecvFrag = bindAck.MaxRecvFrag;
        bindAckReassembled.AssocGroupId = bindAck.AssocGroupId;
        bindAckReassembled.SecAddr = bindAck.SecAddr;
        bindAckReassembled.Pad2 = bindAck.Pad2;
        bindAckReassembled.PResultList = bindAck.PResultList;
        binary authBinary = $[];
        binary sourceData = $[];
        foreach (RpcconnCommonHdrT commonFrag in coBindAckArray4Reassembly)
        {
            RpcconnBindAckHdrT frag = commonFrag as RpcconnBindAckHdrT;
            authBinary += (frag.AuthVerifier as binary);
            bindAckReassembled.Origins += [frag];
            if (sourceData.Count == 0)
            {
                sourceData += (frag.SourceData as binary);
            }
            else
            {
                sourceData += (frag.AuthVerifier as binary);
            }
        }
        bindAckReassembled.AuthVerifier = BinaryDecoder<AuthVerifierCoT[bindAckReassembled.AuthLength, authBinary[bindAckReassembled.FragLength - bindAckReassembled.AuthLength - 6]]>(authBinary as stream);//DecodeAuthVerifier(authBinary[bindAckReassembled.FragLength - bindAckReassembled.AuthLength - 6], bindAckReassembled.AuthLength, authBinary);
        AssignCoFieldEncodingInfo(bindAckReassembled, sourceData);
        bindAckReassembled.AssignFieldEncodingInfo("MaxXmitFrag", 128, 16);
        bindAckReassembled.AssignFieldEncodingInfo("MaxRecvFrag", 144, 16);
        bindAckReassembled.AssignFieldEncodingInfo("AssocGroupId", 160, 32);
        bindAckReassembled.AssignFieldEncodingInfo("SecAddr", 192, (bindAckReassembled.FragLength - 24 - authBinary.Count - ((4 -(bindAckReassembled.SecAddr.Length + 26) % 4) % 4)) * 8);
        bindAckReassembled.AssignFieldEncodingInfo("Pad2", (bindAckReassembled.FragLength - authBinary.Count - ((4 -(bindAckReassembled.SecAddr.Length + 26) % 4) % 4)) * 8, ((4 -(bindAckReassembled.SecAddr.Length + 26) % 4) % 4) * 8);
        bindAckReassembled.AssignFieldEncodingInfo("AuthVerifier", (bindAckReassembled.FragLength - authBinary.Count) * 8, authBinary.Count * 8);
        dispatcher(bindAckReassembled);
        coBindAckArray4Reassembly = [];
    }
}

// Reassembly for connection-oriented AlterContext, including Nested AlterContext RPC
void ReassembleCoAlterContext(ref array<RpcconnCommonHdrT> coAlterContextArray4Reassembly, RpcconnAlterContextHdrT alterContext, void(RpcconnCommonHdrT) dispatcher)
{
    if (IsReadyToCoReassemble(ref coAlterContextArray4Reassembly, alterContext, dispatcher))
    {
        coAlterContextArray4Reassembly += [alterContext];
        RpcconnAlterContextHdrT alterContextReassembled = new RpcconnAlterContextHdrT {};
        AssignRpcconnCommonHdrTFields(alterContextReassembled, alterContext, PDUType.AlterContext, true);
        alterContextReassembled.MaxXmitFrag = alterContext.MaxXmitFrag;
        alterContextReassembled.MaxRecvFrag = alterContext.MaxRecvFrag;
        alterContextReassembled.AssocGroupId = alterContext.AssocGroupId;
        alterContextReassembled.PContextElem = alterContext.PContextElem;
        binary authBinary = $[];
        foreach (RpcconnCommonHdrT frag in coAlterContextArray4Reassembly)
        {
            authBinary += ((frag as RpcconnAlterContextHdrT).AuthVerifier as binary);
            alterContextReassembled.Origins += [frag];
        }
        alterContextReassembled.AuthVerifier = BinaryDecoder<AuthVerifierCoT[alterContextReassembled.AuthLength, authBinary[alterContextReassembled.FragLength - alterContextReassembled.AuthLength - 6]]>(authBinary as stream);//DecodeAuthVerifier(authBinary[alterContextReassembled.FragLength - alterContextReassembled.AuthLength - 6], alterContextReassembled.AuthLength, authBinary);
        dispatcher(alterContextReassembled);
        coAlterContextArray4Reassembly = [];
    }
}

// Reassembly for connection-oriented Auth3, including Nested Auth3 RPC
void ReassembleCoAuth3(ref array<RpcconnCommonHdrT> coAuth3Array4Reassembly, RpcconnRpcAuth3HdrT auth3, void(RpcconnCommonHdrT) dispatcher)
{
    if (IsReadyToCoReassemble(ref coAuth3Array4Reassembly, auth3, dispatcher))
    {
        coAuth3Array4Reassembly += [auth3];
        RpcconnRpcAuth3HdrT auth3Reassembled = new RpcconnRpcAuth3HdrT {};
        AssignRpcconnCommonHdrTFields(auth3Reassembled, auth3, PDUType.Auth3, true);
        auth3Reassembled.Pad = auth3.Pad;
        auth3Reassembled.SecTrailer = auth3.SecTrailer;
        auth3Reassembled.AuthenticationTokens = $[];
        foreach (RpcconnCommonHdrT frag in coAuth3Array4Reassembly)
        {
            auth3Reassembled.AuthenticationTokens = (auth3Reassembled.AuthenticationTokens as binary) + ((frag as RpcconnRpcAuth3HdrT).AuthenticationTokens as binary);
            auth3Reassembled.Origins += [frag];
        }
        dispatcher(auth3Reassembled);
        coAuth3Array4Reassembly = [];
    }
}

// Reassembly for connection-oriented AlterContextResponse, including Nested AlterContextResponse RPC
void ReassembleCoAlterContextResponse(ref array<RpcconnCommonHdrT> coAlterContextResponseArray4Reassembly, RpcconnAlterContextResponseHdrT alterContextResp, void(RpcconnCommonHdrT) dispatcher)
{
    if (IsReadyToCoReassemble(ref coAlterContextResponseArray4Reassembly, alterContextResp, dispatcher))
    {
        coAlterContextResponseArray4Reassembly += [alterContextResp];
        RpcconnAlterContextResponseHdrT alterContextRespReassembled = new RpcconnAlterContextResponseHdrT {};
        AssignRpcconnCommonHdrTFields(alterContextRespReassembled, alterContextResp, PDUType.AlterContextResp, true);
        alterContextRespReassembled.MaxXmitFrag = alterContextResp.MaxXmitFrag;
        alterContextRespReassembled.MaxRecvFrag = alterContextResp.MaxRecvFrag;
        alterContextRespReassembled.AssocGroupId = alterContextResp.AssocGroupId;
        alterContextRespReassembled.SecAddr = alterContextResp.SecAddr;
        alterContextRespReassembled.Pad2 = alterContextResp.Pad2;
        alterContextRespReassembled.PResultList = alterContextResp.PResultList;
        binary authBinary = $[];
        foreach (RpcconnCommonHdrT frag in coAlterContextResponseArray4Reassembly)
        {
            authBinary += ((frag as RpcconnAlterContextResponseHdrT).AuthVerifier as binary);
            alterContextRespReassembled.Origins += [frag];
        }
        optional AuthVerifierCoT authVerifier = BinaryDecoder<AuthVerifierCoT[alterContextRespReassembled.AuthLength, authBinary[alterContextRespReassembled.FragLength - alterContextRespReassembled.AuthLength - 6]]>(authBinary as stream);//DecodeAuthVerifier(authBinary[alterContextRespReassembled.FragLength - alterContextRespReassembled.AuthLength - 6], alterContextRespReassembled.AuthLength, authBinary);
        alterContextRespReassembled.AuthVerifier = authVerifier == nothing ? (nothing as optional (AuthVerifierCoT | binary)) : authVerifier;
        dispatcher(alterContextRespReassembled);
        coAlterContextResponseArray4Reassembly = [];
    }
}

// Reassembly for connection-oriented Request, including Nested Request RPC
void ReassembleCoRequest(ref array<RpcconnCommonHdrT> coRequestArray4Reassembly, RpcconnRequestHdrT request, void(RpcconnCommonHdrT) dispatcher)
{
    if (IsReadyToCoReassemble(ref coRequestArray4Reassembly, request, dispatcher))
    {
        coRequestArray4Reassembly += [request];
        RpcconnRequestHdrT requestReassembled = new RpcconnRequestHdrT {};
        AssignRpcconnCommonHdrTFields(requestReassembled, request, PDUType.Request, false);
        requestReassembled.AllocHint = request.AllocHint;
        requestReassembled.PContId = request.PContId;
        requestReassembled.Opnum = request.Opnum;
        requestReassembled.Object = request.Object;
        requestReassembled.StubData = $[];
        requestReassembled.AuthVerifier = request.AuthVerifier;
        //requestReassembled#PContextUuid = request#PContextUuid == nothing ? "" : request#PContextUuid;
        int headerLength = request.Object == nothing ? 24 : 40; // remember the request header length.
        binary sourceData = $[];
        foreach (RpcconnCommonHdrT commonFrag in coRequestArray4Reassembly)
        {
            RpcconnRequestHdrT requestFrag = commonFrag as RpcconnRequestHdrT;
            requestReassembled.FragLength = (requestReassembled.FragLength + requestFrag.FragLength - headerLength) as ushort;
            requestReassembled.StubData += requestFrag.StubData;
            requestReassembled.Origins += [requestFrag];
            if (sourceData.Count == 0)
            {
                sourceData += (requestFrag.SourceData as binary);
            }
            else
            {
                sourceData += requestFrag.StubData;
            }
        }
        requestReassembled.FragLength = (requestReassembled.FragLength + headerLength) as ushort;

        AssignCoFieldEncodingInfo(requestReassembled, sourceData);
        requestReassembled.AssignFieldEncodingInfo("AllocHint", 128, 32);
        requestReassembled.AssignFieldEncodingInfo("PContId", 160, 16);
        requestReassembled.AssignFieldEncodingInfo("Opnum", 176, 16);
        if (requestReassembled.Object != nothing)
        {
            requestReassembled.AssignFieldEncodingInfo("Object", 192, 128);
            requestReassembled.AssignFieldEncodingInfo("StubData", 320, requestReassembled.StubData.Count * 8);
        }
        else
        {
            requestReassembled.AssignFieldEncodingInfo("StubData", 192, requestReassembled.StubData.Count * 8);
        }
        if (requestReassembled.AuthLength > 0)
        {
            requestReassembled.AssignFieldEncodingInfo("AuthVerifier", (requestReassembled.FragLength - requestReassembled.AuthLength - (requestReassembled.AuthVerifier as AuthVerifierCoT).AuthPadLength - 8) * 8, (requestReassembled.AuthLength + (requestReassembled.AuthVerifier as AuthVerifierCoT).AuthPadLength + 8) * 8);
        }
        dispatcher(requestReassembled);
        coRequestArray4Reassembly = [];
    }
}

// Reassembly for connection-oriented Response, including Nested Response RPC
void ReassembleCoResponse(ref array<RpcconnCommonHdrT> coResponseArray4Reassembly, RpcconnResponseHdrT response, void(RpcconnCommonHdrT) dispatcher)
{
    if (IsReadyToCoReassemble(ref coResponseArray4Reassembly, response, dispatcher))
    {
        coResponseArray4Reassembly += [response];
        RpcconnResponseHdrT responseReassembled = new RpcconnResponseHdrT {};
        AssignRpcconnCommonHdrTFields(responseReassembled, response, PDUType.Response, false);
        responseReassembled.AllocHint = response.AllocHint;
        responseReassembled.PContId = response.PContId;
        responseReassembled.CancelCount = response.CancelCount;
        responseReassembled.Reserved = response.Reserved;
        responseReassembled.StubData = $[];
        responseReassembled.AuthVerifier = response.AuthVerifier;
        binary sourceData = $[];
        foreach (RpcconnCommonHdrT commonFrag in coResponseArray4Reassembly)
        {
            RpcconnResponseHdrT responseFrag = commonFrag as RpcconnResponseHdrT;
            responseReassembled.FragLength = (responseReassembled.FragLength + responseFrag.FragLength - 24) as ushort;// 24 is the response header length.
            responseReassembled.StubData += responseFrag.StubData;
            responseReassembled.Origins += [responseFrag];
            if (sourceData.Count == 0)
            {
                sourceData += (responseFrag.SourceData as binary);
            }
            else
            {
                sourceData += responseFrag.StubData;
            }
        }
        responseReassembled.FragLength = (responseReassembled.FragLength + 24) as ushort;

        AssignCoFieldEncodingInfo(responseReassembled, sourceData);
        responseReassembled.AssignFieldEncodingInfo("AllocHint", 128, 32);
        responseReassembled.AssignFieldEncodingInfo("PContId", 160, 16);
        responseReassembled.AssignFieldEncodingInfo("CancelCount", 176, 8);
        responseReassembled.AssignFieldEncodingInfo("Reserved", 184, 8);
        responseReassembled.AssignFieldEncodingInfo("StubData", 192, responseReassembled.StubData.Count * 8);
        if (responseReassembled.AuthLength > 0)
        {
            responseReassembled.AssignFieldEncodingInfo("AuthVerifier", (responseReassembled.FragLength - responseReassembled.AuthLength - (responseReassembled.AuthVerifier as AuthVerifierCoT).AuthPadLength - 8) * 8, (responseReassembled.AuthLength + (responseReassembled.AuthVerifier as AuthVerifierCoT).AuthPadLength + 8) * 8);
        }
        dispatcher(responseReassembled);
        coResponseArray4Reassembly = [];
    }
}

// Reassembly for connection-oriented Fault, including Nested Fault RPC
void ReassembleCoFault(ref array<RpcconnCommonHdrT> coFaultArray4Reassembly, RpcconnFaultHdrT fault, void(RpcconnCommonHdrT) dispatcher)
{
    if (IsReadyToCoReassemble(ref coFaultArray4Reassembly, fault, dispatcher))
    {
        coFaultArray4Reassembly += [fault];
        RpcconnFaultHdrT faultReassembled = new RpcconnFaultHdrT {};
        AssignRpcconnCommonHdrTFields(faultReassembled, fault, PDUType.Fault, false);
        faultReassembled.AllocHint = fault.AllocHint;
        faultReassembled.PContId = fault.PContId;
        faultReassembled.CancelCount = fault.CancelCount;
        faultReassembled.Reserved = fault.Reserved;
        faultReassembled.Status = fault.Status;
        faultReassembled.Reserved2 = fault.Reserved2;
        faultReassembled.StubData = $[];
        faultReassembled.AuthVerifier = fault.AuthVerifier;
        foreach (RpcconnCommonHdrT commonFrag in coFaultArray4Reassembly)
        {
            RpcconnFaultHdrT faultFrag = commonFrag as RpcconnFaultHdrT;
            faultReassembled.FragLength = (faultReassembled.FragLength + faultFrag.FragLength - 32) as ushort;//32 is the fault header length;
            faultReassembled.StubData = (faultReassembled.StubData as binary) + (faultFrag.StubData as binary);
            faultReassembled.Origins += [faultFrag];
        }
        faultReassembled.FragLength = (faultReassembled.FragLength + 32) as ushort;
        dispatcher(faultReassembled);
        coFaultArray4Reassembly = [];
    }
}

//_______________________________________________________________________Connectionless Functions_____________________________________________________________________

autostart actor DceRpcOverUDP(UDP.Host host)
{
    set<binary> clRequestSet = {};
    set<binary> clResponseSet = {};

    void ClReassemblyAcceptsDispatcher(DcRpcClPktHdrT dcRpcClPktHdrT)
    {
        dispatch (endpoint ClRpcServerReassembly over host) accepts dcRpcClPktHdrT;
    }
    
    void ClReassemblyIssuesDispatcher(DcRpcClPktHdrT dcRpcClPktHdrT)
    {
        dispatch (endpoint ClRpcServerReassembly over host) issues dcRpcClPktHdrT;
    }
    
    // 80 is DcRpcClPktHdrT content length and larger than ClMessageIdentifier's content length;
    process host accepts d:UDP.Datagram where (d.Payload.Count >= 80 
    && (((d.SourcePort == Port.DCERPC || d.DestinationPort == Port.DCERPC) && d.Payload[0] == 4) 
    || (!(d.SourcePort is Port) && !(d.DestinationPort is Port) && BinaryDecoder<ClMessageIdentifier>(d.Payload.Segment(0, 7)) != nothing)))
    {
        ProcessConnectionlessRpc(ref clRequestSet, ref clResponseSet, host, d, ClReassemblyAcceptsDispatcher, ClReassemblyIssuesDispatcher);
    }
}

void ProcessConnectionlessRpc(ref set<binary> clRequestSet, ref set<binary> clResponseSet, UDP.Host host, UDP.Datagram d, void(DcRpcClPktHdrT) AcceptsDispatcher, void(DcRpcClPktHdrT) IssuesDispatcher)
{
    byte pType = d.Payload[1];
    stream payloadStream = d.Payload;
    switch (pType)
    {
        case PDUType.Request =>
        optional DcRpcClRequest requestOptional = BinaryDecoder<DcRpcClRequest>(payloadStream);
        if (requestOptional != nothing)
        {
            // remember the request RPC (client to server) by activity id and sequence number. used for Fack message to be dispatched correctly.
            if (((requestOptional as DcRpcClRequest).Flags1 & RpcClPktHdrFlag1.Frag) == RpcClPktHdrFlag1.Frag)
            {
                clRequestSet[d.Payload.Segment(40, 16) + d.Payload.Segment(64, 4)] = true;
            }
            AcceptsDispatcher(requestOptional as DcRpcClRequest);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClRequest");
        }
        case PDUType.Response =>
        optional DcRpcClResponse responseOptional = BinaryDecoder<DcRpcClResponse>(payloadStream);
        if (responseOptional != nothing)
        {
            // remember the response RPC (client to server) by activity id and sequence number. used for Fack message to be dispatched correctly.
            if (((responseOptional as DcRpcClResponse).Flags1 & RpcClPktHdrFlag1.Frag) == RpcClPktHdrFlag1.Frag)
            {
                clResponseSet[d.Payload.Segment(40, 16) + d.Payload.Segment(64, 4)] = true;
            }
            IssuesDispatcher(responseOptional as DcRpcClResponse);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClResponse");
        }
        case PDUType.Ping =>
        optional DcRpcClPing pingOptional = BinaryDecoder<DcRpcClPing>(payloadStream);
        if (pingOptional != nothing)
        {
            AcceptsDispatcher(pingOptional as DcRpcClPing);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClPing");
        }
        case PDUType.Fault =>
        optional DcRpcClFault faultOptional = BinaryDecoder<DcRpcClFault>(payloadStream);
        if (faultOptional != nothing)
        {
            IssuesDispatcher(faultOptional as DcRpcClFault);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClFault");
        }
        case PDUType.Working =>
        optional DcRpcClWorking workingOptional = BinaryDecoder<DcRpcClWorking>(payloadStream);
        if (workingOptional != nothing)
        {
            IssuesDispatcher(workingOptional as DcRpcClWorking);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClWorking");
        }
        case PDUType.NoCall =>
        optional DcRpcClNocall noCallOptional = BinaryDecoder<DcRpcClNocall>(payloadStream);
        if (noCallOptional != nothing)
        {
            IssuesDispatcher(noCallOptional as DcRpcClNocall);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClNocall");
        }
        case PDUType.Reject =>
        optional DcRpcClReject rejectOptional = BinaryDecoder<DcRpcClReject>(payloadStream);
        if (rejectOptional != nothing)
        {
            IssuesDispatcher(rejectOptional as DcRpcClReject);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClReject");
        }
        case PDUType.Ack =>
        optional DcRpcClAck ackOptional = BinaryDecoder<DcRpcClAck>(payloadStream);
        if (ackOptional != nothing)
        {
            AcceptsDispatcher(ackOptional as DcRpcClAck);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClAck");
        }
        case PDUType.ClCancel =>
        optional DcRpcClCancel cancelOptional = BinaryDecoder<DcRpcClCancel>(payloadStream);
        if (cancelOptional != nothing)
        {
            AcceptsDispatcher(cancelOptional as DcRpcClCancel);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClCancel");
        }
        case PDUType.Fack =>
        optional DcRpcClFack fackOptional = BinaryDecoder<DcRpcClFack>(payloadStream);
        if (fackOptional != nothing)
        {
            binary key = d.Payload.Segment(40, 16) + d.Payload.Segment(64, 4);
            // only display server side. to avoid display twice in the logic of ClRpcServerReassembly. If we use 'Contact/Traffic' we should deal with the client side.
            if (key in clResponseSet)
            {
                AcceptsDispatcher(fackOptional as DcRpcClFack);
            }
            else if (key in clRequestSet)
            {
                IssuesDispatcher(fackOptional as DcRpcClFack);
            }
            else
            {
                dispatch (endpoint Server over host) accepts fackOptional as DcRpcClFack;
            }
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClFack");
        }
        case PDUType.CancelAck =>
        optional DcRpcClCancelAck cancelAckOptional = BinaryDecoder<DcRpcClCancelAck>(payloadStream);
        if (cancelAckOptional != nothing)
        {
            IssuesDispatcher(cancelAckOptional as DcRpcClCancelAck);
        }
        else
        {
            ThrowDecodingException("MSRPCE", "DcRpcClCancelAck");
        }
        default =>
        ThrowDecodingException("MSRPCE");
    }
}

void AssignClFieldEncodingInfo(DcRpcClPktHdrT clMsg, binary sourceData)
{
    clMsg.SourceData = sourceData;
    clMsg.AssignFieldEncodingInfo("RpcVers", 0, 8);
    clMsg.AssignFieldEncodingInfo("PType", 8, 8);
    clMsg.AssignFieldEncodingInfo("Flags1", 16, 8);
    clMsg.AssignFieldEncodingInfo("Flags2", 24, 8);
    clMsg.AssignFieldEncodingInfo("Drep", 32, 24);
    clMsg.AssignFieldEncodingInfo("SerialHi", 56, 8);
    clMsg.AssignFieldEncodingInfo("Object", 64, 128);
    clMsg.AssignFieldEncodingInfo("IfId", 192, 128);
    clMsg.AssignFieldEncodingInfo("ActId", 320, 128);
    clMsg.AssignFieldEncodingInfo("ServerBoot", 56 * 8, 32);
    clMsg.AssignFieldEncodingInfo("IfVers", 60 * 8, 32);
    clMsg.AssignFieldEncodingInfo("Seqnum", 64 * 8, 32);
    clMsg.AssignFieldEncodingInfo("Opnum", 68 * 8, 16);
    clMsg.AssignFieldEncodingInfo("Ihint", 70 * 8, 16);
    clMsg.AssignFieldEncodingInfo("Ahint", 72 * 8, 16);
    clMsg.AssignFieldEncodingInfo("Len", 74 * 8, 16);
    clMsg.AssignFieldEncodingInfo("Fragnum", 76 * 8, 16);
    clMsg.AssignFieldEncodingInfo("AuthProto", 78 * 8, 8);
    clMsg.AssignFieldEncodingInfo("SerialLo", 79 * 8, 8);
}

client endpoint ClRpcClientReassembly connected to ClRpcServerReassembly;

endpoint ClRpcServerReassembly over UDP.Host
accepts DcRpcClRequest issues DcRpcClResponse
accepts DcRpcClAck
accepts DcRpcClCancel issues DcRpcClCancelAck
accepts DcRpcClFack issues DcRpcClFack
issues DcRpcClFault
accepts DcRpcClPing issues DcRpcClNocall issues DcRpcClWorking
issues DcRpcClReject
{
    void ServerAcceptsDispatcher(DcRpcClPktHdrT dcRpcClPktHdrT)
    {
        dispatch (endpoint MSRPCE.Server over this) accepts dcRpcClPktHdrT;
    }
    
    void ServerIssuesDispatcher(DcRpcClPktHdrT dcRpcClPktHdrT)
    {
        dispatch (endpoint MSRPCE.Server over this) issues dcRpcClPktHdrT;
    }
    
    map<string, array<DcRpcClPktHdrT>> map4ClRequestReassemble = {};
    map<string, array<DcRpcClPktHdrT>> map4ClResponseReassemble = {};
    map<string, ushort> biggestRequestFragnum = {};
    map<string, ushort> biggestResponseFragnum = {};
    
    process this accepts ack:DcRpcClAck
    {
        ServerAcceptsDispatcher(ack);
    }
    
    process this accepts cancel:DcRpcClCancel
    {
        ServerAcceptsDispatcher(cancel);
    }
    
    process this issues cancelAck:DcRpcClCancelAck
    {
        ServerIssuesDispatcher(cancelAck);
    }
    
    process this issues fault:DcRpcClFault
    {
        ServerIssuesDispatcher(fault);
    }
    
    process this accepts ping:DcRpcClPing
    {
        ServerAcceptsDispatcher(ping);
    }
    
    process this issues nocall:DcRpcClNocall
    {
        ServerIssuesDispatcher(nocall);
    }
    
    process this issues working:DcRpcClWorking
    {
        ServerIssuesDispatcher(working);
    }
    
    process this issues clReject:DcRpcClReject
    {
        ServerIssuesDispatcher(clReject);
    }
    
    process this accepts request:DcRpcClRequest
    {
        // remember the request RPC (server to client) by activity id and sequence number.
        string mapKey = UuidToText(request.ActId) + (request.Seqnum as string);
        if (IsReadyToClReassemble(ref map4ClRequestReassemble, ref biggestRequestFragnum, request, mapKey, ServerAcceptsDispatcher))
        {
            ClRequestReassemble(ref map4ClRequestReassemble, ref biggestRequestFragnum, request, mapKey, ServerAcceptsDispatcher);
        }
    }
    
    process this issues response:DcRpcClResponse
    {
        // remember the response RPC (server to client) by activity id and sequence number.
        string mapKey = UuidToText(response.ActId) + (response.Seqnum as string);
        if (IsReadyToClReassemble(ref map4ClResponseReassemble, ref biggestResponseFragnum, response, mapKey, ServerIssuesDispatcher))
        {
            ClResponseReassemble(ref map4ClResponseReassemble, ref biggestResponseFragnum, response, mapKey, ServerIssuesDispatcher);
        }
    }
    
    process this accepts fack:DcRpcClFack
    {
        string key = UuidToText(fack.ActId) + (fack.Seqnum as string);
        if (!(key in map4ClResponseReassemble))
        {
            map4ClResponseReassemble[key] = [fack];
        }
        else
        {
            map4ClResponseReassemble[key] += [fack];
        }
    }
    
    process this issues fack:DcRpcClFack
    {
        string key = UuidToText(fack.ActId) + (fack.Seqnum as string);
        if (!(key in map4ClRequestReassemble))
        {
            map4ClRequestReassemble[key] = [fack];
        }
        else
        {
            map4ClRequestReassemble[key] += [fack];
        }
    }
}

autostart actor ObserveClRpcServerReassemblyDestructor(ClRpcServerReassembly e)
{
    ~endpoint(ClRpcServerReassembly e)
    {
        ClearDcRpcClPktHdrTMapCache(ref e.map4ClRequestReassemble, ref e.biggestRequestFragnum, true, e.ServerAcceptsDispatcher);
        ClearDcRpcClPktHdrTMapCache(ref e.map4ClResponseReassemble, ref e.biggestResponseFragnum, false, e.ServerIssuesDispatcher);
    }

    void ClearDcRpcClPktHdrTMapCache(ref map<string, array<DcRpcClPktHdrT>> map4ClReassemble, ref map<string, ushort> biggestFragnum, bool isRequest, void(DcRpcClPktHdrT) dispatcher)
    {
        if (map4ClReassemble != null)
        {
            while (map4ClReassemble.Count > 0)
            {
                string mapKey = "";
                var clRpcMsg = null;
                foreach (string key in map4ClReassemble.Keys)
                {
                    mapKey = key;
                    if (map4ClReassemble[key].Count > 0)
                    {
                        clRpcMsg = map4ClReassemble[key][0];
                        ushort temp = clRpcMsg.Fragnum;
                        foreach (DcRpcClPktHdrT frag in map4ClReassemble[key])
                        {
                            if (frag.Fragnum > temp)
                            {
                                temp = frag.Fragnum;
                            }
                        }
                        biggestFragnum[key] = temp; // fake value
                        break;
                    }
                }
                if (clRpcMsg != null)
                {
                    if (isRequest)
                    {
                        ClRequestReassemble(ref map4ClReassemble, ref biggestFragnum, clRpcMsg, mapKey, dispatcher);
                    }
                    else // Response
                    {
                        ClResponseReassemble(ref map4ClReassemble, ref biggestFragnum, clRpcMsg, mapKey, dispatcher);
                    }
                }
            }
        }
        biggestFragnum = {};
    }
}

bool IsReadyToClReassemble(ref map<string, array<DcRpcClPktHdrT>> map4ClReassemble, ref map<string, ushort> biggestFragnum, DcRpcClPktHdrT clRpcMsg, string key, void(DcRpcClPktHdrT) dispatcher)
{
    if ((clRpcMsg.Flags1 & RpcClPktHdrFlag1.Frag) != RpcClPktHdrFlag1.Frag)
    {
        dispatcher(clRpcMsg);
        return false;
    }
    else
    {
        if (!(key in map4ClReassemble))
        {
            map4ClReassemble[key] = [clRpcMsg];
        }
        else
        {
            map4ClReassemble[key] += [clRpcMsg];
        }
        if ((clRpcMsg.Flags1 & RpcClPktHdrFlag1.Lastfrag) == RpcClPktHdrFlag1.Lastfrag)
        {
            biggestFragnum[key] = clRpcMsg.Fragnum;
        }
        if (key in biggestFragnum)
        {
            map<ushort, bool> cachedFrames = {};
            foreach (DcRpcClPktHdrT frag in map4ClReassemble[key])
            {
                if (!(frag.Fragnum in cachedFrames) && !(frag is DcRpcClFack))
                {
                    cachedFrames[frag.Fragnum] = true;
                }
            }
            return (cachedFrames.Count - 1) == biggestFragnum[key];
        }
        return false;
    }
}

void ClRequestReassemble(ref map<string, array<DcRpcClPktHdrT>> map4ClRequestReassemble, ref map<string, ushort> biggestRequestFragnum, DcRpcClPktHdrT request, string mapKey, void(DcRpcClPktHdrT) dispatcher)
{
    DcRpcClRequest requestReassembled = new DcRpcClRequest {};
    AssignClReassembledValue(requestReassembled, request);
    binary sourceData = $[];
    uint bodyLength = 0;
    ClRpcReassemble(ref map4ClRequestReassemble, ref biggestRequestFragnum, requestReassembled, 80, ref sourceData, ref bodyLength, mapKey); // 80 is the field offset for Request.Body
    requestReassembled.Body = sourceData.Segment(80, bodyLength as int);
    requestReassembled.SourceData = sourceData;
    requestReassembled.AssignFieldEncodingInfo("Body", 80 * 8, bodyLength * 8 as int);
    dispatcher(requestReassembled); // dispatch to upper accepts
}

void ClResponseReassemble(ref map<string, array<DcRpcClPktHdrT>> map4ClResponseReassemble, ref map<string, ushort> biggestResponseFragnum, DcRpcClPktHdrT response, string mapKey, void(DcRpcClPktHdrT) dispatcher)
{
    DcRpcClResponse responseReassembled = new DcRpcClResponse {};
    AssignClReassembledValue(responseReassembled, response);
    binary sourceData = $[];
    uint bodyLength = 0;
    ClRpcReassemble(ref map4ClResponseReassemble, ref biggestResponseFragnum, responseReassembled, 80, ref sourceData, ref bodyLength, mapKey); // 80 is the field offset for Response.Body
    responseReassembled.Body = sourceData.Segment(80, bodyLength as int);
    responseReassembled.SourceData = sourceData;
    responseReassembled.AssignFieldEncodingInfo("Body", 80 * 8, bodyLength * 8 as int);
    dispatcher(responseReassembled); // dispatch to upper issues
}

void AssignClReassembledValue(DcRpcClPktHdrT clRpcReassembled, DcRpcClPktHdrT clRpcMsg)
{
    clRpcReassembled.RpcVers = clRpcMsg.RpcVers;
    clRpcReassembled.PType = clRpcMsg.PType;
    clRpcReassembled.Flags1 = (clRpcMsg.Flags1 & 0xF9) as byte;// Set RpcClPktHdrFlag1.Frag and RpcClPktHdrFlag1.Lastfrag as 0
    clRpcReassembled.Flags2 = clRpcMsg.Flags2;
    clRpcReassembled.Drep = clRpcMsg.Drep;
    clRpcReassembled.SerialHi = 0;
    clRpcReassembled.Object = clRpcMsg.Object;
    clRpcReassembled.IfId = clRpcMsg.IfId;
    clRpcReassembled.ActId = clRpcMsg.ActId;
    clRpcReassembled.ServerBoot = clRpcMsg.ServerBoot;
    clRpcReassembled.IfVers = clRpcMsg.IfVers;
    clRpcReassembled.Seqnum = clRpcMsg.Seqnum;
    clRpcReassembled.Opnum = clRpcMsg.Opnum;
    clRpcReassembled.Ihint = clRpcMsg.Ihint;
    clRpcReassembled.Ahint = clRpcMsg.Ahint;
    clRpcReassembled.Len = 0; // Length of 'Body' field
    clRpcReassembled.Fragnum = 0;
    clRpcReassembled.AuthProto = clRpcMsg.AuthProto;
    clRpcReassembled.SerialLo = 0;
}

void ClRpcReassemble(ref map<string, array<DcRpcClPktHdrT>> map4ClReassemble, ref map<string, ushort> biggestFragnum, DcRpcClPktHdrT clRpcMsgReassembled, int dataOffset4Reassembly, ref binary sourceData, ref uint bodyLength, string key)
{
    map<ushort, DcRpcClPktHdrT> cachedFrames = {};
    foreach (DcRpcClPktHdrT frag in map4ClReassemble[key])
    {
        if (!(frag.Fragnum in cachedFrames) && !(frag is DcRpcClFack))
        {
            cachedFrames[frag.Fragnum] = frag;
        }
        else if (!(frag is DcRpcClFack))
        {
            frag#Retransmission = true;
        }
        clRpcMsgReassembled.Origins += [frag];
    }
    for (int i = 0; i <= biggestFragnum[key]; i++)
    {
        DcRpcClPktHdrT frag = cachedFrames[i as ushort];
        bodyLength += frag.Len;
        if (sourceData.Count == 0)
        {
            sourceData += (frag.SourceData as binary).Segment(0, (dataOffset4Reassembly + frag.Len) as int);
        }
        else
        {
            sourceData += (frag.SourceData as binary).Segment(dataOffset4Reassembly, frag.Len as int);
        }
    }
    
    // the field Len is ushort, and max value is 65536, normally the Len is less than 65528, so if bodyLength larger than actual value when reassemble connectionless pdu, let Len = 0 as pseudo.
    if (bodyLength <= 65528)
    {
        clRpcMsgReassembled.Len = bodyLength as ushort;
    }
    else
    {
        clRpcMsgReassembled.Len = 0;
    }
    AssignClFieldEncodingInfo(clRpcMsgReassembled, sourceData);
    map4ClReassemble = map4ClReassemble.Remove(key);
    biggestFragnum = biggestFragnum.Remove(key);
}

/*--------------------------------Utility annotations and functions -----------------------------------------------*/

annotation bool DcRpcClPktHdrT#Retransmission; // for diagnosis column value of connectionless RPC messages
annotation guid RpcconnCommonHdrT#PContextUuid;// for display summary for connection oriented RPC messages

string UuidToText(guid u)
{
    return "{" + u.ToString() + "}";
}

const guid NDR64TransferSyntaxIdentifier = {71710533-BEBA-4937-8319-B5DBEF9CCC36};
const uint NDR64TransferSyntaxVersion = 0x00000001;

const guid NDRTransferSyntaxIdentifier = {8A885D04-1CEB-11C9-9FE8-08002B104860};
const uint NDRTransferSyntaxVersion = 0x00000002;

// The annotation will be attached to MSRPCE message and upper layer messages
annotation ushort RpcOpnum;

// The decoding function decode a message T and return it as any if success, otherwize throw exception
any MsrpceMessageDecoder<T>(binary data, NdrInfo ndrInfo, string protocolName, string errorMsg)
{
    // Future Reference: the parameter ndrInfo is not added yet
    //var m = NdrDecoder<T>(data, ndrInfo);
    optional T m = NdrDecoder<T>(data);
    if (m == nothing)
    {
        ThrowDecodingException(protocolName, errorMsg);
    }
    return m as T;
}

string GetRPCUuidString(guid uuid)
{
    switch(uuid)
    {
        case {1FF70682-0A51-30E8-076D-740BE8CEE98B} => return "ATSvc (TSCH)";
        case {86D35949-83C9-4044-B424-DB363231FD0C} => return "SchRpc (TSCH)";
        case {0b1c2170-5732-4e0e-8cd3-d9b16f3b84d7} => return "authzr (RAA)";
        case {3DDE7C30-165D-11D1-AB8F-00805F14DB40} => return "BackupKey (BKRP)";
        case {E3D0D746-D2AF-40FD-8A7A-0D7078BB7092} => return "BitsPeerAuth (BPAU)";
        case {6BFFD098-A112-3610-9833-012892020162} => return "Browser (BRWSA)";
        case {B97DB8B2-4C63-11CF-BFF6-08002BE23F2F} => return "CMRP (CMRP)";
        case {333A2276-0000-0000-0D00-00809C000000} => return "Conv (MSRPC)";
        case {6BFFD098-A112-3610-9833-46C3F874532D} => return "DHCPM (DHCPM)";
        case {5b821720-f63b-11d0-aad2-00c04fc324db} => return "DHCPM (DHCPM)";
        case {4BB8AB1D-9EF9-4100-8EB6-DD4B4E418B72} => return "IADProxy (DFSRH)";
        case {C4B0C7D9-ABE0-4733-A1E1-9FDEDF260C7A} => return "IADProxy2 (DFSRH)";
        case {E65E8028-83E8-491b-9AF7-AAF6BD51A0CE} => return "IServerHealthReport (DFSRH)";
        case {20D15747-6C48-4254-A358-65039FD8C63C} => return "IServerHealthReport2 (DFSRH)";
        case {12108A88-6858-4467-B92F-E6CF4568DFB6} => return "IClusterStorage2 (CSVP)";
        case {2931C32C-F731-4c56-9FEB-3D5F1C5E72BF} => return "IClusterNetwork2 (CSVP)";
        case {D6105110-8917-41A5-AA32-8E0AA2933DC9} => return "IClusterCleanup (CSVP)";
        case {491260B5-05C9-40D9-B7F2-1F7BDAE0927F} => return "IClusterSetup (CSVP)";
        case {85923CA7-1B6B-4E83-A2E4-F5BA3BFBB8A3} => return "IClusterLog (CSVP)";
        case {8165B19E-8D3A-4D0B-80C8-97DE310DB583} => return "IServicedComponentInfo (IOI)";
        case {C3FCC19E-A970-11D2-8B5A-00A0C9B7C9C4} => return "IManagedObject (IOI)";
        case {6619A740-8154-43BE-A186-0319578E02DB} => return "IRemoteDispatch (IOI)";
        case {97199110-DB2E-11D1-A251-0000F805CA53} => return "ITransactionStream (COM)";
        case {4D9F4AB8-7D1C-11CF-861E-0020AF6E7C57} => return "IActivation (DCOM)";
        case {99FCFEC4-5260-101B-BBCB-00AA0021347A} => return "IObjectExporter (DCOM)";
        case {000001A0-0000-0000-C000-000000000046} => return "IRemoteSCMActivator (DCOM)";
        case {00000131-0000-0000-C000-000000000046} => return "IRemUnknown (DCOM)";
        case {00000143-0000-0000-C000-000000000046} => return "IRemUnknown2 (DCOM)";
        case {4E6CDCC9-FB25-4FD5-9CC5-C9F4B6559CEC} => return "icomtrackinginfoevents (COMT)";
        case {B60040E0-BCF3-11D1-861D-0080C729264D} => return "igettrackingdata (COMT)";
        case {C2BE6970-DF9E-11D1-8B87-00C04FD7A924} => return "iimport (COMA)";
        case {0E3D6630-B46B-11D1-9D2D-006008B0E5CA} => return "icatalogtableread (COMA)";
        case {971668DC-C3FE-4EA1-9643-0C7230F494A1} => return "iregister2 (COMA)";
        case {A8927A41-D3CE-11D1-8472-006008B0E5CA} => return "icatalogtableinfo (COMA)";
        case {182C40FA-32E4-11D0-818B-00A0C9231C29} => return "icatalogsession (COMA)";
        case {CFADAC84-E12C-11D1-B34C-00C04F990D54} => return "iexport (COMA)";
        case {1F7B1697-ECB2-4CBB-8A0E-75C427F4A6F0} => return "iimport2 (COMA)";
        case {47CDE9A1-0BF6-11D2-8016-00C04FB9988E} => return "icapabilitysupport (COMA)";
        case {6C935649-30A6-4211-8687-C4C83E5FE1C7} => return "icontainercontrol2 (COMA)";
        case {F131EA3E-B7BE-480E-A60D-51CB2785779E} => return "iexport2 (COMA)";
        case {C726744E-5735-4F08-8286-C510EE638FB6} => return "ICatalogUtils2 (COMA)";
        case {456129E2-1078-11D2-B0F9-00805FC73204} => return "icatalogutils (COMA)";
        case {3F3B1B86-DBBE-11D1-9DA6-00805F85CFE3} => return "icontainercontrol (COMA)";
        case {7F43B400-1A0E-4D57-BBC9-6B0C65F7A889} => return "ialternatelaunch (COMA)";
        case {8DB2180E-BD29-11D1-8B7E-00C04FD7A924} => return "iregister (COMA)";
        case {0E3D6631-B46B-11D1-9D2D-006008B0E5CA} => return "icatalogtablewrite (COMA)";
        case {1D118904-94B3-4A64-9FA6-ED432666A7B9} => return "icatalog64bitsupport (COMA)";
        case {98315903-7BE5-11D2-ADC1-00A02463D6E7} => return "IReplicationUtil";
        case {4E14FB9F-2E22-11D1-9964-00C04FBBB345} => return "IEventSystem (COMEV)";
        case {FB2B72A0-7A68-11D1-88F9-0080C7D771BF} => return "IEventClass (COMEV)";
        case {FB2B72A1-7A68-11D1-88F9-0080C7D771BF} => return "IEventClass2 (COMEV)";
        case {4A6B0E15-2E38-11D1-9965-00C04FBBB345} => return "IEventSubscription (COMEV)";
        case {F4A07D63-2E25-11D1-9964-00C04FBBB345} => return "IEnumEventObject (COMEV)";
        case {F89AC270-D4EB-11D1-B682-00805FC79216} => return "IEventObjectCollection (COMEV)";
        case {7FB7EA43-2D76-4EA8-8CD9-3DECC270295E} => return "IEventClass3 (COMEV)";
        case {4A6B0E16-2E38-11D1-9965-00C04FBBB345} => return "IEventSubscription2 (COMEV)";
        case {FBC1D17D-C498-43A0-81AF-423DDD530AF6} => return "IEventSubscription3 (COMEV)";
        case {99CC098F-A48A-4E9C-8E58-965C0AFC19D5} => return "IEventSystem2 (COMEV)";
        case {A0E8F27A-888C-11D1-B763-00C04FB926AF} => return "IEventSystemInitialize (COMEV)";
        case {D2D79DF7-3400-11D0-B40B-00AA005FF586} => return "IDMNotify (DMRP)";
        case {3A410F21-553F-11D1-8E5E-00A0C92C9D5D} => return "IDMRemoteServer (DMRP)";
        case {D2D79DF5-3400-11D0-B40B-00AA005FF586} => return "IVolumeClient (DMRP)";
        case {4BDAFC52-FE6A-11D2-93F8-00105A11164A} => return "IVolumeClient2 (DMRP)";
        case {135698D2-3A37-4D26-99DF-E2BB6AE3AC61} => return "IVolumeClient3 (DMRP)";
        case {DEB01010-3A37-4D26-99DF-E2BB6AE3AC61} => return "IVolumeClient4 (DMRP)";
        case {118610B7-8D94-4030-B5B8-500889788E4E} => return "IEnumVdsObject (VDS)";
        case {6E6F6B40-977C-4069-BDDD-AC710059F8C0} => return "IVdsAdvancedDisk (DMRP)";
        case {8326CD1D-CF59-4936-B786-5EFC08798E25} => return "IVdsAdviseSink (VDS)";
        case {D5D23B6D-5A55-4492-9889-397A3C2D2DBC} => return "IVdsAsync (VDS)";
        case {07E5C822-F00C-47A1-8FCE-B244DA56FD06} => return "IVdsDisk (VDS)";
        case {3B69D7F5-9D94-4648-91CA-79939BA263BF} => return "IVdsPack (VDS)";
        case {10C5E575-7984-4E81-A56B-431F5F92AE42} => return "IVdsProvider (VDS)";
        case {0316560B-5DB4-4ED9-BBB5-213436DDC0D9} => return "IVdsRemovable (VDS)";
        case {0818A8EF-9BA9-40D8-A6F9-E22833CC771E} => return "IVdsService (VDS)";
        case {E0393303-90D4-4A97-AB71-E9B671EE2729} => return "IVdsServiceLoader (VDS)";
        case {9AA58360-CE33-4F92-B658-ED24B14425B8} => return "IVdsSwProvider (VDS)";
        case {88306BB2-E71F-478C-86A2-79DA200A0F11} => return "IVdsVolume (VDS)";
        case {EE2D5DED-6236-4169-931D-B9778CE03DC6} => return "IVdsVolumeMF (VDS)";
        case {4DAA0135-E1D1-40f1-AAA5-3CC1E53221C3} => return "IVdsVolumePlex (VDS)";
        case {2ABD757F-2851-4997-9A13-47D2A885D6CA} => return "IVdsHbaPort (VDS)";
        case {B07FEDD4-1682-4440-9189-A39B55194DC5} => return "IVdsIscsiInitiatorAdapter (VDS)";
        case {38A0A9AB-7CC8-4693-AC07-1F28BD03C3DA} => return "IVdsIscsiInitiatorPortal (VDS)";
        case {0AC13689-3134-47C6-A17C-4669216801BE} => return "IVdsServiceHba (VDS)";
        case {14FBE036-3ED7-4E10-90E9-A5FF991AFF01} => return "IVdsServiceIscsi (VDS)";
        case {B6B22DA8-F903-4BE7-B492-C09D875AC9DA} => return "IVdsServiceUninstallDisk (VDS)";
        case {83BFB87F-43FB-4903-BAA6-127F01029EEC} => return "IVdsSubSystemImportTarget (VDS)";
        case {13B50BFF-290A-47DD-8558-B7C58DB1A71A} => return "IVdsPack2 (VDS)";
        case {40F73C8B-687D-4A13-8D96-3D7F2E683936} => return "IVdsDisk2 (VDS)";
        case {9723F420-9355-42DE-AB66-E31BB15BEEAC} => return "IVdsAdvancedDisk2 (VDS)";
        case {4DBCEE9A-6343-4651-B85F-5E75D74D983C} => return "IVdsVolumeMF2 (VDS)";
        case {538684E0-BA3D-4BC0-ACA9-164AFF85C2A9} => return "IVdsDiskPartitionMF (VDS)";
        case {D68168C9-82A2-4F85-B6E9-74707C49A58F} => return "IVdsVolumeShrink (VDS)";
        case {1BE2275A-B315-4F70-9E44-879B3A2A53F2} => return "IVdsVolumeOnline (VDS)";
        case {B481498C-8354-45F9-84A0-0BDD2832A91F} => return "IVdsVdProvider (VDS)";
        case {4AFC3636-DB01-4052-80C3-03BBCB8D3C69} => return "IVdsServiceInitialization (VDS)";
        case {6788FAF9-214E-4B85-BA59-266953616E09} => return "IVdsVolumeMF3 (VDS)";
        case {D99BDAAE-B13A-4178-9FDB-E27F16B4603E} => return "IVdsHwProvider (VDS)";
        case {90681B1D-6A7F-48E8-9061-31B7AA125322} => return "IVdsDiskOnline (VDS)";
        case {FC5D23E8-A88B-41A5-8DE0-2D2F73C5A630} => return "IVdsServiceSAN (VDS)";
        case {1E062B84-E5E6-4B4B-8A25-67B81E8F13E8} => return "IVdsVDisk (VDS)";
        case {9CBE50CA-F2D2-4BF4-ACE1-96896B729625} => return "IVdsDiskPartitionMF2 (VDS)";
        case {9882F547-CFC3-420B-9750-00DFBEC50662} => return "IVdsCreatePartitionEx (VDS)";
        case {8F4B2F5D-EC15-4357-992F-473EF10975B9} => return "IVdsDisk3 (VDS)";
        case {72AE6713-DCBB-4A03-B36B-371F6AC6B53D} => return "IVdsVolume2 (VDS)";
        case {FA7DF749-66E7-4986-A27F-E2F04AE53772} => return "IVssSnapshotMgmt (SCMP)";
        case {AE1C7110-2F60-11d3-8A39-00C04F72D8E3} => return "IVssEnumObject (SCMP)";
        case {214A0F28-B737-4026-B847-4F9E37D79529} => return "IVssDifferentialSoftwareSnapshotMgmt (SCMP)";
        case {01954E6B-9254-4e6e-808C-C9E05D007696} => return "IVssEnumMgmtObject (SCMP)";
        case {50ABC2A4-574D-40B3-9D66-EE4FD5FBA076} => return "DNSP (DNSP)";
        case {E3514235-4B06-11D1-AB04-00C04FC2DCD2} => return "DRSR (DRSR)";
        case {7c44d7d4-31d5-424c-bd5e-2b3e1f323d22} => return "DSaop (DRSR)";
        case {77DF7A80-F298-11D0-8358-00A024C480A8} => return "DSCOMM (MQDS)";
        case {708CCA10-9569-11D1-B2A5-0060977D8118} => return "DSCOMM2 (MQDS)";
        case {3919286A-B10C-11D0-9BA8-00C04FD92EF5} => return "DSSETUP (DSSP)";
        case {1CBCAD78-DF0B-4934-B558-87839EA501C9} => return "DSROLE";
        case {8D9F4E40-A03D-11CE-8F69-08003E30051B} => return "PNP (PNPR)";
        case {C681D488-D850-11D0-8C52-00C04FD90F7E} => return "EFSRPC (EFSR)";
        case {DF1941C5-fE89-4E79-BF10-463657ACf44D} => return "EFSRPC (EFSR)";
        case {E1AF8308-5D1F-11C9-91A4-08002B14A0FA} => return "EPT (EPMP)";
        case {82273FDC-E32A-18C3-3F78-827929DC23EA} => return "EventLog (EVEN)";
        case {F6BEAFF7-1E19-4FBB-9F8F-B89E2018337C} => return "IEventService (EVEN6)";
        case {5261574A-4572-206E-B268-6B199213B4E4} => return "Exchange Server STORE Async EMSMDB Interface";
        case {A4F1DB00-CA47-1067-B31F-00DD010662DA} => return "Exchange Server STORE EMSMDB Interface";
        case {DA107C01-2B50-44D7-9D5F-BFD4FD8E95ED} => return "Exchange Server STORE ADMIN Interface";
        case {99E64010-B032-11D0-97A4-00C04FD6551D} => return "Exchange Server STORE ADMIN Interface";
        case {89742ACE-A9ED-11CF-9C0C-08002BE7AE86} => return "Exchange Server STORE ADMIN Interface";
        case {A4F1DB00-CA47-1067-B31E-00DD010662DA} => return "Exchange Server STORE ADMIN Interface";
        case {D99E6E71-FC88-11D0-B498-00A0C90312F3} => return "ICertAdminD (CSRA)";
        case {7FE0D935-DDA6-443F-85D0-1CFB58FE41DD} => return "ICertAdminD2 (CSRA)";
        case {91AE6020-9E3C-11CF-8D7C-00AA00C091BE} => return "ICPR (ICPR)";
        case {D99E6E70-FC88-11D0-B498-00A0C90312F3} => return "ICertRequestD (WCCE)";
        case {5422FD3A-D4B8-4CEF-A12E-E87D4CA22E90} => return "ICertRequestD2 (WCCE)";
        case {00020400-0000-0000-C000-000000000046} => return "IDispatch (OAUT)";
        case {00020404-0000-0000-C000-000000000046} => return "IEnumVariant (OAUT)";
        case {0000002F-0000-0000-C000-000000000046} => return "IID_IRecordInfo (OAUT)";
        case {00020403-0000-0000-C000-000000000046} => return "IID_ITypeComp (OAUT)";
        case {00020401-0000-0000-C000-000000000046} => return "IID_ITypeInfo (OAUT)";
        case {00020412-0000-0000-C000-000000000046} => return "IID_ITypeInfo2 (OAUT)";
        case {00020402-0000-0000-C000-000000000046} => return "IID_ITypeLib (OAUT)";
        case {00020411-0000-0000-C000-000000000046} => return "IID_ITypeLib2 (OAUT)";
        case {E8FB8620-588F-11D2-9D61-00C04F79C5FE} => return "IIisServiceControl (IISS)";
        case {70B51430-B6CA-11D0-B9B9-00A0C922E750} => return "IMSAdminBaseW (IMSA)";
        case {8298D101-F992-43B7-8ECA-5052D885B995} => return "IMSAdminBase2W (IMSA)";
        case {F612954D-3B0B-4C56-9563-227B7BE624B4} => return "IMSAdminBase3W (IMSA)";
        case {29822AB8-F302-11D0-9953-00C04FD919C1} => return "IWamAdmin2";
        case {29822AB7-F302-11D0-9953-00C04FD919C1} => return "IWamAdmin";
        case {7C4E1804-E342-483D-A43E-A850CFCC8D18} => return "IIISApplicationAdmin";
        case {BD0C73BC-805B-4043-9C30-9A28D64DD7D2} => return "IIISCertObj";
        case {82AD4280-036B-11CF-972C-00AA006887B0} => return "INetInfo (INETINFO)";
        case {833E4100-AFF7-4AC3-AAC2-9F24C1457BCE} => return "IPCHCollection (RAI)";
        case {833E4200-AFF7-4AC3-AAC2-9F24C1457BCE} => return "IPCHService (RAI)";
        case {833E41AA-AFF7-4AC3-AAC2-9F24C1457BCE} => return "ISAFSession (RAI)";
        case {F120A684-B926-447F-9DF4-C966CB785648} => return "IRASrv (RAI)";
        case {6099FC12-3EFF-11D0-ABD0-00C04FD91A4E} => return "FaxClient (FAX)";
        case {EA0A3165-4834-11D2-A6F8-00C04FA346CC} => return "Fax (FAX)";
        case {D049B186-814F-11D1-9A3C-00C04FC9B232} => return "FrsApi (FRS1)";
        case {F5CC59B4-4264-101A-8C59-08002B2F8426} => return "FrsRpc (FRS1)";
        case {AFC07E2E-311C-4435-808C-C483FFEEC7C9} => return "Lsacap (CAPR)";
        case {12345778-1234-ABCD-EF00-0123456789AB} => return "LSARpc (LSAT/LSAD)";
        case {AFA8BD80-7D8A-11C9-BEF4-08002B102989} => return "MGMT(MSRPC)";
        case {BF6DD426-77B4-44B3-984E-D413FC075562} => return "Microsoft Information Store";
        case {0E4A0156-DD5D-11D2-8C2F-00C04FB6BCDE} => return "Microsoft Information Store";
        case {1453C42C-0FA6-11D2-A910-00C04F990F3B} => return "Microsoft Information Store";
        case {A9E05B20-6F57-4E24-A540-52412017E6FF} => return "Microsoft Information Store";
        case {10F24E8E-0FA6-11D2-A910-00C04F990F3B} => return "Microsoft Information Store";
        case {17FDD703-1827-4E34-79D4-24A55C53BB37} => return "MSGSVC (MSRP)";
        case {5A7B91F8-FF00-11D0-A9B2-00C04FB6E6FC} => return "MSGSVCSend (MSRP)";
        case {1544F5E0-613C-11D1-93DF-00C04FD7BD09} => return "MS Exchange Directory RFR";
        case {3CB4BE69-9BA1-448C-9A44-A1F759A1878A} => return "MS Exchange Recipient Update Service RPC";
        case {F930C514-1215-11D3-99A5-00A0C9B61B04} => return "MS Exchange System Attendant Cluster Interface";
        case {83D72BF0-0D89-11CE-B13F-00AA003BAC6C} => return "MS Exchange System Attendant Private Interface";
        case {469D6EC0-0D87-11CE-B13F-00AA003BAC6C} => return "MS Exchange System Attendant Public Interface";
        case {F5CC5A18-4264-101A-8C59-08002B2F8426} => return "MS NT Directory NSP (NSPI)";
        case {12345678-1234-ABCD-EF00-01234567CFFB} => return "Netlogon (NRPC)";
        case {906B0CE0-C70B-1067-B317-00DD010662DA} => return "OleTx (CMPO)";
        case {DA5A86C5-12C2-4943-AB30-7F74A813D853} => return "PerfLibV2 (PCQ)";
        case {76F03F96-CDFD-44FC-A22C-64950A001209} => return "IRemoteWinspool (PAR)";
        case {0B6EDBFA-4A24-4FC6-8A23-942B1ECA65D1} => return "IRPCAsyncNotify (PAN)";
        case {AE33069B-A2A8-46EE-A235-DDFD339BE281} => return "IRPCRemoteObject (PAN)";
        case {1A9134DD-7B39-45BA-AD88-44D01CA47F28} => return "RemoteRead (MQRR)";
        case {2F5F6521-CA47-1068-B319-00DD010662DB} => return "remotesp (TRP)";
        case {2F5F6520-CA46-1067-B319-00DD010662DA} => return "tapsrv (TRP)";
        case {E33C0CC4-0482-101A-BC0C-02608C6BA218} => return "LocToLoc (RPCL)";
        case {894DE0C0-0D55-11D3-A322-00C04FA321A1} => return "InitShutdown (RSP)";
        case {D95AFE70-A6D5-4259-822E-2C84DA1DDB0D} => return "WindowsShutdown (RSP)";
        case {4E934F30-341A-11D1-8FB1-00A024CB6019} => return "INtmsLibraryControl1 (RSMP)";
        case {D02E4BE0-3419-11D1-8FB1-00A024CB6019} => return "INtmsMediaServices1 (RSMP)";
        case {BB39332C-BFEE-4380-AD8A-BADC8AFF5BB6} => return "INtmsNotifySink (RSMP)";
        case {69AB7050-3059-11D1-8FAF-00A024CB6019} => return "INtmsObjectInfo1 (RSMP)";
        case {B057DC50-3059-11D1-8FAF-00A024CB6019} => return "INtmsObjectManagement1 (RSMP)";
        case {8DA03F40-3419-11D1-8FB1-00A024CB6019} => return "INtmsSession1 (RSMP)";
        case {879C8BBE-41B0-11d1-BE11-00C04FB6BF70} => return "IClientSink (RSMP)";
        case {081E7188-C080-4FF3-9238-29F66D6CABFD} => return "IMessenger (RSMP)";
        case {DB90832F-6910-4D46-9F5E-9FD6BFA73903} => return "INtmsLibraryControl2 (RSMP)";
        case {895A2C86-270D-489D-A6C0-DC2A9B35280E} => return "INtmsObjectManagement2 (RSMP)";
        case {3BBED8D9-2C9A-4B21-8936-ACB2F995BE6C} => return "INtmsObjectManagement3 (RSMP)";
        case {7D07F313-A53F-459A-BB12-012C15B1846E} => return "IRobustNtmsMediaServices1 (RSMP)";
        case {12345778-1234-ABCD-EF00-0123456789AC} => return "Samr (SAMR)";
        case {378E52B0-C0A9-11CF-822D-00AA0051E40F} => return "SaSec (TSCH)";
        case {4B324FC8-1670-01D3-1278-5A47BF6EE188} => return "srvs (SRVS)";
        case {367ABB81-9844-35F1-AD32-98F038001003} => return "scmr (SCMR)";
        case {4DA1C422-943D-11D1-ACAE-00C04FC2AA3F} => return "TrkSvr (DLTM)";
        case {300F3532-38CC-11D0-A3F0-0020AF6B0ADD} => return "TrkWks (DLTM)";
        case {8FB6D884-2388-11D0-8C35-00C04FDA2795} => return "W32Time (W32T)";
        case {338CD001-2244-31F1-AAAA-900038001003} => return "winreg (RRP)";
        case {12345678-1234-ABCD-EF00-0123456789AB} => return "WINSPOOL (RPRN)";
        case {6BFFD098-A112-3610-9833-46C3F87E345A} => return "WKSSVC (WKST)";
        case {6C19BE32-7500-11D1-AD94-00C04FD8FDFF} => return "IWbemMetaData (WMIRP)";
        case {755F9DA6-7508-11D1-AD94-00C04FD8FDFF} => return "IWbemMultiTarget (WMIRP)";
        case {755F9DA7-7508-11D1-AD94-00C04FD8FDFF} => return "IWbemEventProviderRequirements (WMIRP)";
        case {37196B38-CCCF-11D2-B35C-00105A1F8177} => return "IWbemSmartMultiTarget (WMIRP)";
        case {37196B39-CCCF-11D2-B35C-00105A1F8177} => return "IWbemFetchSmartMultiTarget (WMIRP)";
        case {60E512D4-C47B-11D2-B338-00105A1F4AAF} => return "IWbemFilterProxy (WMIRP)";
        case {6C19BE34-7500-11D1-AD94-00C04FD8FDFF} => return "IWbemFilterStub (WMIRP)";
        case {04963311-C399-408E-AD51-05D01506EED0} => return "IWmiObjectSinkSecurity (WMIRP)";
        case {F1E9C5B2-F59B-11D2-B362-00105A1F8177} => return "IWbemRemoteRefresher (WMIRP)";
        case {2C9273E0-1DC3-11D3-B364-00105A1F8177} => return "IWbemRefreshingServices (WMIRP)";
        case {423EC01E-2E35-11D2-B604-00104B703EFD} => return "IWbemWCOSmartEnum (WMIRP)";
        case {1C1C45EE-4395-11D2-B60B-00104B703EFD} => return "IWbemFetchSmartEnum (WMIRP)";
        case {D4781CD6-E5D3-44DF-AD94-930EFE48A887} => return "IWbemLoginClientID (WMIRP)";
        case {92B9503D-19C3-4181-9F42-57FFC1A4BF37} => return "IWinmgmtMofCompilerOOP (WMIRP)";
        case {2A504CA2-CA90-4731-87BC-6E99CA2019AF} => return "IWmiProvSSSink (WMIRP)";
        case {E8107BDF-BAAF-4C7C-BB5F-9D732E8D8F07} => return "IWmiProvSS (WMIRP)";
        case {07435309-D440-41B7-83F3-EB82DB6C622F} => return "IWmiProviderHost (WMIRP)";
        case {21CD80A2-B305-4F37-9D4C-4534A8D9B568} => return "IWmiProviderFactory (WMIRP)";
        case {BAC6B661-167E-4957-AD77-286AB256585E} => return "IWmiDynamicPropertyResolver (WMIRP)";
        case {5FBA5051-3124-4112-B723-46BFBAF1D622} => return "IWmiProviderInitialize (WMIRP)";
        case {B1B55910-8BA0-47A5-A16E-2B733B1D987C} => return "IWmiProviderStack (WMIRP)";
        case {06413D98-405C-4A5A-8D6F-19B8B7C6ACF7} => return "IWmiProviderFactoryInitialize (WMIRP)";
        case {FEC1B0AC-5808-4033-A915-C0185934581E} => return "IWmiProviderSite (WMIRP)";
        case {EB658B8A-7A64-4DDC-9B8D-A92610DB0206} => return "IWmiProviderQuota (WMIRP)";
        case {48FF3109-A366-4B56-B340-01FAE758BA64} => return "IWmiProviderAbnormalShutdown (WMIRP)";
        case {F0E4EDDE-475A-498A-93D7-D4347F68A8F3} => return "IWmiProviderCache (WMIRP)";
        case {6B3FC272-BF37-4968-933A-6DF9222A2607} => return "IWmiProviderConfiguration (WMIRP)";
        case {484E3ECE-1F81-4591-B9D4-943BA13B609D} => return "IWmiProviderLoad (WMIRP)";
        case {41AA40E6-2FBA-4E80-ADE9-34306567206D} => return "IWmiProviderSubsystemRegistrar (WMIRP)"; 
        case {B60EF4F1-A411-462B-B51E-477CBDBB90B4} => return "IWbemRefresherMgr (WMIRP)";
        case {6963B029-B969-40AA-9180-2B2F84075973} => return "IWbemFetchRefresherMgr (WMIRP)";
        case {25411283-46FC-4326-8DF2-FF5D34B2DFEF} => return "IWbemConfigureRefreshingSvcs (WMIRP)";
        case {6919DD07-1637-4611-A8A7-C16FAC5B2D53} => return "Internal_IWbemProviderInit (WMIRP)";
        case {2B322B6E-A9DF-44E3-97BF-259E3583FDA4} => return "Internal_IWbemProviderIdentity (WMIRP)";
        case {F50A28CF-5C9C-4F7E-9D80-E25E16E18C59} => return "Internal_IWbemServices (WMIRP)";
        case {2DB9FA90-9973-46CF-B310-9865B644699D} => return "Internal_IWbemObjectSink (WMIRP)";
        case {AC9EA02A-2C8A-4ACD-B562-D7E8EBEE8E8E} => return "Internal_IEnumWbemClassObject (WMIRP)";
        case {11CAA957-4E80-474E-A819-7FD72148ADA9} => return "Internal_IWbemPropertyProvider (WMIRP)";
        case {FD450835-CF1B-4C87-9FD2-5E0D42FDE081} => return "Internal_IWbemEventProvider (WMIRP)";
        case {DF2373F5-EFB2-475C-AD58-3102D61967D4} => return "Internal_IWbemEventProviderSecurity (WMIRP)";
        case {854D745C-6742-42C0-8BB9-01EC466B6E87} => return "Internal_IWbemEventConsumerProvider (WMIRP)";
        case {88F3781C-6902-4647-9A6B-A74F450AF861} => return "Internal_IWbemEventConsumerProviderEx (WMIRP)";
        case {8A0DC377-A9D3-41CB-BD69-AE1FDAF2DC68} => return "Internal_IWbemEventProviderQuerySink (WMIRP)";
        case {A210BFE9-C9F7-4919-B114-0D98B3D5341E} => return "Internal_IWbemUnboundObjectSink (WMIRP)";
        case {0FC8C622-1728-4149-A57F-AD19D0970710} => return "Internal_IWmiProviderConfiguration (WMIRP)";
        case {E246107B-B06E-11D0-AD61-00C04FD8FDFF} => return "IWbemUnboundObjectSink (WMIRP)";
        case {E245105B-B06E-11D0-AD61-00C04FD8FDFF} => return "IWbemEventProvider (WMIRP)";
        case {580ACAF8-FA1C-11D0-AD72-00C04FD8FDFF} => return "IWbemEventProviderQuerySink (WMIRP)";
        case {631F7D96-D993-11D2-B339-00105A1F4AAF} => return "IWbemEventProviderSecurity (WMIRP)";
        case {631F7D97-D993-11D2-B339-00105A1F4AAF} => return "IWbemProviderIdentity (WMIRP)";
        case {E246107A-B06E-11D0-AD61-00C04FD8FDFF} => return "IWbemEventConsumerProvider (WMIRP)";
        case {1BE41571-91DD-11D1-AEB2-00C04FB68820} => return "IWbemProviderInitSink (WMIRP)";
        case {1BE41572-91DD-11D1-AEB2-00C04FB68820} => return "IWbemProviderInit (WMIRP)";
        case {7EC196FE-7005-11D1-AD90-00C04FD8FDFF} => return "IWbemQualifierSetv (WMIRP)";
        case {7C857801-7381-11CF-884D-00AA004B2E24} => return "IWbemObjectSink (WMIRP)";
        case {027947E1-D731-11CE-A357-000000000001} => return "IEnumWbemClassObject (WMIRP)";
        case {44ACA675-E8FC-11D0-A07C-00C04FB68820} => return "IWbemCallResult (WMIRP)";
        case {9556DC99-828C-11CF-A37E-00AA003240C7} => return "IWbemServices (WMIRP)";
        case {C1E2D759-CABD-11D3-A11B-00105A1F515A} => return "IWbemRawSdAccessor (WMIRP))";
        case {B7B31DF9-D515-11D3-A11C-00105A1F515A} => return "IWbemShutdown (WMIRP))";
        case {1CFABA8C-1523-11D1-AD79-00C04FD8FDFF} => return "IUnsecuredApartment (WMIRP)";
        case {C49E32C7-BC8B-11D2-85D4-00105A1F8304} => return "IWbemBackupRestore (WMIRP)";
        case {A359DEC5-E813-4834-8A2A-BA7F1D777D76} => return "IWbemBackupRestoreEx (WMIRP)";
        case {CE61E841-65BC-11D0-B6BD-00AA003240C7} => return "IWbemPropertyProvider (WMIRP)";
        case {3AE0080A-7E3A-4366-BF89-0FEEDC931659} => return "IWbemEventSink (WMIRP)";
        case {F309AD18-D86A-11D0-A075-00C04FB68820} => return "IWbemLevel1Login (WMIRP)";
        case {D8EC9CB1-B135-4F10-8B1B-C7188BB0D186} => return "IWbemConnectorLogin (WMIRP)";
        case {17CF534A-D8A3-4AD0-AC92-5E3D01717151} => return "IWbemEventConsumerProviderEx (WMIRP)";
        case {75ABD540-F492-4161-86A5-37FC8898F69E} => return "IWbemSecureObjectSink (WMIRP)";
        case {541679AB-2E5F-11d3-B34E-00104BCC4B4A} => return "IWbemLoginHelper (WMIRP)";
        case {FDB3A030-065F-11D1-BB9B-00A024EA5525} => return "QMCOMM (MQMP)";
        case {76D12B80-3467-11D3-91FF-0090272F9EA3} => return "QMCOMM2 (MQMP)";
        case {1088A980-EAE5-11D0-8D9B-00A02453C337} => return "QM2QM (MQQP)";
        case {41208EE0-E970-11D1-9B9E-00E02C064C39} => return "QMMGMT (MQMR)";
        case {71710533-BEBA-4937-8319-B5DBEF9CCC36} => return "NDR64";
        case {8A885D04-1CEB-11C9-9FE8-08002B104860} => return "NDR";
        case {897e2e5f-93f3-4376-9c9c-fd2277495c27} => return "FRS2 (FRS2)";
        case {6b5bdd1e-528c-422c-af8c-a4079be4fe48} => return "FASP (FASP)";
        case {4FC742E0-4A10-11CF-8273-00AA004AE673} => return "netdfs (DFSNMGMT)";
        case {03837520-098B-11D8-9414-505054503030} => return "IDataCollectorSet (PLA)";
        case {03837541-098B-11D8-9414-505054503030} => return "IDataManager (PLA)";
        case {03837543-098B-11D8-9414-505054503030} => return "IFolderAction (PLA)";
        case {03837544-098B-11D8-9414-505054503030} => return "IFolderActionCollection (PLA)";
        case {038374FF-098B-11D8-9414-505054503030} => return "IDataCollector (PLA)";
        case {03837506-098B-11D8-9414-505054503030} => return "IPerformanceCounterDataCollector (PLA)";
        case {03837514-098B-11D8-9414-505054503030} => return "IConfigurationDataCollector (PLA)";
        case {03837516-098B-11D8-9414-505054503030} => return "IAlertDataCollector (PLA)";
        case {0383750B-098B-11D8-9414-505054503030} => return "ITraceDataCollector (PLA)";
        case {0383751A-098B-11D8-9414-505054503030} => return "IApiTracingDataCollector (PLA)";
        case {03837512-098B-11D8-9414-505054503030} => return "ITraceDataProvider (PLA)";
        case {0383753A-098B-11D8-9414-505054503030} => return "ISchedule (PLA)";
        case {03837510-098B-11D8-9414-505054503030} => return "ITraceDataProviderCollection (PLA)";
        case {0383753D-098B-11D8-9414-505054503030} => return "IScheduleCollection (PLA)";
        case {03837502-098B-11D8-9414-505054503030} => return "IDataCollectorCollection (PLA)";
        case {03837524-098B-11D8-9414-505054503030} => return "IDataCollectorSetCollection (PLA)";
        case {03837533-098B-11D8-9414-505054503030} => return "IValueMapItem (PLA)";
        case {03837534-098B-11D8-9414-505054503030} => return "IValueMap (PLA)";
        case {44e265dd-7daf-42cd-8560-3cdb6e7a2729} => return "TSGU (TSGU)";
        case {11899a43-2b68-4a76-92e3-a3d6ad8c26ce} => return "TermSrvNotification (TSTS)";
        case {484809d6-4239-471b-b5bc-61df8c23ac48} => return "TermSrvSession (TSTS)";
        case {bde95fdf-eee0-45de-9e12-e5a61cd0d4fe} => return "RCMPublic (TSTS)";
        case {88143fd0-c28d-4b2b-8fef-8d882f6a9390} => return "TermSrvEnumeration (TSTS)";
        case {497d95a6-2d27-4bf5-9bbd-a6046957133c} => return "RCMListener (TSTS)";
        case {2f59a331-bf7d-48cb-9e5c-7c090d76e8b8} => return "LCRPC (TSTS)";
        case {5ca4a760-ebb1-11cf-8611-00a0245420ed} => return "IcaApi (TSTS)";
        case {D3FBB514-0E3B-11CB-8FAD-08002B1D29C3} => return "NsiC (RPCL)";
        case {D6D70EF0-0E3B-11CB-ACC3-08002B1D29C4} => return "NsiM (RPCL)";
        case {D6D70EF0-0E3B-11CB-ACC3-08002B1D29C3} => return "NsiS (RPCL)";
        case {8f09f000-b7ed-11ce-bbd2-00001a181cad} => return "ROUTER (RRASM)";
        case {F5CC5A7C-4264-101A-8C59-08002B2F8426} => return "Rxds (RXDS)";
        case {F76FBF3B-8DDD-4B42-B05A-CB1C3FF1FEE8} => return "IFsrmCollection (FSRM)";
        case {1BB617B8-3886-49DC-AF82-A6C90FA35DDA} => return "IFsrmMutableCollection (FSRM)";
        case {96DEB3B5-8B91-4A2A-9D93-80A35D8AA847} => return "IFsrmCommittableCollection (FSRM)";
        case {6CD6408A-AE60-463B-9EF1-E117534D69DC} => return "IFsrmAction (FSRM)";
        case {D646567D-26AE-4CAA-9F84-4E0AAD207FCA} => return "IFsrmActionEmail (FSRM)";
        case {8276702F-2532-4839-89BF-4872609A2EA4} => return "IFsrmActionEmail2 (FSRM)";
        case {2DBE63C4-B340-48A0-A5B0-158E07FC567E} => return "IFsrmActionReport (FSRM)";
        case {4C8F96C3-5D94-4F37-A4F4-F56AB463546F} => return "IFsrmActionEventLog (FSRM)";
        case {12937789-E247-4917-9C20-F3EE9C7EE783} => return "IFsrmActionCommand (FSRM)";
        case {22BCEF93-4A3F-4183-89F9-2F8B8A628AEE} => return "IFsrmObject (FSRM)";
        case {F411D4FD-14BE-4260-8C40-03B7C95E608A} => return "IFsrmSetting (FSRM)";
        case {6F4DBFFF-6920-4821-A6C3-B7E94C1FD60C} => return "IFsrmPathMapper (FSRM)";
        case {EFCB0AB1-16C4-4A79-812C-725614C3306B} => return "IFsrmExportImport (FSRM)";
        case {39322A2D-38EE-4D0D-8095-421A80849A82} => return "IFsrmDerivedObjectsResult (FSRM)";
        case {1568A795-3924-4118-B74B-68D8F0FA5DAF} => return "IFsrmQuotaBase (FSRM)";
        case {42DC3511-61D5-48AE-B6DC-59FC00C0A8D6} => return "IFsrmQuotaObject (FSRM)";
        case {377F739D-9647-4B8E-97D2-5FFCE6D759CD} => return "IFsrmQuota (FSRM)";
        case {F82E5729-6ABA-4740-BFC7-C7F58F75FB7B} => return "IFsrmAutoApplyQuota (FSRM)";
        case {8BB68C7D-19D8-4FFB-809E-BE4FC1734014} => return "IFsrmQuotaMaagern (FSRM)";
        case {A2EFAB31-295E-46BB-B976-E86D58B52E8B} => return "IFsrmQuotaTemplate (FSRM)";
        case {9A2BF113-A329-44CC-809A-5C00FCE8DA40} => return "IFsrmQuotaTemplateImported (FSRM)";
        case {4173AC41-172D-4D52-963C-FDC7E415F717} => return "IFsrmQuotaTemplateManager (FSRM)";
        case {8DD04909-0E34-4D55-AFAA-89E1F1A1BBB9} => return "IFsrmFileGroup (FSRM)";
        case {AD55F10B-5F11-4BE7-94EF-D9EE2E470DED} => return "IFsrmFileGroupImported (FSRM)";
        case {426677D5-018C-485C-8A51-20B86D00BDC4} => return "IFsrmFileGroupManager (FSRM)";
        case {F3637E80-5B22-4A2B-A637-BBB642B41CFC} => return "IFsrmFileScreenBase (FSRM)";
        case {5F6325D3-CE88-4733-84C1-2D6AEFC5EA07} => return "IFsrmFileScreen (FSRM)";
        case {BEE7CE02-DF77-4515-9389-78F01C5AFC1A} => return "IFsrmFileScreenException (FSRM)";
        case {FF4FA04E-5A94-4BDA-A3A0-D5B4D3C52EBA} => return "IFsrmFileScreenManager (FSRM)";
        case {205BEBF8-DD93-452A-95A6-32B566B35828} => return "IFsrmFileScreenTemplate (FSRM)";
        case {E1010359-3E5D-4ECD-9FE4-EF48622FDF30} => return "IFsrmFileScreenTemplateImported (FSRM)";
        case {CFE36CBA-1949-4E74-A14F-F1D580CEAF13} => return "IFsrmFileScreenTemplateManager (FSRM)";
        case {27B899FE-6FFA-4481-A184-D3DAADE8A02B} => return "IFsrmReportManager (FSRM)";
        case {38E87280-715C-4C7D-A280-EA1651A19FEF} => return "IFsrmReportJob (FSRM)";
        case {D8CC81D9-46B8-4FA4-BFA5-4AA9DEC9B638} => return "IFsrmReport (FSRM)";
        case {6879CAF9-6617-4484-8719-71C3D8645F94} => return "IFsrmReportScheduler (FSRM)";
        case {EE321ECB-D95E-48E9-907C-C7685A013235} => return "IFsrmFileManagementJobManager (FSRM)";
        case {0770687E-9F36-4D6F-8778-599D188461C9} => return "IFsrmFileManagementJob (FSRM)";
        case {326AF66F-2AC0-4F68-BF8C-4759F054FA29} => return "IFsrmPropertyCondition (FSRM)";
        case {EDE0150F-E9A3-419C-877C-01FE5D24C5D3} => return "IFsrmPropertyDefinition (FSRM)";
        case {4A73FEE4-4102-4FCC-9FFB-38614F9EE768} => return "IFsrmProperty (FSRM)";
        case {CB0DF960-16F5-4495-9079-3F9360D831DF} => return "IFsrmRule (FSRM)";
        case {AFC052C2-5315-45AB-841B-C6DB0E120148} => return "IFsrmClassificationRule (FSRM)";
        case {515C1277-2C81-440E-8FCF-367921ED4F59} => return "IFsrmPipelineModuleDefinition (FSRM)";
        case {BB36EA26-6318-4B8C-8592-F72DD602E7A5} => return "IFsrmClassifierModuleDefinition (FSRM)";
        case {B15C0E47-C391-45B9-95C8-EB596C853F3A} => return "IFsrmClassificationManager (FSRM)";
        case {21546AE8-4DA5-445E-987F-627FEA39C5E8} => return "iwrmconfig (WSRM)";
        case {481E06CF-AB04-4498-8FFE-124A0A34296D} => return "iwrmcalendar (WSRM)";
        case {4F7CA01C-A9E5-45B6-B142-2332A1339C1D} => return "iwrmaccounting (WSRM)";
        case {59602EB6-57B0-4FD8-AA4B-EBF06971FE15} => return "iwrmpolicy (WSRM)";
        case {BC681469-9DD9-4BF4-9B3D-709F69EFE431} => return "iwrmresourcegroup (WSRM)";
        case {C5CEBEE2-9DF5-4CDD-A08C-C2471BC144B4} => return "iresourcemanager (WSRM)";
        case {F31931A9-832D-481C-9503-887A0E6A79F0} => return "iwrmprotocol (WSRM)";
        case {784B693D-95F3-420B-8126-365C098659F2} => return "IOcspAdminD (OCSPA)";
        case {70184AC9-7673-4770-96B1-445CE035CF70} => return "IAppHostMethodExtension (IISA)";
        case {31A83EA0-C0E4-4A2C-8A01-353CC2A4C60A} => return "IAppHostMappingExtension (IISA)";
        case {0191775E-BCFF-445A-B4F4-3BDDA54E2816} => return "IAppHostPropertyCollection (IISA)";
        case {9BE77978-73ED-4A9A-87FD-13F09FEC1B13} => return "IAppHostAdminManager (IISA)";
        case {450386DB-7409-4667-935E-384DBBEE2A9E} => return "IISAIAppHostPropertySchema (IISA)";
        case {370AF178-7758-4DAD-8146-7391F6E18585} => return "IAppHostConfigLocation (IISA)";
        case {ADA4E6FB-E025-401E-A5D0-C3134A281F07} => return "IAppHostConfigFile (IISA)";
        case {8BED2C68-A5FB-4B28-8581-A0DC5267419F} => return "IAppHostPropertySchemaCollection (IISA)";
        case {832A32F7-B3EA-4B8C-B260-9A2923001184} => return "IAppHostConfigLocationCollection (IISA)";
        case {ED35F7A1-5024-4E7B-A44D-07DDAF4B524D} => return "IAppHostProperty (IISA)";
        case {FA7660F6-7B3F-4237-A8BF-ED0AD0DCBBD9} => return "IAppHostWritableAdminManager (IISA)";
        case {64FF8CCC-B287-4DAE-B08A-A72CBF45F453} => return "IAppHostElement (IISA)";
        case {C8550BFF-5281-4B1E-AC34-99B6FA38464D} => return "IAppHostElementCollection (IISA)";
        case {09829352-87C2-418D-8D79-4133969A489D} => return "IAppHostChangeHandler (IISA)";
        case {B80F3C42-60E0-4AE0-9007-F52852D3DBED} => return "IAppHostMethodInstance (IISA)";
        case {E7927575-5CC3-403B-822E-328A6B904BEE} => return "IAppHostPathMapper (IISA)";
        case {0F80E901-8F4C-449A-BF90-13D5D082F187} => return "IAppHostPathMapper2 (IISA)";
        case {8F6D760F-F0CB-4D69-B5F6-848B33E9BDC6} => return "IAppHostConfigManager (IISA)";
        case {0716CAF8-7D05-4A46-8099-77594BE91394} => return "IAppHostConstantValue (IISA)";
        case {B7D381EE-8860-47A1-8AF4-1F33B2B1F325} => return "IAppHostSectionDefinitionCollection (IISA)";
        case {5B5A68E6-8B9F-45E1-8199-A95FFCCDFFFF} => return "IAppHostConstantValueCollection (IISA)";
        case {0DD8A158-EBE6-4008-A1D9-B7ECC8F1104B} => return "IAppHostSectionGroup (IISA)";
        case {7883CA1C-1112-4447-84C3-52FBEB38069D} => return "IAppHostMethod (IISA)";
        case {DE095DB1-5368-4D11-81F6-EFEF619B7BCF} => return "IAppHostCollectionSchema (IISA)";
        case {EF13D885-642C-4709-99EC-B89561C6BC69} => return "IAppHostElementSchema (IISA)";
        case {D6C7CD8F-BB8D-4F96-B591-D3A5F1320269} => return "IAppHostMethodCollection (IISA)";
        case {518EB37D-1FF4-42DD-86C3-3140BC35B823} => return "IAppHostElementExtension (IISA)";
        case {88E220F3-33E8-4534-AFAC-B4A98ECCF9AE} => return "IAppHostPropertyExtension (IISA)";
        case {08A90F5F-0702-48D6-B45F-02A9885A9768} => return "IAppHostChildElementCollection (IISA)";
        case {4DFA1DF3-8900-4BC7-BBB5-D1A458C52410} => return "IAppHostConfigException (IISA)";
        case {0344CDDA-151E-4CBF-82DA-66AE61E97754} => return "IAppHostElementSchemaCollection (IISA)";
        case {C5C04795-321C-4014-8FD6-D44658799393} => return "IAppHostSectionDefinition (IISA)";
        case {2D9915FB-9D42-4328-B782-1B46819FAB9E} => return "IAppHostMethodSchema (IISA)";
        case {EAFE4895-A929-41EA-B14D-613E23F62B71} => return "IAppHostPropertyException (IISA)";
        case {FF9A1BB6-1E96-11D3-BFCC-00C04FA3490A} => return "ILinkQueue (IISIAQ)";
        case {EA4DFDF2-9E87-4C57-B845-123872C5649F} => return "IUniqueId (IISIAQ)";
        case {3F962F94-1ECD-11D3-BFCC-00C04FA3490A} => return "IVSAQLink (IISIAQ)";
        case {1EB44A71-1E95-11D3-BFCC-00C04FA3490A} => return "IAQMessageAction (IISIAQ)";
        case {476D70A6-1A90-11D3-BFCB-00C04FA3490A} => return "IAQAdmin (IISIAQ)";
        case {BA7AF302-7373-11D2-94E4-00C04FA379F1} => return "IAQEnumMessages (IISIAQ)";
        case {BA7AF300-7373-11D2-94E4-00C04FA379F1} => return "IEnumVSAQLinks (IISIAQ)";
        case {BA7AF303-7373-11D2-94E4-00C04FA379F1} => return "IEnumLinkQueues (IISIAQ)";
        case {E2ED3340-1E96-11D3-BFCC-00C04FA3490A} => return "IVSAQAdmin (IISIAQ)";
        case {BA7AF305-7373-11D2-94E4-00C04FA379F1} => return "IAQMessage (IISIAQ)";
        case {1A927394-352E-4553-AE3F-7CF4AAFCA620} => return "WDSC";
        // start ISA and TMG common
        case {B347203C-14BB-4878-8B7A-0A12F9B8076A} => return "WspAdmin";
        case {A9B96D49-2C75-4917-A178-06B6F08261CC} => return "PrefetcherAPI";
        case {b3df47c0-a95a-11cf-aa26-00aa00c148b9} => return "RwsAdmin";
        case {45FCCD57-C817-418A-90DA-6A00DA164FEB} => return "W3ProxyAdmin";
        case {1A77DCB2-97B3-4ffb-9EE7-8F42529841AB} => return "StgAdmin";
        case {D87F0FF3-CBAA-40A2-AF04-A12BCAF352FA} => return "VpnAuth";
        case {B960D772-4691-483f-A43B-FB3435DA1BE7} => return "ISASCMAdmin";
        // end ISA and TMG common
        // start Forefront TMG
        case {3fb70b3f-e2eb-46fd-9610-8d1ba842d737} => return "ManagedServiceAdmin";
        case {80a74b95-4a73-40b3-83b9-c977a2773647} => return "SmtpProtectionAdmin";
        case {3BC75947-EA23-4502-B4EF-0C0F8D196F1C} => return "ReportingServicesAdmin";
        // end Forefront TMG
        case {ccd8c074-d0e5-4a40-92b4-d074faa6ba28} => return "Witness (SWN)";
        case {A8E0653C-2744-4389-A61D-7373DF8B2292} => return "FileServerVssAgent (FSRVP)";
        default => return "unknown";
    }
}
