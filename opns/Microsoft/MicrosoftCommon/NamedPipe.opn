protocol NamedPipe with
BinaryEncodingDefaults{Endian = Endian.Little},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-SMB2", Date = "07/12/2012", ProgramName = ProgramName.MCPP},
            new Reference{Name = "MS-CIFS", Version = "18.0", ProgramName = ProgramName.WSPP},
            new Reference{Name = "MS-SMB", Version = "37.0", ProgramName = ProgramName.WSPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="1.0.0", Date="09/02/2011"}
        ]
};

using Standard;
using Technologies.Block;
using Utility;
using DTYP;
using ERREF;
using NBTSS;
using WindowsReference;
using TCP;
using IANA;
using VirtualTransport;
using Reassembly;
using MSRPCE;
using NBF;

// ------------------------------------------------------------------
// SMBOverTCP
endpoint Server
    over VirtualTransport.Server
    accepts TransportPacket issues TransportPacket;

client endpoint Client connected to Server;

// Actors
autostart actor NamedPipeOverTCPServer(VirtualTransport.Server server)
{
    DecodingCache inboundCache = null;
    DecodingCache outboundCache = null;
    void AcceptDispatcher(TransportPacket m)
    {
        dispatch (endpoint Server over server) accepts m;
    }
    
    void IssueDispatcher(TransportPacket m)
    {
        dispatch (endpoint Server over server) issues m;
    }

    process server accepts s:VirtualTransport.VirtualDataSegment{DestinationPort is Port.SMB}
    {
        if (inboundCache == null)
        {
            inboundCache = new DecodingCache{Dispatcher = AcceptDispatcher};
        }
        inboundCache.Add(s);
        inboundCache.TryDecodeAndDispatchTransportPacket();
    }
   
    process server issues s:VirtualTransport.VirtualDataSegment{SourcePort is Port.SMB}
    {
        if (outboundCache == null)
        {
            outboundCache = new DecodingCache{Dispatcher = IssueDispatcher};
        }
        outboundCache.Add(s);
        outboundCache.TryDecodeAndDispatchTransportPacket();
    }
    
    ~endpoint(VirtualTransport.Server e)
    {
        if (inboundCache != null)
        {
            inboundCache.Clear();
        }
        if (outboundCache != null)
        {
            outboundCache.Clear();
        }
    }
}

// Message
message TransportPacket
{
    byte Zero where value == 0;
    uint StreamProtocolLength with BinaryEncoding{Width = 24};
    binary SMBMessage with BinaryEncoding{Length = StreamProtocolLength};
    
    override string ToString()
    {
        return "SMBOverTCP, StreamProtocolLength: " + (StreamProtocolLength as string);
    }
} with BinaryEncodingDefaults{Endian = Endian.Big};

type DecodingCache : DecodingCacheBase
{ 
    void(TransportPacket) Dispatcher;
    
    void TryDecodeAndDispatchTransportPacket()
    {
        stream str = Buffer;
        bool msgDecoded = false;
        while (str.RemainingLength > 0)
        {
            var msg = BinaryDecoder<TransportPacket>(str);
            if (msg == nothing)
            {
                if (msgDecoded)
                {
                    /* Reset the Buffer as the decoding failure is caused by insufficient data,
                     * and waiting for the following data.
                     */
                    Reset(str);
                }
                else if ((Buffer[0] != 0) && !HasSegmentLost)
                {
                    /* The data is invalid as the first byte doesn't match,
                     * and it's not caused by TCP segment-lost or the data is still insufficient
                     */
                    Buffer = $[];
                    Origins = [];
                    ThrowDecodingException("NamedPipe", "TransportPacket");
                }
                else if ((Buffer.Segment(5, 3) != $[534D42] && HasSegmentLost)|| HasIncompleteSegments)
                {
                    /* The decoding failed at the first time when trying to decode Buffer,
                     * which is caused by TCP segment-lost.
                     */
                    Clear();
                }
                return;
            }
            else
            {
                var m = msg as TransportPacket;
                m.Origins = Origins;
                Dispatcher(m);
                msgDecoded = true;
            }
        }
        Buffer = $[];
        Origins = [];
    }
    
    override void Clear()
    {
        if (Buffer != null)
        {
            if (Buffer.Count > 4 && Buffer[0] == 0)
            {
                // Dispatch the partical message
                uint streamProtocolLength = Buffer[3] + ((Buffer[2] as uint) << 8) + ((Buffer[1] as uint) << 16);
                    // WORKAROUND: Bug#31792 - [DCR]BinaryDecoder<T>(binary) should support big-endian or little-endian dynamically assigned in runtime decoding.
                    //BinaryDecoder<uint>(Buffer.Segment(0, 4));
                var m = new TransportPacket
                {
                    Zero = 0,
                    StreamProtocolLength = streamProtocolLength,
                    SMBMessage = Buffer.Segment(4),
                };
                m.SourceData = Buffer;
                m.AssignFieldEncodingInfo("Zero", 0, 8);
                m.AssignFieldEncodingInfo("StreamProtocolLength", 8, 24);
                m.AssignFieldEncodingInfo("SMBMessage", 24, m.SMBMessage.Count * 8);
                ReportInsufficientData(m, DiagnosisLevel.Error, "NamedPipe: Data is insufficient for TransportPacket.SMBMessage field due to TCP segment-lost.");
                m.Origins = Origins;
                Dispatcher(m);
            }
            else
            {
                foreach (var m in Origins)
                {
                    ValidationCheckDecodingMessageFailedWithReason(null, "NamedPipe" , "TransportPacket", "TCP segment-lost");
                    DisplayTopLevelMessage(m);
                }
            }
        }
        Origins = [];
        Buffer = $[];
    }
}

// Get the binary value of ProtocolId from NBTSS.SessionService message
binary GetProtocolIdBin(NBTSS.SessionService m)
{
    switch (m.Trailer)
    {
        case p: SessionMessagePacket =>
            if (p.UserData.Count > 4)
            {
                return p.UserData.Segment(0,4);
            }
    }
    return $[];
}

// Get the binary value of ProtocolId from NBTSS.SessionService message
binary GetProtocolIdBin(TransportPacket m)
{
    if (m.SMBMessage.Count > 4)
    {
        return m.SMBMessage.Segment(0, 4);
    }
    return $[];
}

// ------------------------------------------------------------------
// SMB2
const binary SMB2ProtocolId = $[FE534D42];
const binary SMB3EncryptdProtocolId = $[FD534D42];

// Mark if the message is reassembled or not
annotation bool SMB2Messages.ResMessage#IsReassembled;

// Keep the command name for SMB2HeaderOnly message
annotation string SMB2Messages.SMB2HeaderOnly#CommandName;

// Negotiate DialectRevision, some value of SMB2NegotiateResponseDialectRevision
ushort SMB2DialectRevision = 0xFFFF;

// Endpoint ---------------------------
// Top layer endpoint available for the protocol that is assumed that the client and server have a security association usable with named pipes.
endpoint NamedPipeServer
    over NamedPipeReassemblyServer
    provides SMB2Messages;
    
endpoint NamedPipeReassemblyServer[ulong FileId]
    over SMB2Server
    provides SMB2Messages
    accepts SMB2Messages.TransformMessage issues SMB2Messages.TransformMessage
{
    // Keeps the fragmented buffer data
    binary bufferData = $[];
    // Keeps the message origins for the reassembed message
    array<any message> origins = [];
    
    observe this accepts m:SMB2Messages.CloseRequest
    {
        ReleaseOrigins();
    }
    
    process this issues m:SMB2Messages.IoctlResponse
    {
        if (IsNeedReassemble(m.Response.Buffer, GetStatus(m.Header), m))
        {
            if (GetStatus(m.Header) != 0x80000005)
            {
                // Create the reassembled message base on the last message
                var lastRes = m.Response;
                var reponse = new SMB2IoctlResponse
                    {
                        StructureSize = lastRes.StructureSize,
                        Reserved = lastRes.Reserved,
                        CtlCode = lastRes.CtlCode,
                        FileId = lastRes.FileId,
                        InputOffset = lastRes.InputOffset,
                        InputCount = lastRes.InputCount,
                        OutputCount = bufferData.Count as uint,
                        Flags = lastRes.Flags,
                        Reserved2 = lastRes.Reserved2,
                        InputBufferPadding = lastRes.InputBufferPadding,
                        InputBuffer = lastRes.InputBuffer,
                        OutputBufferPadding = lastRes.OutputBufferPadding,
                        Buffer = bufferData
                    };
                var reMsg = new SMB2Messages.IoctlResponse{ Header = m.Header, Response = reponse };
                reMsg.Response.AssignFieldEncodingInfo("Buffer", 0, bufferData.Count * 8);
                reMsg#SMBFileId = m#SMBFileId;
                DispatchReassembledResponse(reMsg, this);
            }
        }
        else
        {
            dispatch (endpoint NamedPipeServer over this) issues m;
        }
    }
    
    process this issues m:SMB2Messages.ReadResponse
    {
        if (IsNeedReassemble(m.Response.Buffer, GetStatus(m.Header), m))
        {
            if (GetStatus(m.Header) != 0x80000005)
            {
                // Create the reassembled message base on the last message
                var lastRes = m.Response;
                var reponse = new SMB2ReadResponse
                    {
                        StructureSize = lastRes.StructureSize,
                        DataOffset = lastRes.DataOffset,
                        Reserved = lastRes.Reserved,
                        DataLength = bufferData.Count as uint,
                        DataRemaining = lastRes.DataRemaining,
                        Reserved2 = lastRes.Reserved2,
                        DataPadding = lastRes.DataPadding,
                        Buffer = bufferData,
                    };
                var reMsg = new SMB2Messages.ReadResponse{Header = m.Header, Response = reponse};
                reMsg.Response.AssignFieldEncodingInfo("Buffer", 0, bufferData.Count * 8);
                reMsg#SMBFileId = m#SMBFileId;
                DispatchReassembledResponse(reMsg, this);
            }
        }
        else
        {
            dispatch (endpoint NamedPipeServer over this) issues m;
        }
    }
    
    process this accepts m:SMB2Messages.ReqMessage 
    {
        dispatch (endpoint NamedPipeServer over this) accepts m;
    }
    
    // Check if the Buffer need reassembled and hold the partial data and the message in cache
    bool IsNeedReassemble(any buffer, optional uint status, any message origin)
    {
        if (buffer is binary && status != nothing)
        {
            // The current message or the message it followed to has returned STATUS_BUFFER_OVERFLOW
            if ((status == 0x80000005) || origins.Count > 0)
            {
                bufferData += (buffer as binary);
                origins += [origin];
                return true;
            }
        }
        return false;
    }

    void DispatchReassembledResponse(SMB2Messages.ResMessage reMsg, NamedPipeReassemblyServer reassemServer)
    {
        reMsg#IsReassembled = true;
        reMsg.SourceData = bufferData;
        reMsg.Origins = origins;
        dispatch (endpoint NamedPipeServer over reassemServer) issues reMsg;
        origins = [];
        bufferData = $[];
    }
    
    // Release the messages stalled in the cache
    void ReleaseOrigins()
    {
        if (origins.Count > 0)
        {
            foreach (var m in origins)
            {
                DisplayTopLevelMessage(m);
            }
            origins = null;
        }
    }
    
    // endpoint destructor
    ~endpoint(NamedPipeReassemblyServer server)
    {
        ReleaseOrigins();
    }
}
    
// Endpoint
endpoint SMB2Server
    over Server | over NBTSS.Server
    provides SMB2Messages
    accepts SMB2Messages.TransformMessage issues SMB2Messages.TransformMessage
{
    // Keeps the Capabilities.SMB2GlobalCapMultiChannel flag bit from NegotiateResponse message.
    // Indicats whether the server supports establishing multiple channels for sessions.
    bool supportsMultiChannel = false;
    // Mark whether it's named pipe or not
    bool? isNamedPipe = null;
    
    // key: MID, value: FID
    map<ulong, ulong> FIDByMID = {};
    
    // Get the values from from NegotiateResponse message
    observe this issues m:SMB2Messages.NegotiateResponse
    {
        supportsMultiChannel =  (m.Response.Capabilities & SMB2NegotiateResponseCapabilities.SMB2GlobalCapMultiChannel) > 0;
    }
    
    // Store the share type for named pipe in the current connection
    observe this issues m:SMB2Messages.TreeConnectResponse
    {
        isNamedPipe = (m.Response.ShareType == SMB2TreeConnectResponseShareType.SMB2ShareTypePipe);
    }
    
   // Dispatch write response and Ioctl response to upper layer.
    process this accepts m:SMB2Messages.WriteRequest where (isNamedPipe == null || isNamedPipe as bool) 
    {
        ulong mid = m.Header.MessageId;
        ulong fid = m.Request.FileId.Persistent;
        FIDByMID[mid] = fid;
        dispatch (endpoint NamedPipeReassemblyServer[fid] over this) accepts m;
    }
    
    process this accepts m:SMB2Messages.IoctlRequest where (isNamedPipe == null || isNamedPipe as bool) 
    {
        ulong mid = m.Header.MessageId;
        ulong fid = m.Request.FileId.Persistent;
        FIDByMID[mid] = fid;
        dispatch (endpoint NamedPipeReassemblyServer[fid] over this) accepts m;
    }
    
    process this accepts m:SMB2Messages.ReadRequest where (isNamedPipe == null || isNamedPipe as bool) 
    {
        ulong mid = m.Header.MessageId;
        ulong fid = m.Request.FileId.Persistent;
        FIDByMID[mid] = fid;
        dispatch (endpoint NamedPipeReassemblyServer[fid] over this) accepts m;
    }
    // Dispatch write request and Ioctl request to upper layer.
    process this issues m:SMB2Messages.ReadResponse where (isNamedPipe == null || isNamedPipe as bool) 
    {
        ulong mid = GetMessageId(m.Header);
        ulong fid = (mid in FIDByMID) ? FIDByMID[mid] : 0;
        m#SMBFileId = fid;
        dispatch (endpoint NamedPipeReassemblyServer[fid] over this) issues m;
        FIDByMID = FIDByMID.Remove(mid);
    }
    
    process this issues m:SMB2Messages.IoctlResponse where (isNamedPipe == null || isNamedPipe as bool) 
    {
        ulong mid = GetMessageId(m.Header);
        ulong fid = (mid in FIDByMID) ? FIDByMID[mid] : 0;
        m#SMBFileId = fid;
        dispatch (endpoint NamedPipeReassemblyServer[fid] over this) issues m;
        FIDByMID = FIDByMID.Remove(mid);
    }
    
    ~endpoint(SMB2Server server)
    {
        FIDByMID = {};
    }
}

// Actor that listens to SessionService messages on both possible directions.
autostart actor SMB2NamedPipeOverNBTSS(NBTSS.Server server)
{
    SMB2DecodingCache dc = new SMB2DecodingCache{};
    
    // Parsing request message
    process server accepts s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchRequestMessages(dc, (s.Trailer as SessionMessagePacket).UserData, server);
    }

    // Parsing response message
    process server issues s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchResponseMessages(dc, (s.Trailer as SessionMessagePacket).UserData, server);
    }

    // Parsing Transform request message
    process server accepts s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        switch ((s.Trailer as SessionMessagePacket).UserData)
        {
            case m:SMB2Messages.TransformMessage from BinaryDecoder<SMB2Messages.TransformMessage> =>
                dispatch (endpoint SMB2Server over server) accepts m;
            default =>
                 ThrowDecodingException("NamedPipe TransformMessage");
        }
    }

    // Parsing Transform response message
    process server issues s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        switch ((s.Trailer as SessionMessagePacket).UserData)
        {
            case m:SMB2Messages.TransformMessage from BinaryDecoder<SMB2Messages.TransformMessage> =>
                dispatch (endpoint SMB2Server over server) accepts m;
            default =>
                 ThrowDecodingException("NamedPipe TransformMessage");
        }
    }
}

// Actor
// Actor that listens to TransportPacket messages on both possible directions.
autostart actor SMB2NamedPipeOverSMB(Server server)
{
    SMB2DecodingCache dc = new SMB2DecodingCache{};
    // Parsing request message
    process server accepts s:TransportPacket where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchRequestMessages(dc, s.SMBMessage, server);
    }

    // Parsing response message
    process server issues s:TransportPacket where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchResponseMessages(dc, s.SMBMessage, server);
    }

    // Parsing Transform request message
    process server accepts s:TransportPacket where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        switch (s.SMBMessage)
        {
            case m:SMB2Messages.TransformMessage from BinaryDecoder<SMB2Messages.TransformMessage> =>
                dispatch (endpoint SMB2Server over server) accepts m;
            default =>
                ThrowDecodingException("NamedPipe Transform");
        }
    }

    // Parsing Transform response message
    process server issues s:TransportPacket where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        switch (s.SMBMessage)
        {
            case m:SMB2Messages.TransformMessage from BinaryDecoder<SMB2Messages.TransformMessage> =>
                dispatch (endpoint SMB2Server over server) issues m;
            default =>
                ThrowDecodingException("NamedPipe Transform");
        }
    }
}

autostart actor MsrpceOverSMB2NamedPipeServer(NamedPipe.NamedPipeServer server)
{
    binary incompleteRequestSourceData = $[];
    binary incompleteResponseSourceData = $[];
    array<any message> requestMsgOrigins = [];
    array<any message> responseMsgOrigins = [];
    
    process server issues s:NamedPipe.SMB2Messages.ReadResponse where incompleteResponseSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Response.Buffer)
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s#SMBFileId == nothing ? 0 : s#SMBFileId as ulong];
        MsrpceProcessSmbMessages(reasseblyServer, s.Response.Buffer, ref incompleteResponseSourceData, GetStatus(s.Header), ref responseMsgOrigins, s, CoReassemblyIssuesDispatcher);
    }

    process server accepts s:NamedPipe.SMB2Messages.WriteRequest where incompleteRequestSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Request.Buffer)
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s.Request.FileId.Persistent];
        MsrpceProcessSmbMessages(reasseblyServer, s.Request.Buffer, ref incompleteRequestSourceData, nothing, ref requestMsgOrigins, s, CoReassemblyAcceptsDispatcher);
    }
    
    process server accepts s:NamedPipe.SMB2Messages.IoctlRequest where (s.Request.Buffer is binary) && (incompleteRequestSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Request.Buffer as binary))
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s.Request.FileId.Persistent];
        MsrpceProcessSmbMessages(reasseblyServer, s.Request.Buffer as binary, ref incompleteRequestSourceData, nothing, ref requestMsgOrigins, s, CoReassemblyAcceptsDispatcher);
    }
    
    process server issues s:NamedPipe.SMB2Messages.IoctlResponse where (s.Response.Buffer is binary) && (incompleteResponseSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Response.Buffer as binary))
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s#SMBFileId == nothing ? 0 : s#SMBFileId as ulong];
        MsrpceProcessSmbMessages(reasseblyServer, s.Response.Buffer as binary, ref incompleteResponseSourceData, GetStatus(s.Header), ref responseMsgOrigins, s, CoReassemblyIssuesDispatcher);
    }
    
    ~endpoint(NamedPipe.NamedPipeServer server)
    {
        MSRPCE.DispatchOriginsToRevive(ref requestMsgOrigins);
        MSRPCE.DispatchOriginsToRevive(ref responseMsgOrigins);
    }
}

contract SMB2Messages
{
    // Base message for all the SMB2 messages except for CancelRequest
    accepts message ReqMessage
    {
        SMB2PacketHeaderSync[true] Header;
    }

    // Base message for all the reponse messages
    issues message ResMessage 
    {
        SMB2PacketHeader Header;
    }

    message TransformMessage
    {
        SMB2TransformHeader Header;
        binary Data;
        override string ToString()
        {
            return "SMB2 Transform, SessionId: " + DecToHexFormat(Header.SessionId).ToString();
        }
    }

    // Header only message for in case that the data is insufficient for the body part or the body part can't be decoded successfully
    message SMB2HeaderOnly[bool isRequest]
    {
        (SMB2PacketHeaderSync[isRequest] | SMB2PacketHeaderAsync[isRequest]) Header;
        override string ToString()
        {
            string summary = "SMB2 " + GetSMB2CommandStringWithoutSpace(Header);
            if (isRequest)
            {
                summary +=  "Request, Header Only";
            }
            else
            {
                summary += "Response, Header Only, Status:" + StatusToText(Header);
            }
            return summary;
        }
    }
    
    issues NegotiateResponse:ResMessage
    {
        SMB2NegotiateResponse Response;
        override string ToString()
        {
            return "SMB2 NegotiateResponse, Status: " + StatusToText(Header) + ", Revision: " + NamedPipe.DialectRevisionToText(Response.DialectRevision);
        }
    }
    
    issues TreeConnectResponse:ResMessage
    {
        SMB2TreeConnectResponse Response;
        override string ToString()
        {
            return "SMB2 TreeConnectResponse, Status: " + StatusToText(Header);
        }
    }

    accepts ReadRequest:ReqMessage
    {
        SMB2ReadRequest Request;
        override string ToString()
        {    
            return "SMB2 ReadRequest";
        }
    }
    
    issues ReadResponse:ResMessage
    {
        SMB2ReadResponse Response;
        override string ToString()
        {
            string summary = "SMB2 ReadResponse" + (this#IsReassembled != nothing ? ", Reassembled" : "");
            summary += ", Status: " + StatusToText(Header);
            return summary;
        }
    }
    
    accepts WriteRequest:ReqMessage
    {
        SMB2WriteRequest Request;
        override string ToString()
        {    
            return "SMB2 WriteRequest";
        }
    }
    
    accepts IoctlRequest:ReqMessage
    {
        SMB2IoctlRequest Request;
        override string ToString()
        {
            return "SMB2 IoctlRequest, CtlCode: " + CtlCodeToText(Request.CtlCode);
        }
    }

    issues IoctlResponse:SMB2Messages.ResMessage
    {
        SMB2IoctlResponse Response;
        override string ToString()
        {
            string summary = "SMB2 IoctlResponse" + (this#IsReassembled != nothing ? ", Reassembled" : "");
            summary += ", Status: " + StatusToText(Header);
            return summary;
        }
    }
    accepts CloseRequest:ReqMessage
    {
        SMB2CloseRequest Request;
        override string ToString()
        {
            return "SMB2 CloseRequest";
        }
    }
    
    // ERROR Response Packet
    issues ErrorResponse:ResMessage
    {
        binary Response;
        override string ToString()
        {
            return "SMB2 ErrorResponse, Status: " + StatusToText(Header);
        }
    }
    
    accepts CancelRequest
    {
        SMB2PacketHeaderReq Header;
        binary Request;
        override string ToString()
        {    
            return "SMB2 CancelRequest";
        }
    }
    
    accepts NonPipeRequest:ReqMessage
    {
        binary Request; 
        override string ToString()
        {
            return "SMB2 " + GetSMB2CommandStringWithoutSpace(Header) + "Request";
        }
    }
    
    issues NonPipeResponse:ResMessage
    {
        binary Response; 
        override string ToString()
        {
            return "SMB2 " + GetSMB2CommandStringWithoutSpace(Header) + "Response, Status: " + StatusToText(Header);
        }
    }
}

// Keep the values during the decoding
type SMB2DecodingCache
{
    // Indicates what PduFull is set in etw provider
    bool pduFull = true;
}

// Type ---------------------------------
// Defined for look ahead the field values in the Header part
type SMB2Header
{
    ushort StructureSize;
    ushort CreditCharge;
    uint Status;
    ushort Command;
    ushort Credit;
    SMB2PacketHeaderFlags Flags;
    uint NextCommand;
    ulong MessageId;
    ulong AsyncId;
    ulong SessionId;
}

// 2.2.1   SMB2 Packet Header
pattern SMB2PacketHeader = SMB2PacketHeaderSync[false] | SMB2PacketHeaderAsync[false];
pattern SMB2PacketHeaderReq = SMB2PacketHeaderSync[true] | SMB2PacketHeaderAsync[true];

// 2.2.1.1   SMB2 Packet Header - ASYNC
type SMB2PacketHeaderAsync[bool IsRequest]
{
    ULONG ProtocolId with BinaryEncoding{Endian = Endian.Big};
    USHORT StructureSize;
    USHORT CreditCharge;
    optional [|IsRequest && SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] USHORT ChannelSequence;
    optional [|IsRequest && SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] USHORT Reserved;
    optional [|!IsRequest || SMB2DialectRevision != SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] NTSTATUS Status;
    SMB2PacketHeaderCommand Command;
    USHORT Credit; 
    SMB2PacketHeaderFlags Flags;
    ULONG NextCommand;
    UINT64 MessageId;
    UINT64 AsyncId;
    UINT64 SessionId;
    binary Signature with BinaryEncoding{Length = 16};
}

pattern SMB2PacketHeaderCommand = enum USHORT
{
    SMB2Negotiate      = 0x0000,
    SMB2SessionSetup   = 0x0001,
    SMB2Logoff         = 0x0002,
    SMB2TreeConnect    = 0x0003,
    SMB2TreeDisconnect = 0x0004,
    SMB2Create         = 0x0005,
    SMB2Close          = 0x0006,
    SMB2Flush          = 0x0007,
    SMB2Read           = 0x0008,
    SMB2Write          = 0x0009,
    SMB2Lock           = 0x000A,
    SMB2Ioctl          = 0x000B,
    SMB2Cancel         = 0x000C,
    SMB2Echo           = 0x000D,
    SMB2QueryDirectory = 0x000E,
    SMB2ChangeNotify   = 0x000F,
    SMB2QueryInfo      = 0x0010,
    SMB2SetInfo        = 0x0011,
    SMB2OplockBreak    = 0x0012
};

pattern SMB2PacketHeaderFlags = flags ULONG
{
    SMB2FlagsSigned = 0x00000008,
    SMB2FlagsRelatedOperations = 0x00000004,
    SMB2FlagsAsyncCommand = 0x00000002,
    SMB2FlagsServerToRedir = 0x00000001,
    SMB2FlagsDFSOperations = 0x10000000,
    SMB2FlagsReplayOperation = 0x20000000
};


// 2.2.1.2   SMB2 Packet Header - SYNC
type SMB2PacketHeaderSync[bool IsRequest]
{
    ULONG ProtocolId with BinaryEncoding {Endian = Endian.Big};
    USHORT StructureSize;
    USHORT CreditCharge;
    optional [|IsRequest && SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] USHORT ChannelSequence;
    optional [|IsRequest && SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] USHORT Reserved;
    optional [|!IsRequest || SMB2DialectRevision != SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] NTSTATUS Status;
    SMB2PacketHeaderSyncCommand Command;
    USHORT Credit;
    SMB2PacketHeaderFlags Flags where (Flags & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) == 0;
    ULONG NextCommand;
    UINT64 MessageId;
    ULONG Reserved2;
    ULONG TreeId;
    UINT64 SessionId;
    binary Signature with BinaryEncoding{Length = 16};
}

pattern SMB2PacketHeaderSyncCommand = enum USHORT
{
    SMB2Negotiate      = 0x0000,
    SMB2SessionSetup   = 0x0001,
    SMB2Logoff         = 0x0002,
    SMB2TreeConnect    = 0x0003,
    SMB2TreeDisconnect = 0x0004,
    SMB2Create         = 0x0005,
    SMB2Close          = 0x0006,
    SMB2Flush          = 0x0007,
    SMB2Read           = 0x0008,
    SMB2Write          = 0x0009,
    SMB2Lock           = 0x000A,
    SMB2Ioctl          = 0x000B,
    SMB2Cancel         = 0x000C,
    SMB2Echo           = 0x000D,
    SMB2QueryDirectory = 0x000E,
    SMB2ChangeNotify   = 0x000F,
    SMB2QueryInfo      = 0x0010,
    SMB2SetInfo        = 0x0011,
    SMB2OplockBreak    = 0x0012
};

// 2.2.2.1   Symbolic Link Error Response
type SymbolicLinkErrorResponseErrorData
{
    ULONG SymLinkLength;
    ULONG SymLinkErrorTag;
    ULONG ReparseTag;
    USHORT ReparseDataLength;
    USHORT UnparsedPathLength;
    USHORT SubstituteNameOffset;
    USHORT SubstituteNameLength;
    USHORT PrintNameOffset;
    USHORT PrintNameLength;
    SymbolicLinkErrorResponseFlags Flags;
    // Will manully decode the PathBuffer in detail later
    PathBuffer PathBuffer with Encoding{Ignore =  true};
}

type PathBuffer
{
    string SubstituteName;
    string PrintName;
}

pattern SymbolicLinkErrorResponseFlags = enum ULONG
{
    SYMLinkFlagPath = 0x00000000,
    SYMLinkFlagRelative = 0x00000001,
    ...
};

// 2.2.4   SMB2 NEGOTIATE Response
type SMB2NegotiateResponse
{
    USHORT StructureSize;
    SMB2NegotiateResponseSecurityMode SecurityMode;
    SMB2NegotiateResponseDialectRevision DialectRevision;
    USHORT Reserved;
    GUID ServerGuid;
    SMB2NegotiateResponseCapabilities Capabilities;
    ULONG MaxTransactSize;
    ULONG MaxReadSize;
    ULONG MaxWriteSize;
    FILETIME SystemTime;
    FILETIME ServerStartTime;
    USHORT SecurityBufferOffset;
    USHORT SecurityBufferLength;
    ULONG Reserved2;
    optional [|SecurityBufferOffset > 128|] array<byte> BufferPadding with BinaryEncoding{Length = SecurityBufferOffset - 128 as uint};
    (binary | any) Buffer;
}

pattern SMB2NegotiateResponseSecurityMode = flags USHORT
{
    SMB2NegotiateSigningEnabled = 0x0001,
    SMB2NegotiateSigningRequired = 0x0002,
    ...
};

pattern SMB2NegotiateResponseDialectRevision = enum USHORT
{
    SMB2002DialectRevisionNumber = 0x0202,
    SMB21DialectRevisionNumber = 0x0210,
    SMB30DialectRevisionNumber = 0x0300,
	SMB302DialectRevisionNumber = 0x0302,
    SMB2WildcardRevisionNumber = 0x02FF,
	...
};


pattern SMB2NegotiateResponseCapabilities = flags ULONG
{
    SMB2GlobalCapDfs = 0x00000001,
    SMB2GlobalCapLeasing = 0x00000002,
    SMB2GlobalCapLargeMtu = 0x00000004,
    SMB2GlobalCapMultiChannel = 0x00000008,
    SMB2GlobalCapPersistentHandles = 0x00000010,
    SMB2GlobalCapDirectoryLeasing = 0x00000020,
    SMB2GlobalCapEncryption = 0x00000040,
    ...
};

// 2.2.10   SMB2 TREE_CONNECT Response
type SMB2TreeConnectResponse
{
    USHORT StructureSize;
    SMB2TreeConnectResponseShareType ShareType;
    BYTE Reserved;
    SMB2TreeConnectResponseShareFlags ShareFlags;
    SMB2TreeConnectResponseCapabilities Capabilities;
    ([|ShareType == SMB2TreeConnectResponseShareType.SMB2ShareTypeDisk|] DirectoryAccessMask
        | FilePipePrinterAccessMask) MaximalAccess;
}

pattern SMB2TreeConnectResponseShareType = enum BYTE
{
    SMB2ShareTypeDisk = 0x01,
    SMB2ShareTypePipe = 0x02,
    SMB2ShareTypeprint = 0x03,
    ...
};

pattern SMB2TreeConnectResponseShareFlags = flags ULONG
{
    SMB2ShareflagManualCaching = 0x00000000,
    SMB2ShareflagAutoCaching = 0x00000010,
    SMB2ShareflagVdoCaching = 0x00000020,
    SMB2ShareflagNoCaching = 0x00000030,
    SMB2ShareflagDfs = 0x00000001,
    SMB2ShareflagDfsRoot = 0x00000002,
    SMB2ShareflagRestrictExclusiveOpens = 0x00000100,
    SMB2ShareflagForceSharedDelete = 0x00000200,
    SMB2ShareflagAllowNamespaceCaching = 0x00000400,
    SMB2ShareflagAccessBasedDirectoryEnum = 0x00000800,
    SMB2ShareflagForceLeveliiOplock = 0x00001000,
    SMB2ShareflagEnableHashV1 = 0x00002000,
    SMB2ShareflagEnableHashV2 = 0x00004000,
    SMB2ShareflagEncryptData = 0x00008000,
    ...
};
 
pattern SMB2TreeConnectResponseCapabilities = flags ULONG
{
    SMB2ShareCapDfs = 0x00000008,
    SMB2ShareCapContinuousAvailability = 0x00000010,
    SMB2ShareCapScaleout = 0x00000020,
    SMB2ShareCapCluster = 0x00000040,
    ...
};

// 2.2.13.1.1   File_Pipe_Printer_Access_Mask
type FilePipePrinterAccessMask
{
    FilePipePrinterAccessMaskFilePipePrinterAccessMask FilePipePrinterAccessMaskFlags;
}

// 2.2.13.1.2   Directory_Access_Mask
type DirectoryAccessMask
{
    DirectoryAccessMaskDirectoryAccessMask DirectoryAccessMaskValue;
}

pattern FilePipePrinterAccessMaskFilePipePrinterAccessMask = flags ULONG
{
    FileReadData = 0x00000001,
    FileWriteData = 0x00000002,
    FileAppendData = 0x00000004,
    FileReadEa = 0x00000008,
    FileWriteEa = 0x00000010,
    FileExecute = 0x00000020,
    FileDeleteChild = 0x00000040,
    FileReadAttributes = 0x00000080,
    FileWriteAttributes = 0x00000100,
    Delete = 0x00010000,
    ReadControl = 0x00020000,
    WriteDac = 0x00040000,
    WriteOwner = 0x00080000,
    Synchronize = 0x00100000,
    AccessSystemSecurity = 0x01000000,
    MaximumAllowed = 0x02000000,
    GenericAll = 0x10000000,
    GenericExecute = 0x20000000,
    GenericWrite = 0x40000000,
    GenericRead = 0x80000000,
    ...
};

// 2.2.15   SMB2 CLOSE Request
type SMB2CloseRequest
{
    USHORT StructureSize;
    SMB2CloseRequestFlags Flags;
    ULONG Reserved;
    SMB2Fileid FileId;
}

pattern SMB2CloseRequestFlags = flags USHORT
{
   SMB2CloseFlagPostqueryAttrib = 0x0001,
   ...
};

type SMB2Fileid
{
    UINT64 Persistent;
    UINT64 Volatile;

    override string ToString()
    {
        return "Persistent: " + Utility.DecToHexFormat(Persistent) + ", Volatile: " + Utility.DecToHexFormat(Volatile);
    }
}

type SMB2ReadRequest
{
    USHORT StructureSize;
    UCHAR Padding;
    UCHAR Reserved;
    ULONG Length;
    UINT64 Offset;
    SMB2Fileid FileId;
    ULONG MinimumCount;
    SMB2ReadRequestChannel Channel;
    ULONG RemainingBytes;
    USHORT ReadChannelInfoOffset;
    USHORT ReadChannelInfoLength;
    BYTE Buffer;
}

pattern SMB2ReadRequestChannel = flags ULONG
{
      SMB2ChannelRdmaV1 = 0x00000001,
      ...
};

// 2.2.20   SMB2 READ Response
type SMB2ReadResponse
{
    USHORT StructureSize;
    UCHAR DataOffset;
    UCHAR Reserved;
    ULONG DataLength;
    ULONG DataRemaining;
    ULONG Reserved2;
    optional [|DataOffset > 80|] array<byte> DataPadding with BinaryEncoding{Length = DataOffset - 80 as uint};
    binary Buffer;
};

// 2.2.21   SMB2 WRITE Request
type SMB2WriteRequest
{
    USHORT StructureSize;
    USHORT DataOffset;
    ULONG Length;
    UINT64 Offset;
    SMB2Fileid FileId;
    SMB2WriteRequestChannel Channel;
    ULONG RemainingBytes;
    USHORT WriteChannelInfoOffset;
    USHORT WriteChannelInfoLength;
    SMB2WriteRequestFlags Flags;
    optional [|DataOffset > 112|] array<byte> DataPadding with BinaryEncoding{Length = DataOffset - 112 as uint};
    binary Buffer; 
}

pattern SMB2WriteRequestFlags = flags ULONG
{
    SMB2WriteflagWriteThrough = 0x00000001,
    ...
};

pattern SMB2WriteRequestChannel = flags ULONG
{
      SMB2ChannelRdmaV1 = 0x00000001,
      ...
};

pattern DirectoryAccessMaskDirectoryAccessMask = flags ULONG
{
    FileListDirectory = 0x00000001,
    FileAddFile = 0x00000002,
    FileAddSubdirectory = 0x00000004,
    FileReadEa = 0x00000008,
    FileWriteEa = 0x00000010,
    FileTraverse = 0x00000020,
    FileDeleteChild = 0x00000040,
    FileReadAttributes = 0x00000080,
    FileWriteAttributes = 0x00000100,
    Delete = 0x00010000,
    ReadControl = 0x00020000,
    WriteDac = 0x00040000,
    WriteOwner = 0x00080000,
    Synchronize = 0x00100000,
    AccessSystemSecurity = 0x01000000,
    MaximumAllowed = 0x02000000,
    GenericAll = 0x10000000,
    GenericExecute = 0x20000000,
    GenericWrite = 0x40000000,
    GenericRead = 0x80000000,
    ...
};
// 2.2.31   SMB2 IOCTL Request
type SMB2IoctlRequest
{
    USHORT StructureSize;
    USHORT Reserved;
    ULONG CtlCode with DisplayInfo{ToText = CtlCodeToText};
    SMB2Fileid FileId;
    ULONG InputOffset;
    ULONG InputCount;
    ULONG MaxInputResponse;
    ULONG OutputOffset;
    ULONG OutputCount;
    ULONG MaxOutputResponse;
    SMB2IoctlRequestFlags Flags;
    ULONG Reserved2;
    optional [|InputOffset > 120|] array<byte> Padding with BinaryEncoding{Length = InputOffset - 120 as uint};
    binary Buffer;
}

pattern SMB2IoctlRequestFlags = enum ULONG
{
    SMB20Ioctl = 0x00000000,
    SMB20IoctlIsFsctl = 0x00000001,
};

// 2.2.31.2   SRV_READ_HASH Request
type SrvReadHashRequest
{
    SrvReadHashHashType HashType;
    SrvReadHashHashVersion HashVersion;
    SrvReadHashHashRetrievalType HashRetrievalType;
    ULONG Length;
    UINT64 Offset;
}

pattern SrvReadHashHashType = enum ULONG
{
    SrvHashTypePeerDist = 0x00000001,
};

pattern SrvReadHashHashVersion = enum ULONG
{
    SrvHashVer1 = 0x00000001,
    SrvHashVer2 = 0x00000002,
};

pattern SrvReadHashHashRetrievalType = enum ULONG
{
    SrvReadRetrieveHashBased = 0x00000001,
    SrvReadRetrieveFileBased = 0x00000002,
};


// 2.2.32   SMB2 IOCTL Response
type SMB2IoctlResponse
{
    USHORT StructureSize;
    USHORT Reserved;
    ULONG CtlCode with DisplayInfo{ToText = CtlCodeToText};
    SMB2Fileid FileId;
    ULONG InputOffset;
    ULONG InputCount;
    ULONG OutputOffset;
    ULONG OutputCount;
    ULONG Flags;
    ULONG Reserved2;

    // Buffer part
    optional [|InputOffset > 112|] array<byte> InputBufferPadding with BinaryEncoding{Length = InputOffset - 112 as uint};
    binary InputBuffer with BinaryEncoding{Length = InputCount};
    optional [|OutputOffset > 112 && OutputOffset > InputOffset + InputCount|] array<byte> OutputBufferPadding with BinaryEncoding{Length = OutputOffset - InputOffset - InputCount as uint};
    binary Buffer;
}

// 2.2.41   SMB2 TRANSFORM_HEADER
type SMB2TransformHeader
{
    ULONG ProtocolId with BinaryEncoding {Endian = Endian.Big};
    binary Signature with BinaryEncoding{Length = 16};
    binary Nonce with BinaryEncoding{Length = 16};
    ULONG OriginalMessageSize;
    USHORT Reserved;
    SMB2TransformHeaderEncryptionAlgorithm EncryptionAlgorithm;
    UINT64 SessionId;
}

pattern SMB2TransformHeaderEncryptionAlgorithm = enum USHORT
{
    SMB2EncryptionAes128Ccm = 0x00000001,
    ...
};

// Function ----------------------------------
// Decoding the request messages
void DecodeAndDispatchRequestMessages(SMB2DecodingCache dc, binary payload, (Server | NBTSS.Server) server)
{
    // The beginning offset of current message
    int offset = 0;
    // The beginning offset of next message
    int nextOffset = 0;
    var streamLength = payload.Count;

    while (offset + 64 < streamLength) // 64 is the total size of the Header part
    {
        switch (payload.Segment(offset + 4, 44))
        {
            case header:SMB2Header from BinaryDecoder<SMB2Header> =>
                nextOffset = (header.NextCommand == 0 ? streamLength : header.NextCommand + offset) as int;
                var messageData = payload.Segment(offset, nextOffset - offset);

                switch (header.Command)
                {
                    case SMB2PacketHeaderCommand.SMB2Write =>
                        var m = NamedPipeDecodeMessage<SMB2Messages.WriteRequest>(messageData, "WriteRequest");
                        if (m != null)
                        {
                            if (messageData.Count < m.Request.DataOffset + m.Request.Length)
                            {
                                ReportInsufficientData(m, "NamedPipe", "Buffer", "WriteRequest", !dc.pduFull);
                                DisplayTopLevelMessage(m);
                            }
                            else
                            {
                                dispatch GetSMB2ServerInstance(server) accepts m;
                            }
                        }
                    case SMB2PacketHeaderCommand.SMB2Ioctl =>
                        var m = NamedPipeDecodeMessage<SMB2Messages.IoctlRequest>(messageData, "IoctlRequest");
                        if (m != null)
                        {
                            if (messageData.Count < m.Request.InputOffset + m.Request.InputCount)
                            {
                                ReportInsufficientData(m, "NamedPipe", "Buffer", "IoctlRequest", !dc.pduFull); 
                                DisplayTopLevelMessage(m);
                            }
                            else
                            {
                                dispatch GetSMB2ServerInstance(server) accepts m;
                            }
                        }
                    case SMB2PacketHeaderCommand.SMB2Read =>
                        var m = NamedPipeDecodeMessage<SMB2Messages.ReadRequest>(messageData, "ReadRequest"); 
                        dispatch GetSMB2ServerInstance(server) accepts m;
                    case SMB2PacketHeaderCommand.SMB2Cancel =>
                        var m = NamedPipeDecodeMessage<SMB2Messages.CancelRequest>(messageData, "CancelRequest"); 
                        dispatch GetSMB2ServerInstance(server) accepts m;
                    case SMB2PacketHeaderCommand =>
                        switch(messageData)
                        {
                            case msg: SMB2Messages.NonPipeRequest from BinaryDecoder<SMB2Messages.NonPipeRequest> =>
                                dispatch GetSMB2ServerInstance(server) accepts msg;
                            default =>
                                TryDecodeSMB2HeaderOnlyMessage(messageData, "NonPipeRequest");
                        }
                    default =>
                        throw "NamedPipe: Unrecoverable decoding failure, unknown SMB2 request message";
                }
                offset = nextOffset;
            default =>
                throw "NamedPipe: Unrecoverable decoding failure for the SMB2Header type";
        }
    }
}

// Decoding the response messages
void DecodeAndDispatchResponseMessages(SMB2DecodingCache dc, binary payload, (Server | NBTSS.Server) server)
{
    int offset = 0;
    int nextOffset = 0;
    var streamLength = payload.Count;

    while (offset + 64 < streamLength) // 64 is the total size of the Header part
    {
        switch (payload.Segment(offset + 4, 44))
        {
            case header:SMB2Header from BinaryDecoder<SMB2Header> =>
                nextOffset = (header.NextCommand == 0 ? streamLength : header.NextCommand + offset) as int;
                var messageData = payload.Segment(offset, nextOffset - offset);
                // Look ahead the value of the StructureSize field in reponse package
                var structureSize = BinaryDecoder<ushort>(messageData.Segment(64, 2)) as ushort;
                any message m;
                bool isAsyncCommand = (header.Flags & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) > 0;
                if (IsErrorResponse(header.Command, header.Status, structureSize, isAsyncCommand))
                {
                    stream s = messageData;
                    switch (s)
                    {
                        case tm:SMB2Messages.ErrorResponse from BinaryDecoder<SMB2Messages.ErrorResponse> =>
                            m = tm;
                        default =>
                            TryDecodeSMB2HeaderOnlyMessage(messageData, "ErrorResponse");
                    }
                }
                else
                {
                    switch (header.Command)
                    {
                        case SMB2PacketHeaderCommand.SMB2Negotiate =>
                            var tm = NamedPipeDecodeMessage<SMB2Messages.NegotiateResponse>(messageData, "NegotiateResponse");
                            if (tm != null)
                            {
                                /* WORKAROUND: Assign the DialectRevision to global variable SMB2DialectRevision.
                                 * Will remove this global variable in the Server endpoint when BUG#39968 and 43830 is fixed
                                 * BUG#39968: The value parameter feature doesn't work properly when a type overriding a type with value parameters.
                                 */
                                SMB2DialectRevision = tm.Response.DialectRevision;
                                if (messageData.Count < tm.Response.SecurityBufferLength + tm.Response.SecurityBufferOffset)
                                {
                                    ReportInsufficientData(tm, "NamedPipe", "Buffer", "NegotiateResponse", !dc.pduFull);
                                    DisplayTopLevelMessage(tm);
                                }
                                else
                                {
                                    m = tm;
                                }
                            }

                        case SMB2PacketHeaderCommand.SMB2TreeConnect =>
                            m = NamedPipeDecodeMessage<SMB2Messages.TreeConnectResponse>(messageData, "TreeConnectResponse");
                        case SMB2PacketHeaderCommand.SMB2Read =>
                            var tm = NamedPipeDecodeMessage<SMB2Messages.ReadResponse>(messageData, "ReadResponse");
                            if (tm != null)
                            {
                                if (messageData.Count < tm.Response.DataOffset + tm.Response.DataLength)
                                {
                                    ReportInsufficientData(tm, DiagnosisLevel.Error, "NamedPipe: Insufficient data for Buffer field in message ReadResponse, due to missing lower-layer protocol segment.");                                                                                                                                                                                                                                                                                          
                                    DisplayTopLevelMessage(tm);
                                }
                                else
                                {
                                    m = tm;
                                }
                            }
                        case SMB2PacketHeaderCommand.SMB2Ioctl =>
                            var tm = NamedPipeDecodeMessage<SMB2Messages.IoctlResponse>(messageData, "IoctlResponse");
                            if (tm != null)
                            {
                                if (messageData.Count < tm.Response.OutputOffset + tm.Response.OutputCount)
                                {
                                    ReportInsufficientData(tm, "NamedPipe", "Buffer", "ReadResponse", !dc.pduFull);
                                    DisplayTopLevelMessage(tm);
                                }
                                else
                                {
                                    m = tm;
                                }
                               
                            }
                        case SMB2PacketHeaderCommand => 
                            switch(messageData)
                            {
                                case msg: SMB2Messages.NonPipeResponse from BinaryDecoder<SMB2Messages.NonPipeResponse> =>
                                    m = msg;
                                default =>
                                    TryDecodeSMB2HeaderOnlyMessage(messageData, "NonPipeResponse");
                            }
                        default =>
                            throw "NamedPipe: Unrecoverable decoding failure, unknown SMB2 response message.";
                    }
                }
                if (m != null)
                {
                    dispatch GetSMB2ServerInstance(server) issues m;
                }
                offset = nextOffset;
            default =>
                throw "NamedPipe: Unrecoverable decoding failure for the SMB2Header type.";
        }
    }
}

// Judge an error response message according to section 3.3.4.4 Sending an Error Response
bool IsErrorResponse(ushort commmand, uint status, ushort size, bool asyncCommand)
{
    //An error code other than one of the following indicates a failure:
    if ((commmand == SMB2PacketHeaderCommand.SMB2SessionSetup && status == 0xC0000016) // STATUS_MORE_PROCESSING_REQUIRED in an SMB2 SESSION_SETUP Response
        || ((commmand == SMB2PacketHeaderCommand.SMB2QueryInfo || commmand is SMB2PacketHeaderCommand.SMB2Read) && status == 0x80000005) // STATUS_BUFFER_OVERFLOW in an SMB2 QUERY_INFO Response/SMB2 READ Response
        || (commmand == SMB2PacketHeaderCommand.SMB2ChangeNotify && status == 0x0000010C) // STATUS_NOTIFY_ENUM_DIR in an SMB2 CHANGE_NOTIFY Response
        || (commmand == SMB2PacketHeaderCommand.SMB2Ioctl && status != 0 && size == 49)) // Any status other than STATUS_SUCCESS in a FSCTL_SRV_COPYCHUNK or FSCTL_SRV_COPYCHUNK_WRITE Response
    {
        return false;
    }
    else
    {
        return ((status & 0xC0000000) == 0xC0000000) // Error code
            || (asyncCommand && (status == 0x0103)) // Interim Response for an Asynchronous Operation
            || (status in {0x8000002D, 0x80000014}); // STATUS_STOPPED_ON_SYMLINK, STATUS_EA_LIST_INCONSISTENT
    }
}

// Decode the message by the command type
T NamedPipeDecodeMessage<T>(stream data, string command)
{
    switch (data)
    {
        case m:T from BinaryDecoder<T> =>
            return m;
        default =>
            TryDecodeSMB2HeaderOnlyMessage(data, command);
    }
    T t;
    return t; // return null
}

// Try to decode the insufficient data into the header only message
void TryDecodeSMB2HeaderOnlyMessage(stream data, string msgName)
{
    bool isRequest = ((data.PeekByte(16 * 8) as int) & 0x01) == 0; // Look ahead the ServerToRedir bit
    switch (data)
    {
        case m:SMB2Messages.SMB2HeaderOnly from BinaryDecoder<SMB2Messages.SMB2HeaderOnly[isRequest]> =>
            m#CommandName = msgName;
            DisplayTopLevelMessage(m);
        default =>
            ThrowDecodingException(msgName);
    }
}

// Get the MessageId for the reponse message
ulong GetCommand(SMB2PacketHeader header)
{
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).Command;
    }
    else
    {
        return (header as SMB2PacketHeaderAsync).Command;
    }
}

string GetSMB2CommandStringWithoutSpace(SMB2PacketHeader header)
{
    switch (GetCommand(header))
    {
        case SMB2PacketHeaderCommand.SMB2Negotiate 
            => return "Negotiate";
        case SMB2PacketHeaderCommand.SMB2SessionSetup
            => return "SessionSetup";
        case SMB2PacketHeaderCommand.SMB2Logoff         
            => return "Logoff";
        case SMB2PacketHeaderCommand.SMB2TreeConnect    
            => return "TreeConnect";
        case SMB2PacketHeaderCommand.SMB2TreeDisconnect 
            => return "TreeDisconnect";
        case SMB2PacketHeaderCommand.SMB2Create         
            => return "Create";
        case SMB2PacketHeaderCommand.SMB2Close          
            => return "Close";
        case SMB2PacketHeaderCommand.SMB2Flush          
            => return "Flush";
        case SMB2PacketHeaderCommand.SMB2Read           
            => return "Read";
        case SMB2PacketHeaderCommand.SMB2Write          
            => return "Write";
        case SMB2PacketHeaderCommand.SMB2Lock           
            => return "Lock";
        case SMB2PacketHeaderCommand.SMB2Ioctl          
            => return "Ioctl";
        case SMB2PacketHeaderCommand.SMB2Cancel         
            => return "Cancel";
        case SMB2PacketHeaderCommand.SMB2Echo           
            => return "Echo";
        case SMB2PacketHeaderCommand.SMB2QueryDirectory 
            => return "QueryDirectory";
        case SMB2PacketHeaderCommand.SMB2ChangeNotify   
            => return "ChangeNotify";
        case SMB2PacketHeaderCommand.SMB2QueryInfo      
            => return "QueryInformation";
        case SMB2PacketHeaderCommand.SMB2SetInfo        
            => return "SetInformation";
        case SMB2PacketHeaderCommand.SMB2OplockBreak   
            => return "OplockBreak";
        default 
            => return "Unknown";
        
    }
}

// Get the TreeId for the reponse message
uint GetTreeId(SMB2PacketHeader header)
{
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).TreeId;
    }
    return 0;
}

// Get the MessageId for the reponse message
ulong GetMessageId(SMB2PacketHeader header)
{
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).MessageId;
    }
    else
    {
        return (header as SMB2PacketHeaderAsync).MessageId;
    }
}

// Get the VirtualOperationServer endpoint binding over the lower transport endpoint
SMB2Server GetSMB2ServerInstance((Server | NBTSS.Server) ls)
{
    SMB2Server server;
    switch (ls)
    {
        case lowerNode:Server =>
            server = endpoint SMB2Server over lowerNode;
            
        case lowerNode:NBTSS.Server =>
            server = endpoint SMB2Server over lowerNode;
        
        default =>
            // No binding of the lower endpoint for other transports
            server = endpoint SMB2Server;
    }
    return server;
}

// Defined for get Status
optional NTSTATUS GetStatus(SMB2PacketHeader header)
{
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).Status;
    }
    else if (header is SMB2PacketHeaderAsync)
    {
        return (header as SMB2PacketHeaderAsync).Status;
    }
    return nothing;
}

string DialectRevisionToText(ushort revision)
{
    if (revision == 0x0202) return "SMB 2.002";
    else if (revision == 0x0210) return "SMB 2.1";
    else if (revision == 0x02FF) return Utility.DecToHexFormat(revision);
    else if (revision == 0x0300) return "SMB 3.0";
	else if (revision == 0x0302) return "SMB 3.02";
    else return "Unknown Value: " + Utility.DecToHexFormat(revision);
}

// Defined for DisplayInfo.
string StatusToText(SMB2PacketHeader header)
{
    if (GetStatus(header) == nothing)
    {
        return "";
    }
    uint status = GetStatus(header) as uint;
    return status == 0 ? "Success": NtStatusValuesToText(status); 
}

string CtlCodeToText(any ctlCode)
{
    uint code = ctlCode as uint;
    if (code in CtlCodeMap)
    {
        return CtlCodeMap[code];
    }
    else if (code in FsctlNameMap)
    {
        return FsctlNameMap[code];
    }
    else
    {
        return "Unknown value: " + Utility.DecToHexFormat(code);
    }
}

const map<uint, string> CtlCodeMap = {
        0x00060194 -> "FSCTL_DFS_GET_REFERRALS",
        0x0011400C -> "FSCTL_PIPE_PEEK",
        0x00110018 -> "FSCTL_PIPE_WAIT",
        0x0011C017 -> "FSCTL_PIPE_TRANSCEIVE",
        0x001440F2 -> "FSCTL_SRV_COPYCHUNK",
        0x00144064 -> "FSCTL_SRV_ENUMERATE_SNAPSHOTS",
        0x00140078 -> "FSCTL_SRV_REQUEST_RESUME_KEY",
        0x001441BB -> "FSCTL_SRV_READ_HASH",
        0x001480F2 -> "FSCTL_SRV_COPYCHUNK_WRITE",
        0x001401D4 -> "FSCTL_LMR_REQUEST_RESILIENCY",
        0x001401FC -> "FSCTL_QUERY_NETWORK_INTERFACE_INFO",
        0x000900A4 -> "FSCTL_SET_REPARSE_POINT",
        0x001400EC -> "FSCTL_LMR_SET_LINK_TRACKING_INFORMATION",
        0x000601B0 -> "FSCTL_DFS_GET_REFERRALS_EX",
        0x00090073 -> "FSCTL_GET_RETRIEVAL_POINTERS",
        0x00094264 -> "FSCTL_OFFLOAD_READ",
        0x00098268 -> "FSCTL_OFFLOAD_WRITE",
        0x00098208 -> "FSCTL_FILE_LEVEL_TRIM",
        0x00140204 -> "FSCTL_VALIDATE_NEGOTIATE_INFO",
    };

const map<uint, string> FsctlNameMap =
    {
        0x900C0 -> "FSCTL_CREATE_OR_GET_OBJECT_ID",
        0x900A0 -> "FSCTL_DELETE_OBJECT_ID",
        0x900AC -> "FSCTL_DELETE_REPARSE_POINT",
        0x98208 -> "FSCTL_FILE_LEVEL_TRIM",
        0x90060 -> "FSCTL_FILESYSTEM_GET_STATISTICS",
        0x9008F -> "FSCTL_FIND_FILES_BY_SID",
        0x9003C -> "FSCTL_GET_COMPRESSION",
        0x9027C -> "FSCTL_GET_INTEGRITY_INFORMATION",
        0x90064 -> "FSCTL_GET_NTFS_VOLUME_DATA",
        0x9009C -> "FSCTL_GET_OBJECT_ID",
        0x900A8 -> "FSCTL_GET_REPARSE_POINT",
        0x90073 -> "FSCTL_GET_RETRIEVAL_POINTERS",
        0x9002C -> "FSCTL_IS_PATHNAME_VALID",
        0x1400EC -> "FSCTL_LMR_SET_LINK_TRACKING_INFORMATION",
        0x94264 -> "FSCTL_OFFLOAD_READ",
        0x98268 -> "FSCTL_OFFLOAD_WRITE",
        0x11400C -> "FSCTL_PIPE_PEEK",
        0x11C017 -> "FSCTL_PIPE_TRANSCEIVE",
        0x110018 -> "FSCTL_PIPE_WAIT",
        0x940CF -> "FSCTL_QUERY_ALLOCATED_RANGES",
        0x90058 -> "FSCTL_QUERY_FAT_BPB",
        0x9013C -> "FSCTL_QUERY_ON_DISK_VOLUME_INFO",
        0x90138 -> "FSCTL_QUERY_SPARING_INFO",
        0x900EB -> "FSCTL_READ_FILE_USN_DATA",
        0x90117 -> "FSCTL_RECALL_FILE",
        0x9C040 -> "FSCTL_SET_COMPRESSION",
        0x98134 -> "FSCTL_SET_DEFECT_MANAGEMENT",
        0x900D7 -> "FSCTL_SET_ENCRYPTION",
        0x9C280 -> "FSCTL_SET_INTEGRITY_INFORMATION",
        0x90098 -> "FSCTL_SET_OBJECT_ID",
        0x900BC -> "FSCTL_SET_OBJECT_ID_EXTENDED",
        0x900A4 -> "FSCTL_SET_REPARSE_POINT",
        0x900C4 -> "FSCTL_SET_SPARSE",
        0x980C8 -> "FSCTL_SET_ZERO_DATA",
        0x90194 -> "FSCTL_SET_ZERO_ON_DEALLOCATION",
        0x90100 -> "FSCTL_SIS_COPYFILE",
        0x900EF -> "FSCTL_WRITE_USN_CLOSE_RECORD",
        0x901B4 -> "FSCTL_SET_SHORT_NAME_BEHAVIOR",
    };
    
// List of ignored error code for ErrorCodeIf check
array<uint> IgnoredErrorCode = [0xC0000016, // STATUS_MORE_PROCESSING_REQUIRED
                                0xC000019C];  // STATUS_FS_DRIVER_REQUIRED


// ------------------------------------------------------------------
// SMB
endpoint SMBServer 
    over LowestServer | over FileServer 
    provides SMBMessages;
    
client endpoint SMBClient connected to SMBServer;

endpoint FileServer[ushort FileId] 
    over LowestServer 
    provides SMBMessages 
    accepts SmbHeader issues SmbHeader
{
    process this accepts m:SmbHeader
    {
        dispatch (endpoint SMBServer over this) accepts m;
    }
    
    process this issues m:SmbHeader
    {
        dispatch (endpoint SMBServer over this) issues m;
    }
}
client endpoint FileClient connected to FileServer;

type DecoderVariables
{
    array<string> NegotiateDialects = [];
    // key: MID, value: SubCommand
    map<USHORT, USHORT> Subcommand = {};
    // key: MID, value : FID
    map<USHORT, USHORT> FIDByMID = {};
    map<USHORT, USHORT> InformationLevel = {};
    map<USHORT, USHORT> Trans2FindFlags = {};
    map<USHORT, ULONG> IoctlFunctionCode = {};
    map<USHORT, string> FileName = {}; // key is FID, for conversation usage
    map<USHORT, string> FileNameForRsp = {}; // key is MID, for response usage
    map<USHORT, USHORT> FidForRsp = {}; // Key is MID, for response referring FID
    
    bool pduFull = true; // Indicates what PduFull is set in etw provider
    
    string GetIndex(ushort mid, ushort fid, bool isOpen, bool isClose)
    {
        string index = fid as string;
        if (isOpen)
        {
            if (mid in FileNameForRsp)
            {
                index = FileNameForRsp[mid];
                FileNameForRsp = FileNameForRsp.Remove(mid);
                FileName[fid] = index;
            }
        }
        else
        {
            FidForRsp[mid] = fid;
            if (fid in FileName)
            {
                index = FileName[fid];
                FileNameForRsp[mid] = index;
                if (isClose)
                {
                    FileName = FileName.Remove(fid);
                }
            }
        }
        return index;
    }
    
    string GetIndex(ushort mid)
    {
        string index = "0x00";
        if (mid in FidForRsp)
        {
            index = FidForRsp[mid] as string;
            FidForRsp = FidForRsp.Remove(mid);
        }
        if (mid in FileNameForRsp)
        {
            index = FileNameForRsp[mid];
            FileNameForRsp = FileNameForRsp.Remove(mid);
        }
        return index;
    }
}

endpoint LowestServer
    over Server | over NBTSS.Server | over NBF.Node
    provides SMBMessages 
{
    DecoderVariables dvar = new DecoderVariables{};
    map<ushort, array<SMBMessages.ComTransactionResponse>> transMessages = {};
    
    process this accepts m:SMBMessages.ComReadAndxRequest
    {
        dvar.FIDByMID[m.Mid] = m.Request.Fid;
        dispatch (endpoint FileServer[m.Request.Fid] over this) accepts m;
    }
    
    process this issues m:SMBMessages.ComReadAndxResponse
    {
        ushort fid = 0;
        if (m.Mid in dvar.FIDByMID)
        {
            fid = dvar.FIDByMID[m.Mid];
            dvar.FIDByMID = dvar.FIDByMID.Remove(m.Mid);
        }
        m#SMBFileId = fid as ulong;
        dispatch (endpoint FileServer[fid] over this) issues m;
    }
    
    process this accepts m:SMBMessages.ComWriteAndxRequest
    {
        dispatch (endpoint FileServer[m.Request.Fid] over this) accepts m;
    }
    
    process this accepts m:SMBMessages.ComTransactionRequest
    {
        ushort fid = m.Request.Fid == nothing ? 0 : m.Request.Fid as ushort;
        dvar.FIDByMID[m.Mid] = fid;
        if (m.Request.Subcommand != nothing)
        {
            dvar.Subcommand[m.Mid] = m.Request.Subcommand as ushort;
        }
        dispatch (endpoint FileServer[fid] over this) accepts m;
    }
    
    process this issues m:SMBMessages.ComTransactionResponse
    {
        if (m.Response.TransData != nothing && (m.Response.TransData is binary) 
            && (m.Response.TransData as binary).Count < m.Response.DataCount) //deal with messages contains insufficient data
        {
            DisplayTopLevelMessage(m);
            ReportInsufficientData(m, "NamedPipe", "TransData", "ComTransactionResponse", !dvar.pduFull);
            if (m.Mid in transMessages)
            {
                foreach(var transRsp in transMessages[m.Mid])
                {
                    DisplayTopLevelMessage(transRsp);
                }
                transMessages = transMessages.Remove(m.Mid);
            }
            if (m.Mid in dvar.Subcommand)
            {
                dvar.Subcommand = dvar.Subcommand.Remove(m.Mid);
            }
        }
        else if (IsCompletedResponse(m.Response.ParameterDisplacement, m.Response.ParameterCount, m.Response.TotalParameterCount) 
            && IsCompletedResponse(m.Response.DataDisplacement, m.Response.DataCount, m.Response.TotalDataCount))
        {
            ushort fid = 0;
            if (m.Mid in dvar.FIDByMID)
            {
                fid = dvar.FIDByMID[m.Mid];
                dvar.FIDByMID = dvar.FIDByMID.Remove(m.Mid);
            }
            m#SMBFileId = fid as ulong;
            dispatch (endpoint FileServer[fid] over this) issues m;
        }
        else
        {
            if (!(m.Mid in transMessages.Keys))
            {
                transMessages[m.Mid] = [m];
            }
            else
            {
                transMessages[m.Mid].InsertSorted<SMBMessages.ComTransactionResponse>(
                    (SMBMessages.ComTransactionResponse r1, SMBMessages.ComTransactionResponse r2) => r1.Response.ParameterDisplacement == r2.Response.ParameterDisplacement ? r1.Response.DataDisplacement - r2.Response.DataDisplacement : r1.Response.ParameterDisplacement - r2.Response.ParameterDisplacement,
                    m);
                array<SMBMessages.ComTransactionResponse> comTransactionResponse = transMessages[m.Mid];
                SMBMessages.ComTransactionResponse lastRsp = comTransactionResponse[comTransactionResponse.Count - 1];
                /* The data part in response is made up of TransParameter and TransData, TransParameter is before TransData.
                 * when there is no TransData, only check whether TransParameters is sequential and completed,
                 * otherwise only check  whether TransData is sequential and completed.
                 * if TransData is completed, TransParameter must be completed
                */
                if (lastRsp.Response.TotalDataCount == 0 ?
                    IsFragmentsSequentialCompleted<SMBMessages.ComTransactionResponse>(comTransactionResponse,
                        (SMBMessages.ComTransactionResponse r) => r.Response.ParameterDisplacement == 0,
                        (SMBMessages.ComTransactionResponse r) => r.Response.ParameterDisplacement + r.Response.ParameterCount == r.Response.TotalParameterCount,
                        (SMBMessages.ComTransactionResponse r) => r.Response.ParameterDisplacement,
                        (SMBMessages.ComTransactionResponse r) => r.Response.ParameterDisplacement + r.Response.ParameterCount) :
                    IsFragmentsSequentialCompleted<SMBMessages.ComTransactionResponse>(comTransactionResponse,
                        (SMBMessages.ComTransactionResponse r) => r.Response.DataDisplacement == 0,
                        (SMBMessages.ComTransactionResponse r) => r.Response.DataDisplacement + r.Response.DataCount == r.Response.TotalDataCount,
                        (SMBMessages.ComTransactionResponse r) => r.Response.DataDisplacement,
                        (SMBMessages.ComTransactionResponse r) => r.Response.DataDisplacement + r.Response.DataCount))
                {
                    binary buffer = $[];
                    for (int j = 0; j < comTransactionResponse.Count; j++)
                    {
                        if (j == 0)
                        {
                            binary temp = comTransactionResponse[0].SourceData as binary;
                            buffer = temp.Segment(0, 39) + temp.Segment(33, 2) // make ParameterCount same as TotalParameterCount
                                 + temp.Segment(41, 4) + temp.Segment(35, 2) // make DataCount same as TotalDataCount
                                 + temp.Segment(47);
                        }
                        else
                        {
                            if (comTransactionResponse[j].Response.TransParameters != nothing)
                            {
                                buffer += comTransactionResponse[j].Response.TransParameters as binary;
                            }
                            if (comTransactionResponse[j].Response.TransData != nothing)
                            {
                                buffer += comTransactionResponse[j].Response.TransData as binary;
                            }
                        }
                    }
                    transMessages = transMessages.Remove(m.Mid);
                    ushort fid = 0;
                    if (m.Mid in dvar.FIDByMID)
                    {
                        fid = dvar.FIDByMID[m.Mid];
                        dvar.FIDByMID = dvar.FIDByMID.Remove(m.Mid);
                    }
                    optional ushort subcommand = nothing;
                    if (m.Mid in dvar.Subcommand)
                    {
                        subcommand = dvar.Subcommand[m.Mid];
                        dvar.Subcommand = dvar.Subcommand.Remove(m.Mid);
                    }
                    switch (buffer)
                    {
                        case msg:SMBMessages.ComTransactionResponse from BinaryDecoder<SMBMessages.ComTransactionResponse[subcommand]> =>
                            msg#SMBFileId = fid as ulong;
                            dispatch (endpoint FileServer[fid] over this) issues msg;
                        default =>
                            TryDecodeSMBHeaderOnlyMessage(buffer, "ComTransactionResponse");
                    }
                }
            }
        }
    }
    
    ~endpoint(LowestServer LowestServer)
    {
        if (transMessages.Count > 0)
        {
            foreach (ushort key in transMessages.Keys)
            {
                foreach (var m in transMessages[key])
                {
                    DisplayTopLevelMessage(m);
                }
            }
            transMessages = {};
        }
        dvar.FIDByMID = {};
        dvar.Subcommand = {};
    }
}

client endpoint LowestClient connected to LowestServer;

autostart actor SMBNamedPipeOverSmbTransport(Server server)
{
    process server accepts p:TransportPacket where p.SMBMessage.Segment(0,4) is $[FF534D42]
    {
        LowestServer lowestServer = endpoint LowestServer over server;
        NamedPipeDecodeAndDispatchMessages(lowestServer, p.SMBMessage, lowestServer.dvar);
    }

    // parsing response message
    process server issues p:TransportPacket where p.SMBMessage.Segment(0,4) is $[FF534D42]
    {
        LowestServer lowestServer = endpoint LowestServer over server;
        NamedPipeDecodeAndDispatchMessages(lowestServer, p.SMBMessage, lowestServer.dvar);
    }
}

autostart actor SmbOverNbtss(NBTSS.Server server)
{
    process server accepts p:NBTSS.SessionService where p.Trailer != nothing 
                                                        && p.Trailer is NBTSS.SessionMessagePacket 
                                                        && (p.Trailer as NBTSS.SessionMessagePacket).UserData.Segment(0,4) is $[FF534D42]
    {
        LowestServer lowestServer = endpoint LowestServer over server;
        NamedPipeDecodeAndDispatchMessages(lowestServer, (p.Trailer as NBTSS.SessionMessagePacket).UserData, lowestServer.dvar);
    }

    // parsing response message
    process server issues p:NBTSS.SessionService where p.Trailer != nothing 
                                                        && p.Trailer is NBTSS.SessionMessagePacket 
                                                        && (p.Trailer as NBTSS.SessionMessagePacket).UserData.Segment(0,4) is $[FF534D42]
    {
        LowestServer lowestServer = endpoint LowestServer over server;
        NamedPipeDecodeAndDispatchMessages(lowestServer, (p.Trailer as NBTSS.SessionMessagePacket).UserData, lowestServer.dvar);
    }
}

autostart actor SmbOverNbf(NBF.Node node)
{
    process node accepts p:NBF.NBFCommonHeader
    {
        LowestServer lowestServer = endpoint LowestServer over node;
        if (p is NBF.Datagram && (p as NBF.Datagram).Payload != nothing && ((p as NBF.Datagram).Payload as binary).Segment(0,4) is $[FF534D42])
        {
            NamedPipeDecodeAndDispatchMessages(lowestServer, ((p as NBF.Datagram).Payload as binary), lowestServer.dvar);
        }
        else if (p is NBF.DatagramBroadcast && (p as NBF.DatagramBroadcast).Payload != nothing && ((p as NBF.DatagramBroadcast).Payload as binary).Segment(0,4) is $[FF534D42])
        {
            NamedPipeDecodeAndDispatchMessages(lowestServer, ((p as NBF.DatagramBroadcast).Payload as binary), lowestServer.dvar);
        }
        else if (p is NBF.DataOnlyLast && (p as NBF.DataOnlyLast).UserData != nothing && ((p as NBF.DataOnlyLast).UserData as binary).Segment(0,4) is $[FF534D42])
        {
            NamedPipeDecodeAndDispatchMessages(lowestServer, ((p as NBF.DataOnlyLast).UserData as binary), lowestServer.dvar);
        }
        else
        {
            reject;
        }
    }
}

bool IsCompletedResponse(uint displacement, uint count, uint totalCount)
{
    return displacement == 0 && displacement + count == totalCount;
}

void DecodeTransactionResponse((LowestServer | FileServer) server, stream s, optional ushort subcommand, bool isGreater, byte wordCount, string msgName)
{
    ushort mid = MakeWord(s.PeekByte(248), s.PeekByte(240));
    switch (s)
    {
        case msg:SMBMessages.ComTransactionResponse from BinaryDecoder<SMBMessages.ComTransactionResponse[subcommand]> =>
            if (server is LowestServer)
            {
                dispatch (server as LowestServer) issues msg;
            }
            else
            {
                dispatch (server as FileServer) issues msg;
            }
            
        default =>
            TryDecodeSMBHeaderOnlyMessage(s, "ComTransactionResponse");
    }
}

void NamedPipeDecodeAndDispatchMessages(LowestServer server, stream s, DecoderVariables dvar)
{
    bool isRequest = ((s.PeekByte(72) & 0x80) == 0x00);
    byte command = s.PeekByte(32);
    
    if (IsErrorResponse(s))
    {
        switch (s)
        {
            case m:SMBMessages.NonPipeResponse from BinaryDecoder<SMBMessages.NonPipeResponse> =>
                dispatch server issues m;
            default =>
                TryDecodeSMBHeaderOnlyMessage(s, "Error Response");
        }
        return;
    }
    
    // Parsing message as per Command.
    switch (command)
    {
        case SmbCommand.SmbComTransaction =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:SMBMessages.ComTransactionRequest from BinaryDecoder<SMBMessages.ComTransactionRequest> =>
                        if (m.Request.SetupCount > 0)
                        {
                            dvar.Subcommand[m.Mid] = (m.Request.Subcommand) as USHORT;
                        }
                        if (s.BytePosition < s.ByteLength && m.Request.ParameterOffset > s.BytePosition)
                        {
                            int padLength = m.Request.ParameterOffset - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("Pad1", s.BitPosition, padLength * 8);
                            m.Request.Pad1 = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (s.BytePosition < s.ByteLength && m.Request.ParameterCount > 0)
                        {
                            m.Request.AssignFieldEncodingInfo("TransParameters", s.BitPosition, m.Request.ParameterCount * 8);
                            if (m.Request.SetupCount > 0)
                            {
                                m.Request.TransParameters = BinaryDecoder<TransactionSubCommandsRequestParameters[(m.Request.Subcommand) as USHORT, m.Request.ParameterCount]>(s);
                            }
                            else
                            {
                                m.Request.TransParameters = BinaryDecoder<Blob[(m.Request.ParameterCount) as uint]>(s);
                            }
                        }
                        if (s.BytePosition < s.ByteLength && m.Request.DataOffset > s.BytePosition)
                        {
                            int padLength = m.Request.DataCount > 0 ? (m.Request.DataOffset - s.BytePosition) : (s.ByteLength - s.BytePosition);
                            m.Request.AssignFieldEncodingInfo("Pad2", s.BitPosition, padLength * 8);
                            m.Request.Pad2 = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (s.BytePosition < s.ByteLength && m.Request.DataCount > 0)
                        {
                            int dataCount = m.Request.DataCount > s.RemainingLength ? s.RemainingLength : m.Request.DataCount;
                            m.Request.AssignFieldEncodingInfo("TransData", s.BitPosition, dataCount * 8);
                            m.Request.TransData = (BinaryDecoder<Blob[dataCount as uint]>(s) as Blob).Data;
                            if (dataCount < m.Request.DataCount)
                            {
                                ReportInsufficientData(m, "NamedPipe", "TransData", "ComTransactionRequest", !dvar.pduFull);
                                
                                DisplayTopLevelMessage(m);
                            }
                        }
                        dispatch server accepts m;
                    default =>
                        TryDecodeSMBHeaderOnlyMessage(s, "ComTransactionRequest");
                }
            }
            else // response
            {
                ushort mid = MakeWord(s.PeekByte(248), s.PeekByte(240));
                optional ushort subcommand = mid in dvar.Subcommand.Keys ? dvar.Subcommand[mid] : nothing;
                switch (s)
                {
                    case msg:SMBMessages.ComTransactionResponse from BinaryDecoder<SMBMessages.ComTransactionResponse[subcommand]> =>
                            dispatch server issues msg;
                    default =>
                        TryDecodeSMBHeaderOnlyMessage(s, "ComTransactionResponse");
                }
            }
        case SmbCommand.SmbComReadAndx =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:SMBMessages.ComReadAndxRequest from BinaryDecoder<SMBMessages.ComReadAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXRequestsData", s.BitPosition, s.RemainingLength * 8);
                            m.AndXRequestsData = s.PeekBytes(s.BitPosition);
                        }
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeSMBHeaderOnlyMessage(s, "ComReadAndxRequest");
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:SMBMessages.ComReadAndxResponse from BinaryDecoder<SMBMessages.ComReadAndxResponse> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        int dataLength1 = m.Response.DataLength < m.Response.ByteCount ? (m.Response.DataLength + (m.Response.DataLengthHigh << 16)) : m.Response.DataLength;
                        int dataLength = dataLength1 > s.RemainingLength ? s.RemainingLength : dataLength1;
                        m.Response.AssignFieldEncodingInfo("Data", s.BitPosition, dataLength * 8);
                        m.Response.Data = (BinaryDecoder<Blob[dataLength as uint]>(s) as Blob).Data;
                        if (dataLength < dataLength1)
                        {
                            ReportInsufficientData(m, "NamedPipe", "Data", "ComReadAndxResponse", !dvar.pduFull);                            
                            DisplayTopLevelMessage(m);
                        }
                        else
                        {
                            if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                            {
                                int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                                m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                                m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                            }
                            if (m.Response.AndXCommand != 0xff)
                            {
                                m.AssignFieldEncodingInfo("AndXResponsesData", s.BitPosition, s.RemainingLength * 8);
                                m.AndXResponsesData = s.PeekBytes(s.BitPosition);
                            }
                            dispatch server issues m;
                        }
                        
                    default =>
                        TryDecodeSMBHeaderOnlyMessage(s, "ComReadAndxResponse");
                }
            }
        case SmbCommand.SmbComWriteAndx =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:SMBMessages.ComWriteAndxRequest from BinaryDecoder<SMBMessages.ComWriteAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        int dataLength1 = m.Request.DataLength < m.Request.ByteCount ? (m.Request.DataLength + (m.Request.DataLengthHigh << 16)) : m.Request.DataLength;
                        int dataLength = dataLength1 > s.RemainingLength ? s.RemainingLength : dataLength1;
                        m.Request.AssignFieldEncodingInfo("Data", s.BitPosition, dataLength * 8);
                        m.Request.Data = (BinaryDecoder<Blob[dataLength as uint]>(s) as Blob).Data;
                        if (dataLength < dataLength1)
                        {
                            ReportInsufficientData(m, "NamedPipe", "Data", "ComWriteAndxRequest", !dvar.pduFull);
                            DisplayTopLevelMessage(m);
                        }
                        else
                        {
                            if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                            {
                                int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                                m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                                m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                            }
                            if (m.Request.AndXCommand != 0xff)
                            {
                                m.AssignFieldEncodingInfo("AndXRequestsData", s.BitPosition, s.RemainingLength * 8);
                                m.AndXRequestsData = s.PeekBytes(s.BitPosition);
                            }
                            dispatch server accepts m;
                        }
                        
                    default =>
                        TryDecodeSMBHeaderOnlyMessage(s, "ComWriteAndxRequest");
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:SMBMessages.ComWriteAndxResponse from BinaryDecoder<SMBMessages.ComWriteAndxResponse> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                            m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Response.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXResponsesData", s.BitPosition, s.RemainingLength * 8);
                            m.AndXResponsesData = s.PeekBytes(s.BitPosition);
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeSMBHeaderOnlyMessage(s, "ComWriteAndxResponse");
                }
            }
        case SmbCommand => 
            if (isRequest)
            {
                switch (s)
                {
                    case m:SMBMessages.NonPipeRequest from BinaryDecoder =>
                        dispatch server accepts m;
                    default =>
                        TryDecodeSMBHeaderOnlyMessage(s, "NonPipeRequest");
                }
            }
            else
            {
                switch (s)
                {
                    case m:SMBMessages.NonPipeResponse from BinaryDecoder =>
                        dispatch server issues m;
                    default =>
                        TryDecodeSMBHeaderOnlyMessage(s, "NonPipeResponse"); 
                }
            }
        default =>
            throw ("NamedPipe: Unknown SMB command: " + command.ToString() + ".");
    }
    return;
}

void TryDecodeSMBHeaderOnlyMessage(stream s, string msgName)
{
    bool isRequest = ((s.PeekByte(9 * 8) as int) & 0x80) == 0;
    switch (s)
    {
        case m:SMBHeaderOnly from BinaryDecoder<SMBHeaderOnly[isRequest]> =>
            DisplayTopLevelMessage(m);
        default =>
            ThrowDecodingException("NamedPipe", msgName);
    }
}

bool IsErrorResponse(stream s)
{
    bool ret = true;
    if (s.PeekBytes(s.BitPosition + 32 * 8, 1) != $[00]) // WordCount != 0
    {
        ret = false;
    }
    else if ((s.PeekByte(88) & 0x4000) > 0 && (s.PeekByte(64) & 0xC0) == 0) // NTSTATUS Severity != 3
    {
        ret = false;
    }
    else if ((s.PeekByte(88) & 0x4000) == 0 && (s.PeekByte(40) & 0xFF) == 0) // SMBStatus ErrorClass == 0
    {
        ret = false;
    }
    return ret;
}

autostart actor MsrpceOverSmbNamedPipeServer(SMBServer server)
{
    binary incompleteRequestSourceData = $[];
    binary incompleteResponseSourceData = $[];
    array<any message> requestMsgOrigins = [];
    array<any message> responseMsgOrigins = [];
    
    process server accepts s:SMBMessages.ComTransactionRequest where s.Request.TransData != nothing && (incompleteRequestSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Request.TransData as binary))
    {
        // set status nothing for request, because Status is meaningless for request messages
        var reasseblyServer = endpoint ServerOverNamedpipe[s.Request.Fid != nothing ? s.Request.Fid as ulong : 0];
        MsrpceProcessSmbMessages(reasseblyServer, s.Request.TransData as binary, ref incompleteRequestSourceData, nothing, ref requestMsgOrigins, s, CoReassemblyAcceptsDispatcher);
    }

    process server issues s:SMBMessages.ComTransactionResponse where s.Response.TransData is binary && (incompleteResponseSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Response.TransData as binary))
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s#SMBFileId != nothing ? s#SMBFileId as ulong : 0];
        MsrpceProcessSmbMessages(reasseblyServer, s.Response.TransData as binary, ref incompleteResponseSourceData, s.Status, ref responseMsgOrigins, s, CoReassemblyIssuesDispatcher);
    }

    process server accepts s:SMBMessages.ComWriteAndxRequest where s.Request.Data != nothing && (incompleteRequestSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Request.Data as binary))
    {
        // set status nothing for request, because Status is meaningless for request messages
        var reasseblyServer = endpoint ServerOverNamedpipe[s.Request.Fid as ulong];
        MsrpceProcessSmbMessages(reasseblyServer, s.Request.Data as binary, ref incompleteRequestSourceData, nothing, ref requestMsgOrigins, s, CoReassemblyAcceptsDispatcher);
    }

    process server issues s:SMBMessages.ComReadAndxResponse where s.Response.Data != nothing && (incompleteResponseSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Response.Data as binary))
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s#SMBFileId != nothing ? s#SMBFileId as ulong : 0];
        MsrpceProcessSmbMessages(reasseblyServer, s.Response.Data as binary, ref incompleteResponseSourceData, s.Status, ref responseMsgOrigins, s, CoReassemblyIssuesDispatcher);
    }
    
    ~endpoint(SMBServer server)
    {
        DispatchOriginsToRevive(ref requestMsgOrigins);
        DispatchOriginsToRevive(ref responseMsgOrigins);
    }
}

// Message and contract
message SMBHeaderOnly[bool IsRequest] : SmbHeader
{
    override string ToString()
    {
        string summary = "SMB " + GetSMBCommandNameWithoutSpace(Command);
        if (IsRequest)
        {
            summary += "Request, Header Only";
        }
        else
        {
            summary += "Response, Header Only, Status: " + SmbStatusValuesToText(Status);
        }
        return summary;
    }
}

contract SMBMessages
{
    accepts ComTransactionRequest : SmbHeader
    {
        SmbComTransactionRequest[(Flags2 & 0x8000) == 0x8000] Request;
        
        override string ToString()
        {
            if (Request.SetupCount > 0)
            {
                return "SMB ComTransactionRequest, Subcommand: " + GetTransactionSubcommandName(Request.SetupCount, Request.Subcommand as ushort);
            }
            else
            {
                return "SMB ComTransactionRequest, Remote Administration Protocol";
            }
        }
    }
    
    issues ComTransactionResponse[optional ushort Subcommand] : SmbHeader
    {
        SmbComTransactionResponse[(Flags2 & 0x8000) == 0x8000, Subcommand] Response;
        
        override string ToString()
        {
            return "SMB ComTransactionResponse" + ", Status: " + SmbStatusValuesToText(Status);
        }
    }

    accepts ComReadAndxRequest : SmbHeader
    {
        SmbComReadAndxRequest Request;
        optional binary AndXRequestsData with Encoding{Ignore = true};
        
        override string ToString()
        {
            return "SMB ComReadAndxRequest";
        }
    }
    
    issues ComReadAndxResponse : SmbHeader
    {
        SmbComReadAndxResponse[(Flags2 & 0x8000) == 0x8000] Response;
        optional binary AndXResponsesData with Encoding{Ignore = true};
        
        override string ToString()
        {
            return "SMB ComReadAndxResponse, Status: " + SmbStatusValuesToText(Status);
        }
    }

    accepts ComWriteAndxRequest : SmbHeader
    {
        SmbComWriteAndxRequest Request;
        optional binary AndXRequestsData with Encoding{Ignore = true};
        
        override string ToString()
        {
            return "SMB ComWriteAndxRequest";
        }
    }
    
    issues ComWriteAndxResponse : SmbHeader
    {
        SmbComWriteAndxResponse Response;
        optional binary AndXResponsesData with Encoding{Ignore = true};
        
        override string ToString()
        {
            return "SMB ComWriteAndxResponse" + ", Status: " + SmbStatusValuesToText(Status);
        }
    }

    accepts NonPipeRequest : SmbHeader
    {
        binary Request; 
        
        override string ToString()
        {
            return "SMB " + GetSMBCommandNameWithoutSpace(Command) + "Reqeust";
        }
    }
    
    issues NonPipeResponse : SmbHeader
    {
        binary Response; 
        
        override string ToString()
        {
            return "SMB " + GetSMBCommandNameWithoutSpace(Command) + "Response, Status: " + SmbStatusValuesToText(Status);
        }
    }
    
}

message SmbHeader
{
    ULONG Protocol with BinaryEncoding{Endian = Endian.Big}, DisplayInfo{ToText = GetProtocolString};
    SmbCommand Command with DisplayInfo{ToText = GetCommandString};
    NTSTATUS Status with DisplayInfo{ToText = GetStatusString};
    SmbHeaderFlags Flags;
    SmbHeaderFlags2 Flags2;
    USHORT PidHigh;
    SmbHeaderSecurityfeatures SecurityFeatures;
    USHORT Reserved;
    USHORT Tid;
    USHORT PidLow;
    USHORT Uid;
    USHORT Mid;
    
    static string GetProtocolString(any data)
    {
        return "SMB";
    }
    
    static string GetCommandString(any data)
    {
        UCHAR command = data as UCHAR;
        return (GetSMBCommandNameWithoutSpace(command) + ", " + (command as string) + "(" + Utility.DecToHexFormat(2, command) + ")");
    }
    
    static string GetStatusString(any data)
    {
        NTSTATUS status = data as NTSTATUS;
        return ("" + Utility.DecToHexFormat(8, status as uint) + ", " + SmbStatusValuesToText(status));
    }
}

pattern SmbCommand = enum byte
{
    SmbComCreateDirectory       = 0x00,
    SmbComDeleteDirectory       = 0x01,
    SmbComOpen                  = 0x02,
    SmbComCreate                = 0x03,
    SmbComClose                 = 0x04,
    SmbComFlush                 = 0x05,
    SmbComDelete                = 0x06,
    SmbComRename                = 0x07,
    SmbComQueryInformation      = 0x08,
    SmbComSetInformation        = 0x09,
    SmbComRead                  = 0x0A,
    SmbComWrite                 = 0x0B,
    SmbComLockByteRange         = 0x0C,
    SmbComUnlockByteRange       = 0x0D,
    SmbComCreateTemporary       = 0x0E,
    SmbComCreateNew             = 0x0F,
    SmbComCheckDirectory        = 0x10,
    SmbComProcessExit           = 0x11,
    SmbComSeek                  = 0x12,
    SmbComLockAndRead           = 0x13,
    SmbComWriteAndUnlock        = 0x14,
    SmbComReadRaw               = 0x1A,
    SmbComReadMpx               = 0x1B,
    SmbComReadMpxSecondary      = 0x1C,
    SmbComWriteRaw              = 0x1D,
    SmbComWriteMpx              = 0x1E,
    SmbComWriteMpxSecondary     = 0x1F, // Obsolated
    SmbComWriteComplete         = 0x20, // Obsolated
    SmbComQueryServer           = 0x21, // Obsolated
    SmbComSetInformation2       = 0x22,
    SmbComQueryInformation2     = 0x23,
    SmbComLockingAndx           = 0x24,
    SmbComTransaction           = 0x25,
    SmbComTransactionSecondary  = 0x26,
    SmbComIoctl                 = 0x27,
    SmbComIoctlSecondary        = 0x28, // Obsolated
    SmbComCopy                  = 0x29, // Obsolated
    SmbComMove                  = 0x2A, // Obsolated
    SmbComEcho                  = 0x2B,
    SmbComWriteAndClose         = 0x2C,
    SmbComOpenAndx              = 0x2D,
    SmbComReadAndx              = 0x2E,
    SmbComWriteAndx             = 0x2F,
    SmbComNewFileSize           = 0x30, // Obsolated
    SmbComCloseAndTreeDisc      = 0x31, // Obsolated
    SmbComTransaction2          = 0x32,
    SmbComTransaction2Secondary = 0x33,
    SmbComFindClose2            = 0x34,
    SmbComFindNotifyClose       = 0x35, // Obsolated
    SmbComTreeConnect           = 0x70,
    SmbComTreeDisconnect        = 0x71,
    SmbComNegotiate             = 0x72,
    SmbComSessionSetupAndx      = 0x73,
    SmbComLogoffAndx            = 0x74,
    SmbComTreeConnectAndx       = 0x75,
    SmbComSecurityPackageAndx   = 0x7E, // Obsolated
    SmbComQueryInformationDisk  = 0x80,
    SmbComSearch                = 0x81,
    SmbComFind                  = 0x82,
    SmbComFindUnique            = 0x83,
    SmbComFindClose             = 0x84,
    SmbComNTTransact            = 0xA0,
    SmbComNTTransactSecondary   = 0xA1,
    SmbComNTCreateAndx          = 0xA2,
    SmbComNTCancel              = 0xA4,
    SmbComNTRename              = 0xA5,
    SmbComOpenPrintFile         = 0xC0,
    SmbComWritePrintFile        = 0xC1,
    SmbComClosePrintFile        = 0xC2,
    SmbComGetPrintQueue         = 0xC3, // Obsolated
    SmbComReadBulk              = 0xD8, // Obsolated
    SmbComWriteBulk             = 0xD9, // Obsolated
    SmbComWriteBulkData         = 0xDA, // Obsolated
    SmbComInvalid               = 0xFE, // Obsolated
    SmbComNOAndxCommand         = 0xFF // Obsolated
};

string GetSMBCommandNameWithoutSpace(UCHAR command)
{
    switch (command)
    {
        case 0x00 => return "CreateDirectory";
        case 0x01 => return "DeleteDirectory";
        case 0x02 => return "Open";
        case 0x03 => return "Create";
        case 0x04 => return "Close";
        case 0x05 => return "Flush";
        case 0x06 => return "Delete";
        case 0x07 => return "Rename";
        case 0x08 => return "QueryInformation";
        case 0x09 => return "SetInformation";
        case 0x0A => return "Read";
        case 0x0B => return "Write";
        case 0x0C => return "LockByteRange";
        case 0x0D => return "UnlockByteRange";
        case 0x0E => return "CreateTemporary";
        case 0x0F => return "Create New";
        case 0x10 => return "CheckDirectory";
        case 0x11 => return "ProcessExit";
        case 0x12 => return "Seek";
        case 0x13 => return "LockAndRead";
        case 0x14 => return "WriteAndUnlock";
        case 0x1A => return "ReadRaw";
        case 0x1B => return "ReadMpx";
        case 0x1C => return "ReadMpxSecondary";
        case 0x1D => return "WriteRaw";
        case 0x1E => return "WriteMpx";
        case 0x1F => return "WriteMpxSecondary"; // Obsolated
        case 0x20 => return "WriteComplete"; // Obsolated
        case 0x21 => return "QueryServer"; // Obsolated
        case 0x22 => return "SetInformation2";
        case 0x23 => return "QueryInformation2";
        case 0x24 => return "LockingAndx";
        case 0x25 => return "Transaction";
        case 0x26 => return "TransactionSecondary";
        case 0x27 => return "Ioctl";
        case 0x28 => return "IoctlSecondary"; // Obsolated
        case 0x29 => return "Copy"; // Obsolated
        case 0x2A => return "Move"; // Obsolated
        case 0x2B => return "Echo";
        case 0x2C => return "WriteAndClose";
        case 0x2D => return "OpenAndx";
        case 0x2E => return "ReadAndx";
        case 0x2F => return "WriteAndx";
        case 0x30 => return "NewFileSize"; // Obsolated
        case 0x31 => return "CloseAndTreeDisc"; // Obsolated
        case 0x32 => return "Transaction2";
        case 0x33 => return "Transaction2 Secondary";
        case 0x34 => return "FindClose2";
        case 0x35 => return "FindNotifyClose"; // Obsolated
        case 0x70 => return "TreeConnect";
        case 0x71 => return "TreeDisconnect";
        case 0x72 => return "Negotiate";
        case 0x73 => return "SessionSetupAndx";
        case 0x74 => return "LogoffAndx";
        case 0x75 => return "TreeConnectAndx";
        case 0x7E => return "SecurityPackageAndx"; // Obsolated
        case 0x80 => return "QueryInformationDisk";
        case 0x81 => return "Search";
        case 0x82 => return "Find";
        case 0x83 => return "FindUnique";
        case 0x84 => return "FindClose";
        case 0xA0 => return "NTTransact";
        case 0xA1 => return "NTTransactSecondary";
        case 0xA2 => return "NTCreate Andx";
        case 0xA4 => return "NTCancel";
        case 0xA5 => return "NTRename";
        case 0xC0 => return "OpenPrintFile";
        case 0xC1 => return "WritePrintFile";
        case 0xC2 => return "ClosePrintFile";
        case 0xC3 => return "GetPrintQueue"; // Obsolated
        case 0xD8 => return "ReadBulk"; // Obsolated
        case 0xD9 => return "WriteBulk"; // Obsolated
        case 0xDA => return "WriteBulk Data"; // Obsolated
        case 0xFE => return "Invalid"; // Obsolated
        case 0xFF => return "NOAndxCommand"; // Obsolated
        default => return "Unknown command: " + Utility.DecToHexFormat(command);
    }
}

string SmbStatusValuesToText(uint code)
{
    if (code in SmbNtStatusMap)
    {
        return SmbNtStatusMap[code];
    }
    else
    {
        return NtStatusValuesToText(code);
    }
}

// 2.2.2.4   SMB Error Classes and Codes
map<uint, string> SmbNtStatusMap =
{
    0x00000000 -> "STATUS_SUCCESS",
    0x00010002 -> "STATUS_INVALID_SMB",
    0x00050002 -> "STATUS_SMB_BAD_TID",
    0x00160002 -> "STATUS_SMB_BAD_COMMAND",
    0x005B0002 -> "STATUS_SMB_BAD_UID",
    0x00FB0002 -> "STATUS_SMB_USE_STANDARD",
    0x80000005 -> "STATUS_BUFFER_OVERFLOW",
    0x80000006 -> "STATUS_NO_MORE_FILES",
    0x8000002D -> "STATUS_STOPPED_ON_SYMLINK",
    0xC0000002 -> "STATUS_NOT_IMPLEMENTED",
    0xC000000D -> "STATUS_INVALID_PARAMETER",
    0xC000000E -> "STATUS_NO_SUCH_DEVICE",
    0xC0000010 -> "STATUS_INVALID_DEVICE_REQUEST",
    0xC0000016 -> "STATUS_MORE_PROCESSING_REQUIRED",
    0xC0000022 -> "STATUS_ACCESS_DENIED",
    0xC0000023 -> "STATUS_BUFFER_TOO_SMALL",
    0xC0000034 -> "STATUS_OBJECT_NAME_NOT_FOUND",
    0xC0000035 -> "STATUS_OBJECT_NAME_COLLISION",
    0xC000003A -> "STATUS_OBJECT_PATH_NOT_FOUND",
    0xC00000A5 -> "STATUS_BAD_IMPERSONATION_LEVEL",
    0xC00000B5 -> "STATUS_IO_TIMEOUT",
    0xC00000BA -> "STATUS_FILE_IS_A_DIRECTORY",
    0xC00000BB -> "STATUS_NOT_SUPPORTED",
    0xC00000C9 -> "STATUS_NETWORK_NAME_DELETED",
    0xC0000203 -> "STATUS_USER_SESSION_DELETED",
    0xC000035C -> "STATUS_NETWORK_SESSION_EXPIRED",
    0xC000205A -> "STATUS_SMB_TOO_MANY_UIDS",
    0xC0000002 -> "STATUS_NOT_IMPLEMENTED",
    0xC00000AF -> "STATUS_ILLEGAL_FUNCTION",
    0xC000000F -> "STATUS_NO_SUCH_FILE",
    0xC0000039 -> "STATUS_OBJECT_PATH_INVALID",
    0xC000003B -> "STATUS_OBJECT_PATH_SYNTAX_BAD",
    0xC000009B -> "STATUS_DFS_EXIT_PATH_FOUND",
    0xC00000FB -> "STATUS_REDIRECTOR_NOT_STARTED",
    0xC000011F -> "STATUS_TOO_MANY_OPENED_FILES",
    0xC000001E -> "STATUS_INVALID_LOCK_SEQUENCE",
    0xC000001F -> "STATUS_INVALID_VIEW_SIZE",
    0xC0000021 -> "STATUS_ALREADY_COMMITTED",
    0xC0000041 -> "STATUS_PORT_CONNECTION_REFUSED",
    0xC000004B -> "STATUS_THREAD_IS_TERMINATING",
    0xC0000056 -> "STATUS_DELETE_PENDING",
    0xC0000061 -> "STATUS_PRIVILEGE_NOT_HELD",
    0xC000006D -> "STATUS_LOGON_FAILURE",
    0xC00000D5 -> "STATUS_FILE_RENAMED",
    0xC000010A -> "STATUS_PROCESS_IS_TERMINATING",
    0xC0000101 -> "STATUS_DIRECTORY_NOT_EMPTY",
    0xC0000121 -> "STATUS_CANNOT_DELETE",
    0xC0000123 -> "STATUS_FILE_DELETED",
    0x00060001 -> "STATUS_SMB_BAD_FID",
    0xC0000008 -> "STATUS_INVALID_HANDLE",
    0xC0000024 -> "STATUS_OBJECT_TYPE_MISMATCH",
    0xC0000037 -> "STATUS_PORT_DISCONNECTED",
    0xC0000042 -> "STATUS_INVALID_PORT_HANDLE",
    0xC0000128 -> "STATUS_FILE_CLOSED",
    0xC0000235 -> "STATUS_HANDLE_NOT_CLOSABLE",
    0xC0000040 -> "STATUS_SECTION_TOO_BIG",
    0xC0000097 -> "STATUS_TOO_MANY_PAGING_FILES",
    0xC0000205 -> "STATUS_INSUFF_SERVER_RESOURCES",
    0x000C0001 -> "STATUS_OS2_INVALID_ACCESS",
    0xC0000022 -> "STATUS_ACCESS_DENIED",
    0xC000009C -> "STATUS_DATA_ERROR",
    0xC00000D4 -> "STATUS_NOT_SAME_DEVICE",
    0x80000006 -> "STATUS_NO_MORE_FILES",
    0xC0000001 -> "STATUS_UNSUCCESSFUL",
    0xC0000043 -> "STATUS_SHARING_VIOLATION",
    0xC0000054 -> "STATUS_FILE_LOCK_CONFLICT",
    0xC0000055 -> "STATUS_LOCK_NOT_GRANTED",
    0xC0000011 -> "STATUS_END_OF_FILE",
    0XC00000BB -> "STATUS_NOT_SUPPORTED",
    0xC0000035 -> "STATUS_OBJECT_NAME_COLLISION",
    0xC000000D -> "STATUS_INVALID_PARAMETER",
    0x007C0001 -> "STATUS_OS2_INVALID_LEVEL",
    0x00830001 -> "STATUS_OS2_NEGATIVE_SEEK",
    0xC000007E -> "STATUS_RANGE_NOT_LOCKED",
    0x00710001 -> "STATUS_OS2_NO_MORE_SIDS",
    0x00AD0001 -> "STATUS_OS2_CANCEL_VIOLATION",
    0x00AE0001 -> "STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED",
    0xC0000003 -> "STATUS_INVALID_INFO_CLASS",
    0xC00000AD -> "STATUS_INVALID_PIPE_STATE",
    0xC00000B4 -> "STATUS_INVALID_READ_MODE",
    0x010A0001 -> "STATUS_OS2_CANNOT_COPY",
    0xC00000AB -> "STATUS_INSTANCE_NOT_AVAILABLE",
    0xC00000AC -> "STATUS_PIPE_NOT_AVAILABLE",
    0xC00000AE -> "STATUS_PIPE_BUSY",
    0xC00000B1 -> "STATUS_PIPE_CLOSING",
    0xC00000D9 -> "STATUS_PIPE_EMPTY",
    0xC00000B0 -> "STATUS_PIPE_DISCONNECTED",
    0x80000005 -> "STATUS_BUFFER_OVERFLOW",
    0xC0000016 -> "STATUS_MORE_PROCESSING_REQUIRED",
    0xC0000050 -> "STATUS_EA_TOO_LARGE",
    0x01130001 -> "STATUS_OS2_EAS_DIDNT_FIT",
    0xC000004F -> "STATUS_EAS_NOT_SUPPORTED",
    0x03E20001 -> "STATUS_OS2_EA_ACCESS_DENIED",
    0x0000010C -> "STATUS_NOTIFY_ENUM_DIR",
    0x00010002 -> "STATUS_INVALID_SMB",
    0xC000006A -> "STATUS_WRONG_PASSWORD",
    0xC0000257 -> "STATUS_PATH_NOT_COVERED",
    0xC00000CA -> "STATUS_NETWORK_ACCESS_DENIED",
    0xC00000C9 -> "STATUS_NETWORK_NAME_DELETED",
    0x00050002 -> "STATUS_SMB_BAD_TID",
    0xC00000CC -> "STATUS_BAD_NETWORK_NAME",
    0xC00000CB -> "STATUS_BAD_DEVICE_TYPE",
    0x00160002 -> "STATUS_SMB_BAD_COMMAND",
    0xC00000C6 -> "STATUS_PRINT_QUEUE_FULL",
    0xC00000C7 -> "STATUS_NO_SPOOL_SPACE",
    0xC00000C8 -> "STATUS_PRINT_CANCELLED",
    0xC0000002 -> "STATUS_NOT_IMPLEMENTED",
    0xC00000C4 -> "STATUS_UNEXPECTED_NETWORK_ERROR",
    0xC00000B5 -> "STATUS_IO_TIMEOUT",
    0xC00000D0 -> "STATUS_REQUEST_NOT_ACCEPTED",
    0xC00000CE -> "STATUS_TOO_MANY_SESSIONS",
    0x005B0002 -> "STATUS_SMB_BAD_UID",
    0x00FA0002 -> "STATUS_SMB_USE_MPX",
    0x00FB0002 -> "STATUS_SMB_USE_STANDARD",
    0x00FC0002 -> "STATUS_SMB_CONTINUE_MPX",
    0xC0000072 -> "STATUS_ACCOUNT_DISABLED",
    0xC0000193 -> "STATUS_ACCOUNT_EXPIRED",
    0xC0000070 -> "STATUS_INVALID_WORKSTATION",
    0xC000006F -> "STATUS_INVALID_LOGON_HOURS",
    0xC0000071 -> "STATUS_PASSWORD_EXPIRED",
    0xC0000224 -> "STATUS_PASSWORD_MUST_CHANGE",
    0XFFFF0002 -> "STATUS_SMB_NO_SUPPORT",
    0xC00000A2 -> "STATUS_MEDIA_WRITE_PROTECTED",
    0xC0000013 -> "STATUS_NO_MEDIA_IN_DEVICE",
    0xC0000184 -> "STATUS_INVALID_DEVICE_STATE",
    0xC000003E -> "STATUS_DATA_ERROR",
    0xC000003F -> "STATUS_CRC_ERROR",
    0xC0000032 -> "STATUS_DISK_CORRUPT_ERROR",
    0xC0000015 -> "STATUS_NONEXISTENT_SECTOR",
    0x8000000E -> "STATUS_DEVICE_PAPER_EMPTY",
    0xC0000043 -> "STATUS_SHARING_VIOLATION",
    0xC0000054 -> "STATUS_FILE_LOCK_CONFLICT",
    0xC0000012 -> "STATUS_WRONG_VOLUME",
    0xC000007F -> "STATUS_DISK_FULL"
};

string GetTransactionSubcommandName(UCHAR setupCount, USHORT subcommand)
{
    if (setupCount <= 2)
    {
        switch (subcommand)
        {
            case 0x01 => return "Named Pipe, Set named pipe state";
            case 0x11 => return "Named Pipe, Raw read named pipe";
            case 0x21 => return "Named Pipe, Query named pipe state";
            case 0x22 => return "Named Pipe, Query named pipe info";
            case 0x23 => return "Named Pipe, peek named pipe";
            case 0x26 => return "Named Pipe, Transact named pipe";
            case 0x31 => return "Named Pipe, Raw write named pipe";
            case 0x36 => return "Named Pipe, Read named pipe";
            case 0x37 => return "Named Pipe, Write named pipe";
            case 0x53 => return "Named Pipe, Wait named pipe";
            case 0x54 => return "Named Pipe, Call named pipe";
            default   => return "Named Pipe, Unknown subcommand";
        }
    }
    else if (setupCount > 2)
    {
        switch (subcommand)
        {
            case 0x01 => return "Mail slot, Mail slot write";
            default   => return "Mail slot, Unknown subcommand";
        }
    }
    else
    {
        return "";
    }
}

type SmbString[bool IsFlags2Unicode]
{
    string Value with BinaryEncoding{TextEncoding = (IsFlags2Unicode ? TextEncoding.UTF16 : TextEncoding.ASCII)};
}

pattern SmbHeaderFlags = flags byte
{
    SmbFlagsLockAndReadOk      = 0x01,
    SmbFlagsBufAvail           = 0x02,
    Reserved                   = 0x04,
    SmbFlagsCaseInsensitive    = 0x08,
    SmbFlagsCanonicalizedPaths = 0x10,
    SmbFlagsOplock             = 0x20,
    SmbFlagsOpbatch            = 0x40,
    SMBFlagsReply              = 0x80,
    ...
};

pattern SmbHeaderFlags2 = flags ushort
{
    SmbFlags2LongNames                 = 0x0001,
    SmbFlags2Eas                       = 0x0002,
    SmbFlags2SmbSecuritySignature      = 0x0004,
    SmbFlags2Compressed                = 0x0008,
    SmbFlags2SecuritySignatureRequired = 0x0010,
    Reserved                           = 0x0020,
    SmbFlags2IsLong_Name               = 0x0040,
    Reserved2                          = 0x0380,
    SmbFlags2ReparsePath               = 0x0400,
    SmbFlags2ExtendedSecurity          = 0x0800,
    SmbFlags2Dfs                       = 0x1000,
    SmbFlags2PagingIO                  = 0x2000,
    SmbFlags2NTStatus                  = 0x4000,
    SmbFlags2Unicode                   = 0x8000,
    ...
};

type SmbHeaderSecurityfeatures
{
    binary SecuritySignature with BinaryEncoding{Length = 8};
}

// 2.2.4.33   SMB_COM_TRANSACTION (0x25)
type SmbComTransactionRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount;
    USHORT TotalParameterCount;
    USHORT TotalDataCount;
    USHORT MaxParameterCount;
    USHORT MaxDataCount;
    UCHAR MaxSetupCount;
    UCHAR Reserved1;
    SmbComTransactionRequestParametersWordsFlags Flags;
    ULONG Timeout;
    USHORT Reserved2;
    USHORT ParameterCount;
    USHORT ParameterOffset;
    USHORT DataCount;
    USHORT DataOffset;
    UCHAR SetupCount;
    UCHAR Reserved3;
    optional [|SetupCount > 0|] USHORT Subcommand;
    optional [|SetupCount > 1 && (Subcommand as USHORT) in {0x01, 0x11, 0x21, 0x22, 0x23, 0x26, 0x31, 0x36, 0x37}|] USHORT Fid;
    optional [|SetupCount > 1 && (Subcommand as USHORT) in {0x53, 0x54}|] USHORT Priority;
    optional [|SetupCount > 2|] array<USHORT> Setup with BinaryEncoding{Length = (SetupCount - 2) as uint};
    USHORT ByteCount;
    optional [|ByteCount > 0 && IsFlags2Unicode|] UCHAR Pad;
    optional [|ByteCount > 0|] SmbString[IsFlags2Unicode] Name;
    optional binary Pad1 with Encoding{Ignore = true};
    optional (TransactionSubCommandsRequestParameters | Blob) TransParameters with Encoding{Ignore = true};
    optional binary Pad2 with Encoding{Ignore = true};
    optional binary TransData with Encoding{Ignore = true};
}

// 2.2.4.33   SMB_COM_TRANSACTION (0x25)
type SmbComTransactionResponse[bool IsFlags2Unicode, optional ushort Subcommand]
{
    UCHAR WordCount;
    USHORT TotalParameterCount;
    USHORT TotalDataCount;
    USHORT Reserved1;
    USHORT ParameterCount;
    USHORT ParameterOffset;
    USHORT ParameterDisplacement;
    USHORT DataCount;
    USHORT DataOffset;
    USHORT DataDisplacement;
    UCHAR SetupCount;
    UCHAR Reserved2;
    USHORT ByteCount;
    optional [|ParameterOffset > 35 + WordCount * 2|] binary Pad1 with BinaryEncoding{Length = (ParameterOffset - 32 - WordCount * 2 - 3) as uint};
    optional [|ParameterCount > 0|] ([|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x21|] TransQueryNmpipeStateResponseTransParameters //0x21
            | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x23|] TransPeekNmpipeResponseTransParameters //0x23
            | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x31|] TransRawWriteNmpipeResponseTransParameters //0x31
            | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x37|] TransWriteNmpipeResponseTransParameters //0x37
            | [|DataOffset != ParameterOffset|] Blob[ParameterCount as uint]) TransParameters;
    optional [|ParameterOffset > 0 ? DataOffset > ParameterOffset + ParameterCount : DataOffset > 35 + WordCount * 2|] binary Pad2 
        with BinaryEncoding{Length = (ParameterOffset > 0 ? DataOffset - ParameterOffset - ParameterCount : DataOffset - 35 - WordCount * 2) as uint};
    optional [|DataCount > 0|] ([|TotalDataCount == DataCount && Subcommand != nothing && (Subcommand as ushort) == 0x21|] SmbNMPipeStatus //0x21
            | [|TotalDataCount == DataCount && Subcommand != nothing && (Subcommand as ushort) == 0x22|] TransQueryNmpipeInfoResponse[IsFlags2Unicode]
            | binary) TransData;
}

pattern SmbComTransactionRequestParametersWordsFlags = flags USHORT
{
    DisconnectTid = 0x0001,
    NOResponse    = 0x0002,
    ...
};

// 2.2.1.3   Named Pipe Status (SMB_NMPIPE_STATUS)
pattern SmbNMPipeStatus = flags USHORT
{
    ICount        = 0x00FF,
    ReadMode      = 0x0300,
    NamedPipeType = 0x0C00,
    Reserved      = 0x3000,
    Endpoint      = 0x4000,
    Nonblocking   = 0x8000,
    ...
};

// 2.2.4.43   SMB_COM_WRITE_ANDX (0x2F)
type SmbComWriteAndxRequest
{
    UCHAR WordCount where (value == 0x0C || value == 0x0E);
    UCHAR AndXCommand;
    UCHAR AndXReserved;
    USHORT AndXOffset;
    USHORT Fid;
    ULONG Offset;
    ULONG Timeout;
    SmbComWriteAndxRequestParametersWordsWriteMode WriteMode;
    USHORT Remaining;
    USHORT DataLengthHigh;
    USHORT DataLength;
    USHORT DataOffset;
    optional [|WordCount == 0x0E|] ULONG OffsetHigh;
    USHORT ByteCount;
    optional [|DataOffset > 35 + WordCount * 2|] binary Pad with BinaryEncoding{Length = (DataOffset - 35 - WordCount * 2) as uint};
    optional binary Data with Encoding{Ignore = true};
    optional binary AndXPadding with Encoding{Ignore = true};
}

pattern SmbComWriteAndxRequestParametersWordsWriteMode = flags USHORT
{
    WritethroughMode   = 0x0001,
    ReadBytesAvailable = 0x0002,
    RawMode            = 0x0004,
    MsgStart           = 0x0008,
    ...
};

// 2.2.4.43   SMB_COM_WRITE_ANDX (0x2F)
type SmbComWriteAndxResponse
{
    UCHAR WordCount where value == 0x06;
    UCHAR AndXCommand;
    UCHAR AndXReserved;
    USHORT AndXOffset;
    USHORT Count;
    USHORT Available;
    USHORT CountHigh;
    USHORT Reserved where value == 0x0000;
    USHORT ByteCount where value == 0x0000;
    optional binary AndXPadding with Encoding{Ignore = true};
}

// 2.2.5   Transaction Subcommands, no specified response.
type TransactionSubCommandsRequestParameters[ushort Subcommand, ushort Length]
{
    ([|Subcommand == 0x0001|] TransSetNmpipeStateRequest
        | [|Subcommand == 0x0022|] TransQueryNmpipeInfoRequest
        | Blob[Length as uint]) SmbParameters;
}

// 2.2.5.1   TRANS_SET_NMPIPE_STATE (0x0001)
type TransSetNmpipeStateRequest
{
    TransSetNmpipeStateRequestParametersPipeState PipeState;
};

pattern TransSetNmpipeStateRequestParametersPipeState = flags USHORT
{
    Reserved1   = 0x00FF,
    ReadMode    = 0x0100,
    Reserved2   = 0x7E00,
    Nonblocking = 0x8000,
    ...
};

// 2.2.5.3   TRANS_QUERY_NMPIPE_STATE (0x0021)
type TransQueryNmpipeStateResponseTransParameters
{
    SmbNMPipeStatus NmpipeStatus;
}

// 2.2.5.4   TRANS_QUERY_NMPIPE_INFO (0x0022)
type TransQueryNmpipeInfoRequest
{
    USHORT Level;
}

type TransQueryNmpipeInfoResponse[bool IsFlags2Unicode]
{
    USHORT OutputBufferSize;
    USHORT InputBufferSize;
    UCHAR MaximumInstances;
    UCHAR CurrentInstances;
    UCHAR PipeNameLength;
    optional [|IsFlags2Unicode|] UCHAR Pad;
    SmbString[IsFlags2Unicode] PipeName;
}

// 2.2.5.5   TRANS_PEEK_NMPIPE (0x0023)
type TransPeekNmpipeResponseTransParameters
{
    USHORT ReadDataAvailable;
    USHORT MessageBytesLength;
    TransPeekNmpipeResponseTransParametersNamedPipeState NamedPipeState;
}

pattern TransPeekNmpipeResponseTransParametersNamedPipeState = enum USHORT
{
    Disconnected  = 0x0001,
    Listening = 0x0002,
    ConnectionOkey  = 0x0003,
    Closed = 0x0004,
    ...
};

// 2.2.5.7   TRANS_RAW_WRITE_NMPIPE (0x0031)
type TransRawWriteNmpipeResponseTransParameters
{
    USHORT BytesWritten;
}

// 2.2.5.9   TRANS_WRITE_NMPIPE (0x0037)
type TransWriteNmpipeResponseTransParameters
{
    USHORT BytesWritten;
}


// 2.2.4.42   SMB_COM_READ_ANDX (0x2E)
type SmbComReadAndxRequest
{
    UCHAR WordCount where (value == 0x0a || value == 0x0c);
    UCHAR AndXCommand;
    UCHAR AndXReserved;
    USHORT AndXOffset;
    USHORT Fid;
    ULONG Offset;
    USHORT MaxCountOfBytesToReturn;
    USHORT MinCountOfBytesToReturn;
    ULONG TimeoutOrMaxCountHigh;
    USHORT Remaining;
    optional [|WordCount == 0x0C|] ULONG OffsetHigh;
    USHORT ByteCount where value == 0x0000;
    optional binary AndXPadding with Encoding{Ignore = true};
}

// 2.2.4.42   SMB_COM_READ_ANDX (0x2E)
type SmbComReadAndxResponse[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x0C;
    UCHAR AndXCommand;
    UCHAR AndXReserved;
    USHORT AndXOffset;
    USHORT Available;
    USHORT DataCompactionMode;
    USHORT Reserved1 where value == 0x0000;
    USHORT DataLength;
    USHORT DataOffset;
    USHORT DataLengthHigh;
    binary Reserved2 with BinaryEncoding{Length = 8};
    USHORT ByteCount where value >= 0x0000;
    optional [|DataOffset > 59|] binary Pad with BinaryEncoding{Length = (DataOffset - 59) as uint};
    optional binary Data with Encoding{Ignore = true};
    optional binary AndXPadding with Encoding{Ignore = true};
}

// Stor File Id for SMB/SMB2 named pipe message.
annotation ulong SMBFileId;
