protocol RDPRFX with
Documentation
{
    ProtocolName = "Remote Desktop Protocol: RemoteFX Codec Extension",
    ShortName = "MS-RDPRFX",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-RDPRFX", Version = "15.0", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="1.0.0", Date="02/21/2013"}
        ]
};

using Utility;
using T124;
using T125;
using RDPBCGR;
using CommonResources;
using Diagnostics;

endpoint Server over T125.Node accepts TS_FRAME_ACKNOWLEDGE_PDU; 

autostart actor RDPRFXOverT125(T125.Node node) follows T124OverT125
{
    // decode message TS_FRAME_ACKNOWLEDGE_PDU
    process node accepts domainMCSPDU :T125.DomainMCSPDU where (domainMCSPDU.DomainMCSPDU is T125.SendDataRequestPattern)
    {
        binary payload = (domainMCSPDU.DomainMCSPDU as T125.SendDataRequestPattern).UserData as binary;
        if ((RDPBCGR.GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.MonitorLayoutPdu)) == 0x07 &&
                (RDPBCGR.GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.MonitorLayoutPdu) == 0x38))
        {
            var m = BinaryDecoder<TS_FRAME_ACKNOWLEDGE_PDU[encryptionMethod]>(payload);
            if (m != nothing)
            {
                var msg = m as TS_FRAME_ACKNOWLEDGE_PDU;
                dispatch endpoint Server accepts msg;
            }
            else
            {
                ThrowDecodingException("RDPRFX", "TS_FRAME_ACKNOWLEDGE_PDU");
            }
        }
        else
        {
            reject;
        }
    }
}

autostart actor RDPRFXOverRDPBCGR(RDPBCGR.Server server)
{
    // decode TSRFXMessage
    observe server issues pdu : RDPBCGR.TSFPUpdatePdu
        where (pdu.FPOutputUpdates != nothing && (pdu.FPOutputUpdates as array<RDPBCGR.TSFPUpdate>).Count > 0)
    {
        foreach (RDPBCGR.TSFPUpdate tsfpupdate in (pdu.FPOutputUpdates as array<RDPBCGR.TSFPUpdate>))
        {
            if (tsfpupdate is RDPBCGR.TSFPSurfcmds)
            {
                RDPBCGR.TSFPSurfcmds tsfpsurfcmds = tsfpupdate as RDPBCGR.TSFPSurfcmds;
                if (tsfpsurfcmds.SurfaceCommands != nothing && (tsfpsurfcmds.SurfaceCommands as array<RDPBCGR.TSSurfcmd>).Count > 0)
                {
                    foreach (RDPBCGR.TSSurfcmd tssurfcmd in (tsfpsurfcmds.SurfaceCommands as array<RDPBCGR.TSSurfcmd>))
                    {
                        if (tssurfcmd.CmdData is RDPBCGR.TSSurfcmdSetSurfBits)
                        {
                            RDPBCGR.TSSurfcmdSetSurfBits surfbits = tssurfcmd.CmdData as RDPBCGR.TSSurfcmdSetSurfBits;
                            binary data = surfbits.BitmapData.BitmapData as binary;
                            var msg = DecodeTSRFXMessages(data);
                            if (msg != nothing)
                            {
                                surfbits.BitmapData.BitmapData = msg as array<TSRFXMessage>;
                            }
                            // just ignore it if can't be decoded as TSRFXMessageType
                        }
                        else if (tssurfcmd.CmdData is RDPBCGR.TSSurfcmdStreamSurfBits)
                        {
                            RDPBCGR.TSSurfcmdStreamSurfBits streamSurfbits = tssurfcmd.CmdData as RDPBCGR.TSSurfcmdStreamSurfBits;
                            binary data = streamSurfbits.BitmapData.BitmapData as binary;
                            var msg = DecodeTSRFXMessages(data);
                            if (msg != nothing)
                            {
                                streamSurfbits.BitmapData.BitmapData = msg as array<TSRFXMessage>;
                            }
                            // just ignore it if can't be decoded as TSRFXMessageType.
                        }
                    }
                }
            }
        }
    }

    observe server accepts pdu : RDPBCGR.ClientConfirmActivePdu
    {
        pdu.ConfirmActivePduData.CapabilitySets = ParsingExtendedTSCapsSet(pdu.ConfirmActivePduData.CapabilitySets);
    } 

    observe server issues pdu : RDPBCGR.ServerDemandActivePdu
    {
        pdu.DemandActivePduData.CapabilitySets = ParsingExtendedTSCapsSet(pdu.DemandActivePduData.CapabilitySets);
    }

    array<RDPBCGR.TSCapsSetPattern> ParsingExtendedTSCapsSet(array<RDPBCGR.TSCapsSetPattern> CapabilitySets)
    {
        array<RDPBCGR.TSCapsSetPattern> newArray = [];
        foreach (RDPBCGR.TSCapsSetPattern capsetpat in CapabilitySets)
        {
            if (capsetpat is RDPBCGR.TSBitmapCodecsCapabilitySet)
            {
                RDPBCGR.TSBitmapCodecsCapabilitySet bitmapcapset = capsetpat as RDPBCGR.TSBitmapCodecsCapabilitySet;
                foreach (RDPBCGR.TSBitmapCodec bitmapcodec in bitmapcapset.SupportedBitmapCodecs.BitmapCodecArray)
                {
                    if (bitmapcodec.CodecGUID == RDPBCGR.TSBitmapCodecCodecGUID.CodecGUIDRemotefx || bitmapcodec.CodecGUID == RDPBCGR.TSBitmapCodecCodecGUID.CodecGUIDImageRemotefx)
                    {
                        var prop = BinaryDecoder<TS_RFX_CLNT_CAPS_CONTAINER>(bitmapcodec.CodecProperties as binary);
                        if (prop != nothing)
                        {
                            bitmapcodec.CodecProperties = prop as TS_RFX_CLNT_CAPS_CONTAINER;
                        }
                        else
                        {
                            var prop2 = BinaryDecoder<TS_RFX_SRVR_CAPS_CONTAINER[bitmapcodec.CodecPropertiesLength]>(bitmapcodec.CodecProperties as binary);
                            if (prop2 != nothing)
                            {
                                bitmapcodec.CodecProperties = prop2 as TS_RFX_SRVR_CAPS_CONTAINER[bitmapcodec.CodecPropertiesLength];
                            }
                            else
                            {
                                ThrowDecodingException("RDPRFX", "TS_RFX_CLNT_CAPS_CONTAINER | TS_RFX_SRVR_CAPS_CONTAINER");
                            }
                        }
                    }
                }
            }
            else if (capsetpat is RDPBCGR.UnKnownTSCapsSet) // decode TS_FRAME_ACKNOWLEDGE_CAPABILITYSET
            {
                if (capsetpat is RDPBCGR.TSCapsSet)
                {
                    RDPBCGR.TSCapsSet capset = capsetpat as RDPBCGR.TSCapsSet;
                    if (capset.CapabilitySetType == RDPBCGR.TSCapsSetCapabilitySetType.CapssettypeFrameAckNowledge)
                    {
                        TS_FRAME_ACKNOWLEDGE_CAPABILITYSET ack = new TS_FRAME_ACKNOWLEDGE_CAPABILITYSET
                        {
                            capabilitySetType = capset.CapabilitySetType, 
                            lengthCapability = capset.LengthCapability, 
                            maxUnacknowledgedFrameCount = BinaryDecoder<uint>(capset.CapabilityData) as uint
                        };
                        capsetpat = ack;
                    }
                }
            }
            newArray += [capsetpat];
        }
        return newArray;
    }
}

// [MS-RDPRFX] 2.2.1.1   TS_RFX_CLNT_CAPS_CONTAINER
pattern TS_RFX_CLNT_CAPS_CONTAINER_captureFlags = flags uint
{
    CARDP_CAPS_CAPTURE_NON_CAC = 0x00000001
};

type TS_RFX_CLNT_CAPS_CONTAINER
{
    uint length;
    TS_RFX_CLNT_CAPS_CONTAINER_captureFlags captureFlags;
    uint capsLength;
    TS_RFX_CAPS capsData;
}

type TS_RFX_CAPS
{
    ushort blockType where value == 0xCBC0;
    uint blockLen where ValidationCheck(value == 0x0008, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "blockLen", CommonResources.COMMON_STR_TYPE, "TS_RFX_CAPS", CommonResources.COMMON_STR_MUST, "0x0008", Utility.DecToHexFormat(value)]));
    ushort numCapsets where ValidationCheck(value == 0x0001, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "numCapsets", CommonResources.COMMON_STR_TYPE, "TS_RFX_CAPS", CommonResources.COMMON_STR_MUST, "0x0001", Utility.DecToHexFormat(value)]));
    array<TS_RFX_CAPSET> capsetsData with BinaryEncoding{Length = numCapsets};
}

type TS_RFX_CAPSET
{
    ushort blockType where value == 0xCBC1;
    uint blockLen;
    byte codecId where ValidationCheck(value == 0x01, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "codecId", CommonResources.COMMON_STR_TYPE, "TS_RFX_CAPSET", CommonResources.COMMON_STR_MUST, "0x01", Utility.DecToHexFormat(value)]));
    ushort capsetType where ValidationCheck(value == 0xCFC0, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "capsetType", CommonResources.COMMON_STR_TYPE, "TS_RFX_CAPSET", CommonResources.COMMON_STR_MUST, "CLY_CAPSET (0xCFC0)", Utility.DecToHexFormat(value)]));
    ushort numIcaps;
    ushort icapLen;
    array<TS_RFX_ICAP> icapsData with BinaryEncoding{Length = numIcaps};
}

type TS_RFX_ICAP
{
    ushort version where value == 0x0100;
    ushort tileSize where ValidationCheck(value == 0x0040, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "tileSize", CommonResources.COMMON_STR_TYPE, "TS_RFX_ICAP", CommonResources.COMMON_STR_MUST, "CT_TILE_64x64 (0x0040)", Utility.DecToHexFormat(value)]));
    TS_RFX_ICAP_flags $"flags";
    byte colConvBits where ValidationCheck(value == 0x1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "colConvBits", CommonResources.COMMON_STR_TYPE, "TS_RFX_ICAP", CommonResources.COMMON_STR_MUST, "CLW_COL_CONV_ICT (0x1)", Utility.DecToHexFormat(value)]));
    byte transformBits where ValidationCheck(value == 0x1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "transformBits", CommonResources.COMMON_STR_TYPE, "TS_RFX_ICAP", CommonResources.COMMON_STR_MUST, "CLW_XFORM_DWT_53_A (0x1)", Utility.DecToHexFormat(value)]));
    TS_RFX_ICAP_entropyBits entropyBits;
}

pattern TS_RFX_ICAP_flags = flags byte
{
    CODEC_MODE = 0x02
};

pattern TS_RFX_ICAP_entropyBits = enum byte
{
    CLW_ENTROPY_RLGR1 = 0x01,
    CLW_ENTROPY_RLGR3 = 0x04
};

// [MS-RDPRFX] 2.2.1.2   TS_RFX_SRVR_CAPS_CONTAINER
type TS_RFX_SRVR_CAPS_CONTAINER[ushort CodecPropertiesLength]
{
    binary Reserved with BinaryEncoding{Length = CodecPropertiesLength};
}

// 2.2.1.3   TS_FRAME_ACKNOWLEDGE_CAPABILITYSET
type TS_FRAME_ACKNOWLEDGE_CAPABILITYSET
{
    ushort capabilitySetType where value == 0x001E;
    ushort lengthCapability;
    uint maxUnacknowledgedFrameCount;
}

// 2.2.2.1.1   TS_RFX_BLOCKT
type TS_RFX_BLOCKT
{
    TS_RFX_BLOCKT_blockType blockType;
    uint blockLen;
}

pattern TS_RFX_BLOCKT_blockType = enum ushort
{
    WBT_SYNC = 0xCCC0,
    WBT_CODEC_VERSIONS = 0xCCC1,
    WBT_CHANNELS = 0xCCC2,
    CBT_TILE = 0xCAC3
};

// 2.2.2.1.2   TS_RFX_CODEC_CHANNELT
pattern TS_RFX_CODEC_CHANNELT_blockType = enum ushort
{
    WBT_CONTEXT = 0xCCC3,
    WBT_FRAME_BEGIN = 0xCCC4,
    WBT_FRAME_END = 0xCCC5,
    WBT_REGION = 0xCCC6,
    WBT_EXTENSION = 0xCCC7
};

type TS_RFX_CODEC_CHANNELT
{
    TS_RFX_CODEC_CHANNELT_blockType blockType;
    uint blockLen;
    byte codecId where ValidationCheck(value == 0x01, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "codecId", CommonResources.COMMON_STR_TYPE, "TS_RFX_CODEC_CHANNELT", CommonResources.COMMON_STR_MUST, "0x01", Utility.DecToHexFormat(value)]));
    byte channelId where ValidationCheck(value == 0x00, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "channelId", CommonResources.COMMON_STR_TYPE, "TS_RFX_CODEC_CHANNELT", CommonResources.COMMON_STR_MUST, "0x00", Utility.DecToHexFormat(value)]));
}

// 2.2.2.1.3   TS_RFX_CHANNELT
type TS_RFX_CHANNELT
{
    byte channelId where ValidationCheck(value == 0x00, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "channelId", CommonResources.COMMON_STR_TYPE, "TS_RFX_CHANNELT", CommonResources.COMMON_STR_MUST, "0x00", Utility.DecToHexFormat(value)]));
    ushort width where ValidationCheck(value >= 1 && value <= 4096, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE_IN_RANGE, ["RDPRFX", "width", CommonResources.COMMON_STR_TYPE, "TS_RFX_CHANNELT", CommonResources.COMMON_STR_MUST, "1", "4096", value]));
    ushort height where ValidationCheck(value >= 1 && value <= 2048, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE_IN_RANGE, ["RDPRFX", "height", CommonResources.COMMON_STR_TYPE, "TS_RFX_CHANNELT", CommonResources.COMMON_STR_MUST, "1", "2048", value]));
}

// 2.2.2.1.4   TS_RFX_CODEC_VERSIONT
type TS_RFX_CODEC_VERSIONT
{
    byte codecId where value == 0x01;
    ushort version where value == 0x0100;
}

// 2.2.2.1.5   TS_RFX_CODEC_QUANT
type TS_RFX_CODEC_QUANT
{
    byte LL3 with BinaryEncoding{Width = 4};
    byte LH3 with BinaryEncoding{Width = 4};
    byte HL3 with BinaryEncoding{Width = 4};
    byte HH3 with BinaryEncoding{Width = 4};
    byte LH2 with BinaryEncoding{Width = 4};
    byte HL2 with BinaryEncoding{Width = 4};
    byte HH2 with BinaryEncoding{Width = 4};
    byte LH1 with BinaryEncoding{Width = 4};
    byte HL1 with BinaryEncoding{Width = 4};
    byte HH1 with BinaryEncoding{Width = 4};
}

// 2.2.2.1.6   TS_RFX_RECT
type TS_RFX_RECT
{
    ushort x;
    ushort y;
    ushort width;
    ushort height;
}

// 2.2.2.2.1   TS_RFX_SYNC
message TS_RFX_SYNC
{
    TS_RFX_BLOCKT BlockT where value.blockType == TS_RFX_BLOCKT_blockType.WBT_SYNC;
    uint magic where ValidationCheck(value == 0xCACCACCA, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "BlockT", CommonResources.COMMON_STR_MESSAGE, "TS_RFX_SYNC", CommonResources.COMMON_STR_MUST, "WF_MAGIC (0xCACCACCA)", Utility.DecToHexFormat(value)]));
    ushort version where ValidationCheck(value == 0x0100, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "version", CommonResources.COMMON_STR_MESSAGE, "TS_RFX_SYNC", CommonResources.COMMON_STR_MUST, "WF_VERSION_1_0 (0x0100)", Utility.DecToHexFormat(value)]));
}

// 2.2.2.2.2   TS_RFX_CODEC_VERSIONS
message TS_RFX_CODEC_VERSIONS
{
    TS_RFX_BLOCKT BlockT where value.blockType == TS_RFX_BLOCKT_blockType.WBT_CODEC_VERSIONS;
    byte numCodecs where ValidationCheck(value == 0x01, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "numCodecs", CommonResources.COMMON_STR_MESSAGE, "TS_RFX_CODEC_VERSIONS", CommonResources.COMMON_STR_MUST, "0x01", Utility.DecToHexFormat(value)]));
    TS_RFX_CODEC_VERSIONT codecs;
}

// 2.2.2.2.3   TS_RFX_CHANNELS
message TS_RFX_CHANNELS
{
    TS_RFX_BLOCKT BlockT where value.blockType == TS_RFX_BLOCKT_blockType.WBT_CHANNELS;
    byte numChannels;
    array<TS_RFX_CHANNELT> Channels  with BinaryEncoding{Length = numChannels};
}

// 2.2.2.2.4   TS_RFX_CONTEXT
type TS_RFX_CONTEXT_properties
{
    ushort r with BinaryEncoding{Width = 1};
    ushort qt where ValidationCheck(value == 0x1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "qt",  CommonResources.COMMON_STR_TYPE, "TS_RFX_CONTEXT_properties", CommonResources.COMMON_STR_MUST, "0x1", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 2};
    ushort et where ValidationCheck(value == 0x01 || value == 0x04, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "et",  CommonResources.COMMON_STR_TYPE, "TS_RFX_CONTEXT_properties", CommonResources.COMMON_STR_MUST, "CLW_ENTROPY_RLGR1 (0x01)", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 4};
    ushort xft where ValidationCheck(value == 0x1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "xft",  CommonResources.COMMON_STR_TYPE, "TS_RFX_CONTEXT_properties", CommonResources.COMMON_STR_MUST, "CLW_XFORM_DWT_53_A (0x1)", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 4};
    ushort cct where ValidationCheck(value == 0x1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "cct",  CommonResources.COMMON_STR_TYPE, "TS_RFX_CONTEXT_properties", CommonResources.COMMON_STR_MUST, "COL_CONV_ICT (0x1)", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 2};
    ushort $"flags" with BinaryEncoding{Width = 3};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

message TS_RFX_CONTEXT
{
    TS_RFX_CODEC_CHANNELT CodecChannelT where value.blockType == TS_RFX_CODEC_CHANNELT_blockType.WBT_CONTEXT;
    byte ctxId  where ValidationCheck(value == 0x00, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "ctxId", CommonResources.COMMON_STR_MESSAGE, "TS_RFX_CONTEXT", CommonResources.COMMON_STR_MUST, "0x00", Utility.DecToHexFormat(value)]));
    ushort tileSize where ValidationCheck(value == 0x40, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "tileSize", CommonResources.COMMON_STR_MESSAGE, "TS_RFX_CONTEXT", CommonResources.COMMON_STR_MUST, "CT_TILE_64x64 (0x0040)", Utility.DecToHexFormat(value)]));
    TS_RFX_CONTEXT_properties Properties;
}

message TS_RFX_FRAME_BEGIN
{
    TS_RFX_CODEC_CHANNELT CodecChannelT where value.blockType == TS_RFX_CODEC_CHANNELT_blockType.WBT_FRAME_BEGIN;
    uint frameIdx;
    ushort numRegions;
}

message TS_RFX_FRAME_END
{
    TS_RFX_CODEC_CHANNELT CodecChannelT where value.blockType == TS_RFX_CODEC_CHANNELT_blockType.WBT_FRAME_END;
}

message TS_RFX_REGION
{
    TS_RFX_CODEC_CHANNELT CodecChannelT where value.blockType == TS_RFX_CODEC_CHANNELT_blockType.WBT_REGION;
    byte regionFlags;
    ushort numRects;
    TS_RFX_RECT rects;
    ushort regionType where ValidationCheck(value == 0xCAC1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "regionType", CommonResources.COMMON_STR_MESSAGE, "TS_RFX_REGION", CommonResources.COMMON_STR_MUST, "CBT_REGION (0xCAC1)", Utility.DecToHexFormat(value)]));
    ushort numTilesets where ValidationCheck(value == 0x0001, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "numTilesets", CommonResources.COMMON_STR_MESSAGE, "TS_RFX_REGION", CommonResources.COMMON_STR_MUST, "0x0001", Utility.DecToHexFormat(value)]));
}

message TS_RFX_TILESET
{
    TS_RFX_CODEC_CHANNELT CodecChannelT where value.blockType == TS_RFX_CODEC_CHANNELT_blockType.WBT_EXTENSION;
    ushort subtype where value == 0xCAC2;
    ushort idx where ValidationCheck(value == 0x0000, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "idx", CommonResources.COMMON_STR_MESSAGE, "TS_RFX_TILESET", CommonResources.COMMON_STR_MUST, "0x0000", Utility.DecToHexFormat(value)]));
    TS_RFX_TILESET_properties properties;
    byte numQuant;
    byte tileSize where ValidationCheck(value == 0x40, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "tileSize", CommonResources.COMMON_STR_MESSAGE, "TS_RFX_TILESET", CommonResources.COMMON_STR_MUST, "0x40", Utility.DecToHexFormat(value)]));
    ushort numTiles;
    uint tilesDataSize;
    array<TS_RFX_CODEC_QUANT> quantVals with BinaryEncoding{Length = numQuant};
    array<TS_RFX_TILE> tiles with BinaryEncoding{Length = numTiles};
}

type TS_RFX_TILESET_properties
{
    ushort qt where ValidationCheck(value == 0x1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "qt",  CommonResources.COMMON_STR_TYPE, "TS_RFX_TILESET_properties", CommonResources.COMMON_STR_MUST, "SCALAR_QUANTIZATION (0x1)", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 2};
    TS_RFX_TILESET_properties_et et with BinaryEncoding{Width = 4};
    ushort xft where ValidationCheck(value == 0x1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "xft",  CommonResources.COMMON_STR_TYPE, "TS_RFX_TILESET_properties", CommonResources.COMMON_STR_MUST, "CLW_XFORM_DWT_53_A (0x1)", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 4};
    ushort cct where ValidationCheck(value == 0x1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "cct",  CommonResources.COMMON_STR_TYPE, "TS_RFX_TILESET_properties", CommonResources.COMMON_STR_MUST, "COL_CONV_ICT (0x1)", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 2};
    ushort $"flags" with BinaryEncoding{Width = 3};
    ushort lt where ValidationCheck(value == 0x1, null, DiagnosisLevel.Error, 
        () => Format(CommonResources.COMMON_STR_CHECK_VALUE, ["RDPRFX", "lt",  CommonResources.COMMON_STR_TYPE, "TS_RFX_TILESET_properties", CommonResources.COMMON_STR_MUST, "TRUE (0x1)", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 1};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

pattern TS_RFX_TILESET_properties_et = enum byte
{
    CLW_ENTROPY_RLGR1 = 0x01,
    CLW_ENTROPY_RLGR3 = 0x04
};

message TS_RFX_TILE
{
    TS_RFX_BLOCKT BlockT where value.blockType == TS_RFX_BLOCKT_blockType.CBT_TILE;
    byte quantIdxY;
    byte quantIdxCb;
    byte quantIdxCr;
    ushort xIdx;
    ushort yIdx;
    ushort YLen;
    ushort CbLen;
    ushort CrLen;
    binary YData with BinaryEncoding{Length = YLen};
    binary CbData with BinaryEncoding{Length = CbLen};
    binary CrData with BinaryEncoding{Length = CrLen};
}

message TS_FRAME_ACKNOWLEDGE_PDU[TSUDSCSec1EncryptionMethod encryptionMethod]
{
    optional ([|(encryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit) || (encryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit) || (encryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit)|] NonFipsSecurityHeader |
              [|(encryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader) securityHeader;
    TSShareDataHeader shareDataHeader;
    uint frameID;
    override string ToString()
    {
        return "TS_FRAME_ACKNOWLEDGE_PDU";
    }
}

pattern TSRFXMessage =  TS_RFX_SYNC | TS_RFX_CODEC_VERSIONS | TS_RFX_CHANNELS | TS_RFX_CONTEXT | TS_RFX_FRAME_BEGIN | TS_RFX_REGION | TS_RFX_FRAME_END | TS_RFX_TILESET; 

optional array<TSRFXMessage> DecodeTSRFXMessages(stream s)
{
    array<TSRFXMessage> messages = [];
    TSRFXMessage m;
    bool hasDecodingFailure = false;
    while (s.BytePosition < s.ByteLength - 2 && !hasDecodingFailure)
    {
        var blockType = ((s.PeekByte(s.BitPosition + 8) as ushort) << 8) + s.PeekByte(s.BitPosition);
        switch (blockType)
        {
            case TS_RFX_BLOCKT_blockType.WBT_SYNC =>
                if (DecodeTSRFXMessage<TS_RFX_SYNC>(s, out m))
                {
                    messages += [m];
                }
                else
                {
                    hasDecodingFailure = true;
                }
            case TS_RFX_BLOCKT_blockType.WBT_CODEC_VERSIONS =>
                if (DecodeTSRFXMessage<TS_RFX_CODEC_VERSIONS>(s, out m))
                {
                    messages += [m];
                }
                else
                {
                    hasDecodingFailure = true;
                }
            case TS_RFX_BLOCKT_blockType.WBT_CHANNELS =>
                if (DecodeTSRFXMessage<TS_RFX_CHANNELS>(s, out m))
                {
                    messages += [m];
                }
                else
                {
                    hasDecodingFailure = true;
                }
            case TS_RFX_CODEC_CHANNELT_blockType.WBT_CONTEXT =>
                if (DecodeTSRFXMessage<TS_RFX_CONTEXT>(s, out m))
                {
                    messages += [m];
                }
                else
                {
                    hasDecodingFailure = true;
                }
            case TS_RFX_CODEC_CHANNELT_blockType.WBT_FRAME_BEGIN =>
                if (DecodeTSRFXMessage<TS_RFX_FRAME_BEGIN>(s, out m))
                {
                    messages += [m];
                }
                else
                {
                    hasDecodingFailure = true;
                }
            case TS_RFX_CODEC_CHANNELT_blockType.WBT_REGION =>
                if (DecodeTSRFXMessage<TS_RFX_REGION>(s, out m))
                {
                    messages += [m];
                }
            case TS_RFX_CODEC_CHANNELT_blockType.WBT_EXTENSION =>
                if (DecodeTSRFXMessage<TS_RFX_TILESET>(s, out m))
                {
                    messages += [m];
                }
                else
                {
                    hasDecodingFailure = true;
                }
            case TS_RFX_CODEC_CHANNELT_blockType.WBT_FRAME_END =>
                if (DecodeTSRFXMessage<TS_RFX_FRAME_END>(s, out m))
                {
                    messages += [m];
                }
                else
                {
                    hasDecodingFailure = true;
                }
            default =>
                hasDecodingFailure = true;
        }
    }
    if (messages.Count > 0)
    {
        return messages;
    }
    else
    {
        return nothing;
    }
}

bool DecodeTSRFXMessage<T>(stream s, out TSRFXMessage msg)
{
    var m = BinaryDecoder<T>(s);
    if (m != nothing)
    {
        msg = (m as T) as TSRFXMessage;
        return true;
    }
    else
    {
        return false;
    }
}
