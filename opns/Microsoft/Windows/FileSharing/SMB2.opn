protocol SMB2 with
Documentation
{
    ProtocolName = "Server Message Block (SMB) Protocol Versions 2 and 3",
    ShortName = "SMB2",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-SMB2", Version = "43.0", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="1.0.0", Date="08/13/2013"}
        ]
};

using Standard;
using Utility;
using DTYP;
using ERREF;
using SMBOverTCP;
using FSCC;
using NBTSS;
using PCCRC;
using Diagnostics;
using CommonResources;
using NamedPipe;
using MSRPCE;
using GSSAPI;
using NLMP;
using RSVD;

// -------------------------------------------
// Static values

const ulong InvalidFileId = 0xFFFFFFFFFFFFFFFF;
const ulong InvalidMessageId = 0xFFFFFFFFFFFFFFFF;
const binary SMB2ProtocolId = $[FE534D42];
const binary SMB3EncryptdProtocolId = $[FD534D42];

// -------------------------------------------
// annotation

// Keep the file name for the file access messages
annotation string ReqFileMessage#SMBFileName;
annotation string ResFileMessage#SMBFileName;
annotation ulong ReqFileMessage#FileId;
annotation ulong ResFileMessage#FileId;

// Keep the command name for SMB2HeaderOnly message
annotation string SMB2HeaderOnly#SMB2MessageName;

// Mark if the message is reassembled or not
annotation bool ResFileMessage#IsReassembled;

// -------------------------------------------
// Grobal values

// Negotiate DialectRevision, some value of SMB2NegotiateResponseDialectRevision
ushort SMB2DialectRevision = 0xFFFF;

// Store the global file name by fileId
map<ulong, string> SMB2GlobalFileNames = {};

// ------------------------------------------- Architecture ------------------------------------------- //

// -------------------------------------------
// Endpoints

/* SMB2 Endpoint Layers:
 * The architecture design refers to section 3.2.1 Abstract Data Model.
 *
 * [Upper layer]
 * -------------------------------------------------|--------------|-----------------------------------
 *                                                  |              |                                  
 * [Per Application Open of a File]   FileServer(FileName)  NamedPipeServer(FileName)
 *                                                  |              |
 *                                  FileReassembleServer  NamedPipeReassembleServer
 *                                                  |              |
 * [Per Tree Connect]                          TreeConnectionServer(TreeId)
 *                                                         |
 * [Per Session]                               SessionServer(SessionId)
 *                                                         |
 * [Per Transport Connection]                            Server
 * ----------------------------------------------------------------------------------------------------
 * [Lower layer]
 */

// Top layer endpoint available for the protocol that specifies the file content.
endpoint FileServer[string FileName]
    over FileReassembleServer
    provides Messages;

// Top layer endpoint available for the protocol that is assumed that the client and server have a security association usable with named pipes.
endpoint NamedPipeServer[string FileName]
    over NamedPipeReassembleServer
    provides Messages;

/* The fourth layer endpoint for non-named-pipe share type:
 * 1. Dispatch all the file operations to top level endpoint;
 * 2. Future Reference: For the specified file being read or written, reassemble the buffer data and dispatch the message with the complete data to FileServer layer
 */
endpoint FileReassembleServer[string FileName]
    over TreeConnectionServer
    provides Messages
{
    process this accepts m:ReqFileMessage
    {
        dispatch (endpoint FileServer[FileName] over this) accepts m;
    }
    
    process this issues m:ResFileMessage
    {
        dispatch (endpoint FileServer[FileName] over this) issues m;
    }
}

/* The fourth layer endpoint for named-pipe share type:
 * 1. Used to reassemble the buffer data the if the status returned is STATUS_BUFFER_OVERFLOW for IoctlResponse and ReadResponse
 * 2. All the named pipe operations Messages will be futher dispatched to top level endpoint; 
 */
endpoint NamedPipeReassembleServer[string FileName]
    over TreeConnectionServer
    provides Messages;

/* The third layer endpoint:
 * 1. Deal with the file name for the file commands;
 * 2. Dispatch the message to FileReassembleServer or NamedPipeReassembleServer based on the share type
 */
endpoint TreeConnectionServer[uint TreeId]
    over ls:SessionServer
    provides Messages
{
    // Store the fileId by MessageId for the response message
    map<ulong, string> fileNameByMid = {};
    map<ulong, ulong> fidByMid = {};

    // Mark whether it's named pipe or not
    optional bool isNamedPipe = nothing;

    // Store the share type for named pipe in the current connection
    observe this issues m:Messages.TreeConnectResponse
    {
        isNamedPipe = (m.Response.ShareType == SMB2TreeConnectResponseShareType.SMB2ShareTypePipe);
    }
    
    process this accepts req:ReqFileMessage
    {
        var mid = req.Header.MessageId;
        var command = req.Header.Command;
        var fileId = GetSMBFileId(req);
        fidByMid[mid] = fileId;

        /* Set the value of annotation FileName based on the FileId for the other request messages 
         * and store the file name by MessageId for the response messages
         */
        if (fileId in ls.opens)
        {
            req#SMBFileName = ls.opens[fileId];
        }
        else if (ls.lowerServer.supportsMultiChannel && fileId in SMB2GlobalFileNames)
        {
            req#SMBFileName = SMB2GlobalFileNames[fileId];
        }
        // Store the file name by MessageId
        if (req#SMBFileName != nothing)
        {
            fileNameByMid[mid] = req#SMBFileName as string;
        }
        else if (fileId != InvalidFileId)
        {
            req#SMBFileName = Utility.DecToHexFormat(fileId);
            fileNameByMid[mid] = req#SMBFileName as string;
        }
        
        if (command == SMB2PacketHeaderCommand.SMB2Write && req is Messages.WriteRequest)
        {
            var writeReq = req as Messages.WriteRequest;   
            if (writeReq.Request.Buffer is binary)
            {
                var buf = writeReq.Request.Buffer as binary;
                if (buf.Count < writeReq.Request.Length)
                {
                    DisplayTopLevelMessage(req);
                    return;
                }
            }
        }
        // Dispatch the message to upper layer endpoint by share type
        if (req#SMBFileName == nothing || CheckIsNamedPipe(isNamedPipe, req#SMBFileName as string))
        {
            dispatch (endpoint NamedPipeReassembleServer[req.FileName] over this) accepts req;
        }
        else
        {
            dispatch (endpoint FileReassembleServer[req.FileName] over this) accepts req;
        }
    }

    // Set the value of annotation FileName based on MessageId or FileId for the response messages
    process this issues res:ResFileMessage
    {
        var mid = GetMessageId(res.Header);
        var fid = GetSMBFileId(res);
        var command = GetCommand(res.Header);
        
        if (fid != InvalidFileId)
        {
            if (fid in ls.opens)
            {
                res#SMBFileName = ls.opens[fid];
            }
            else if (fid in ls.lowerServer.durableOpens)
            {
                res#SMBFileName = ls.lowerServer.durableOpens[fid];
            }
            else if (command == SMB2PacketHeaderCommand.SMB2Create && mid in fileNameByMid)
            {                
                string fileName = fileNameByMid[mid];
                ls.opens[fid] = fileName;
                Messages.CreateResponse createRes = res as Messages.CreateResponse;
                createRes#SMBFileName = fileName;
                if (createRes.Response.Buffer != nothing)
                {
                    var buffer = createRes.Response.Buffer as array<SMB2CreateContextResponse>;
                    // Keep it in durableOpens if the open is a durable open
                    foreach (var createContext in buffer)
                    {
                        if (createContext.Buffer.Name == SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleRequest)
                        {
                            ls.lowerServer.durableOpens[fid] = fileName;
                            break;
                        }
                    }
                }
                // Keep in SMB2GlobalFileNames if client supports multi channel
                if (ls.lowerServer.supportsMultiChannel)
                {
                    SMB2GlobalFileNames[fid] = fileName;
                }
            }
            else if (!(mid in fileNameByMid))
            {
                res#SMBFileName = Utility.DecToHexFormat(fid);
            }
        }
        if (mid in fileNameByMid)
        {
            // Set the value of annotation FileName based on the MessageId for the response messages
            if (res#SMBFileName is nothing)
            {
                res#SMBFileName = fileNameByMid[mid];
            }
            if (!(res is Messages.ErrorResponse))
            {
                fileNameByMid = fileNameByMid.Remove(mid);
            }
        }
        
        if (command == SMB2PacketHeaderCommand.SMB2Read && res is Messages.ReadResponse)
        {
            var readRes = res as Messages.ReadResponse;
            if (readRes.Response.Buffer is binary)
            {
                var buf = readRes.Response.Buffer as binary;
                if (buf.Count < readRes.Response.DataLength)
                {
                    DisplayTopLevelMessage(res);
                    return;
                }   
            }
            readRes#SMBFileId = (mid in fidByMid) ? fidByMid[mid] : InvalidFileId;
        }
        
        if (command == SMB2PacketHeaderCommand.SMB2Ioctl && res is Messages.IoctlResponse)
        {
            var ioctlRes = res as Messages.IoctlResponse;
            if (ioctlRes.Response.Buffer is binary)
            {
                var buf = ioctlRes.Response.Buffer as binary;
                if (buf.Count < ioctlRes.Response.OutputCount)
                {
                    DisplayTopLevelMessage(res);
                    return;
                }       
            }     
            ioctlRes#SMBFileId = (mid in fidByMid) ? fidByMid[mid] : InvalidFileId;
        }
        
        // Dispatch the message to upper layer endpoint by share type
        if (res#SMBFileName == nothing || CheckIsNamedPipe(isNamedPipe, res#SMBFileName as string))
        {
            dispatch (endpoint NamedPipeReassembleServer[res.FileName] over this) issues res;
        }
        else
        {
            dispatch (endpoint FileReassembleServer[res.FileName] over this) issues res;
        }
    }
    
    ~endpoint(TreeConnectionServer server)
    {
        fileNameByMid = {};
        fidByMid = {};
    }
}

// The second layer endpoint: Will dispatch message to TreeConnectionServer
endpoint SessionServer[ulong SessionId]
    over ls:SMB2.Server
    provides Messages
    accepts TransformMessage issues TransformMessage
{
    SMB2.Server lowerServer = ls;
    // Keeps the opens of files or named pipes, indexed by FileId
    map<ulong, string> opens = ls.durableOpens;
    
    // Keeps the treeIds indexed by MessageId
    map<ulong, uint> treeIdByMessageId = {};
    
    // Dispatch all the requst messages to TreeConnectionServer endpoint except for authentication messages and TreeConnection.
    process this accepts m:ReqMessage where m.Header.Command > 3
    {
        treeIdByMessageId[m.Header.MessageId] = m.Header.TreeId;
        dispatch (endpoint TreeConnectionServer[m.Header.TreeId] over this) accepts m;
    }

    process this issues m:ResMessage where GetCommand(m.Header) > 2
    {
        var treeId = GetTreeId(m.Header);
        if (GetMessageId(m.Header) in treeIdByMessageId)
        {
            if (treeId == 0)
            {
                // Get the TreeId for the Async response from the corresponding request message
                treeId = treeIdByMessageId[GetMessageId(m.Header)];
            }
            else
            {
                treeIdByMessageId = treeIdByMessageId.Remove(GetMessageId(m.Header));
            }
        }
        dispatch (endpoint TreeConnectionServer[treeId] over this) issues m;
    }
}

/* The first layer endpoint:
 * 1. Sequence validation check for credits;
 * 2. Dispatch the message to SessionServer
 */
endpoint Server
    over SMBOverTCP.Server | over NBTSS.Server
    provides Messages
    accepts TransformMessage issues TransformMessage
{
    // 1. For caculate and validate the credits
    // Keeps the dialect of SMB2 negotiated with the server.
    ushort dialect = 0;
    // Keeps the Capabilities.SMB2GlobalCapLargeMtu flag bit from NegotiateResponse message
    // Indicates whether the server supports multi-credit operations.
    bool supportsMultiCredit = false;
    // The number of credits held by the client MUST be considered as 1 when the connection is established.
    int credits = 1;
    // Check if the message is decoded successfully
    bool hasAnyMessageDecodeFailed = false;

    // 2. For file name 
    // Keeps the Capabilities.SMB2GlobalCapMultiChannel flag bit from NegotiateResponse message.
    // Indicats whether the server supports establishing multiple channels for sessions.
    bool supportsMultiChannel = false;
    // Keep durable opens of files indexed by fileId
    map<ulong, string> durableOpens = {};

    // Hold all the ADM variable, for sequence validation
    ServerGlobal global;
    
    // Get the values from from NegotiateResponse message
    observe this issues m:Messages.NegotiateResponse
    {
        dialect = m.Response.DialectRevision;
        SMB2DialectRevision = dialect;
        supportsMultiCredit =  (m.Response.Capabilities & SMB2NegotiateResponseCapabilities.SMB2GlobalCapLargeMtu) > 0;
        supportsMultiChannel =  (m.Response.Capabilities & SMB2NegotiateResponseCapabilities.SMB2GlobalCapMultiChannel) > 0;
    }
    
    // Updates the credits and validate if it exceeds the the number of granted.
    // Exclude the credits check if the negotiate message is missing or there's message can't be decoded completely
    observe this accepts m:ReqMessage where (dialect != 0 && !hasAnyMessageDecodeFailed) || m.Header.Command == SMB2PacketHeaderCommand.SMB2Negotiate
    {
        /* Decreases the credits consumed by client.
         * If the server implements SMB 2.1 or later version and the request is a multi-credit request,
         * the credit consumed is based on the CreditCharge field, or else consumes one credit for any
         * request except for the SMB2 CANCEL Request.
         */
        if (supportsMultiCredit && m.Header.CreditCharge > 1 && (dialect != SMB2NegotiateResponseDialectRevision.SMB2002DialectRevisionNumber))
        {
            credits -= m.Header.CreditCharge;
        }
        else
        {
            credits--;
        }
        ValidationCheck(credits >= 0, m, DiagnosisLevel.Error, "SMB2: This message exceeds the number of granted credits.");
    }
    
    // Accumulates the credits granted by the server
    observe this issues m:ResMessage where dialect != 0 && !hasAnyMessageDecodeFailed
    {
        credits += m.CreditResponse;
    }
    
    // Dispatch all the messages to SessionServer endpoint except for Negotiate and the first SESSION_SETUP Request
    process this accepts m:ReqMessage where m.Header.Command > 1
    {
        dispatch (endpoint SessionServer[m.Header.SessionId] over this) accepts m;
    }

    process this accepts m:Messages.CancelRequest
    {
        dispatch (endpoint SessionServer[GetSessionId(m.Header)] over this) accepts m;
    }
    
    // Dispatch all the messages to SessionServer endpoint except for Negotiate
    process this issues m:ResMessage where GetCommand(m.Header) > 0
    {
        dispatch (endpoint SessionServer[GetSessionId(m.Header)] over this) issues m;
    }
    
    process this accepts m:TransformMessage
    {
        dispatch (endpoint SessionServer[m.Header.SessionId] over this) accepts m;
    }
    
    process this issues m:TransformMessage
    {
        dispatch (endpoint SessionServer[m.Header.SessionId] over this) issues m;
    }
}

// WORKAROUND: Add this addtional index endpoint just for the binding virtual operation since interleaved operations are not supported now
endpoint VirtualOperationServer[ulong MessageId]
    over SMBOverTCP.Server | over NBTSS.Server
    provides Messages
    provides VirtualOperations
{
    SMB2.Server server;
    
    bool isRequestLost = true;
    
    bool IsAsyncRequest = false;
    
    process this accepts m:ReqMessage
    {
        dispatch server accepts m;
    }

    process this accepts m:Messages.CancelRequest
    {
        dispatch server accepts m;
    }
    
    process this issues m:ResMessage
    {
        dispatch server issues m;
    }
}

//-------------------------------------------
// Client side

// The same architecture is defined for the Client.
client endpoint Client connected to Server;
client endpoint SessionClient connected to SessionServer;
client endpoint TreeConnetionClient connected to TreeConnectionServer;
client endpoint FileReassembleClient connected to FileReassembleServer;
client endpoint NamedPipeReassembleClient connected to NamedPipeReassembleServer;
client endpoint NamedPipeClient connected to NamedPipeServer;
client endpoint FileClient connected to FileServer;

// -------------------------------------------
// Actors

// Actor that listens to TransportPacket messages on both possible directions.
autostart actor SMB2OverSMBTransport(SMBOverTCP.Server server)
{
    DecodingCache dc = new DecodingCache{};

    // Parsing request message
    process server accepts s:SMBOverTCP.TransportPacket where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchRequestMessages(dc, s.SMBMessage, server);
    }

    // Parsing response message
    process server issues s:SMBOverTCP.TransportPacket where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchResponseMessages(dc, s.SMBMessage, server);
    }

    // Parsing Transform request message
    process server accepts s:SMBOverTCP.TransportPacket where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        ushort encryptAlgorithm = GetEncryptAlgorithmFromSMB2TransformMessage(s.SMBMessage);
        switch (s.SMBMessage)
        {
            case m:TransformMessage[encryptAlgorithm] from BinaryDecoder<TransformMessage[encryptAlgorithm]> =>
                dispatch (endpoint Server over server) accepts m;
            default =>
                ThrowDecodingException("SMB2 Transform");
        }
    }

    // Parsing Transform response message
    process server issues s:SMBOverTCP.TransportPacket where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        ushort encryptAlgorithm = GetEncryptAlgorithmFromSMB2TransformMessage(s.SMBMessage);
        switch (s.SMBMessage)
        {
            case m:TransformMessage[encryptAlgorithm] from BinaryDecoder<TransformMessage[encryptAlgorithm]> =>
                dispatch (endpoint Server over server) issues m;
            default =>
                ThrowDecodingException("SMB2 Transform");
        }
    }
}

// Actor that listens to SessionService messages on both possible directions.
autostart actor SMB2OverNBTSS(NBTSS.Server server) precedes NamedPipe.SMB2NamedPipeOverNBTSS
{
    DecodingCache dc = new DecodingCache{};
    
    // Parsing request message
    process server accepts s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchRequestMessages(dc, (s.Trailer as SessionMessagePacket).UserData, server);
    }

    // Parsing response message
    process server issues s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchResponseMessages(dc, (s.Trailer as SessionMessagePacket).UserData, server);
    }

    // Parsing Transform request message
    process server accepts s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        ushort encryptAlgorithm = GetEncryptAlgorithmFromSMB2TransformMessage((s.Trailer as SessionMessagePacket).UserData);
        switch ((s.Trailer as SessionMessagePacket).UserData)
        {
            case m:TransformMessage[encryptAlgorithm] from BinaryDecoder<TransformMessage[encryptAlgorithm]> =>
                dispatch (endpoint Server over server) accepts m;
            default =>
                 ThrowDecodingException("SMB2 TransformMessage");
        }
    }

    // Parsing Transform response message
    process server issues s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        ushort encryptAlgorithm = GetEncryptAlgorithmFromSMB2TransformMessage((s.Trailer as SessionMessagePacket).UserData);
        switch ((s.Trailer as SessionMessagePacket).UserData)
        {
            case m:TransformMessage[encryptAlgorithm] from BinaryDecoder<TransformMessage[encryptAlgorithm]> =>
                dispatch (endpoint Server over server) accepts m;
            default =>
                 ThrowDecodingException("SMB2 TransformMessage");
        }
    }
}

// Reassemble the buffer data the if the status returned is STATUS_BUFFER_OVERFLOW for IoctlResponse and ReadResponse
autostart actor NamedPipeReassembleServerToNamedPipeServerActor(NamedPipeReassembleServer server) 
{
    // Keeps the fragmented buffer data
    binary bufferData = $[];
    // Keeps the message origins for the reassembed message
    array<any message> origins = [];
    
    observe server accepts m:Messages.CloseRequest
    {
        ReleaseOrigins();
    }
    
    process server issues m:Messages.IoctlResponse
    {
        if (IsNeedReassemble(m.Response.Buffer, GetStatus(m.Header), m))
        {
            if (GetStatus(m.Header) != 0x80000005)
            {
                // Create the reassembled message base on the last message
                var lastRes = m.Response;
                var reponse = new SMB2IoctlResponse
                    {
                        StructureSize = lastRes.StructureSize,
                        Reserved = lastRes.Reserved,
                        CtlCode = lastRes.CtlCode,
                        FileId = lastRes.FileId,
                        InputOffset = lastRes.InputOffset,
                        InputCount = lastRes.InputCount,
                        OutputCount = bufferData.Count as uint,
                        Flags = lastRes.Flags,
                        Reserved2 = lastRes.Reserved2,
                        InputBufferPadding = lastRes.InputBufferPadding,
                        InputBuffer = lastRes.InputBuffer,
                        OutputBufferPadding = lastRes.OutputBufferPadding,
                        Buffer = bufferData
                    };
                var reMsg = new Messages.IoctlResponse{ Header = m.Header, Response = reponse };
                reMsg.Response.AssignFieldEncodingInfo("Buffer", 0, bufferData.Count * 8);
                reMsg#SMBFileName = m#SMBFileName;
                reMsg#SMBFileId = m#SMBFileId;
                DispatchReassembledResponse(reMsg);
            }
        }
        else
        {
            dispatch (endpoint NamedPipeServer[server.FileName] over server) issues m;
        }
    }
    
    process server issues m:Messages.ReadResponse
    {
        if (IsNeedReassemble(m.Response.Buffer, GetStatus(m.Header), m))
        {
            if (GetStatus(m.Header) != 0x80000005)
            {
                // Create the reassembled message base on the last message
                var lastRes = m.Response;
                var reponse = new SMB2ReadResponse
                    {
                        StructureSize = lastRes.StructureSize,
                        DataOffset = lastRes.DataOffset,
                        Reserved = lastRes.Reserved,
                        DataLength = bufferData.Count as uint,
                        DataRemaining = lastRes.DataRemaining,
                        Reserved2 = lastRes.Reserved2,
                        DataPadding = lastRes.DataPadding,
                        Buffer = bufferData,
                    };
                var reMsg = new Messages.ReadResponse{ Header = m.Header, Response = reponse };
                reMsg.Response.AssignFieldEncodingInfo("Buffer", 0, bufferData.Count * 8);
                reMsg#SMBFileName = m#SMBFileName;
                reMsg#SMBFileId = m#SMBFileId;
                DispatchReassembledResponse(reMsg);
            }
        }
        else
        {
            dispatch (endpoint NamedPipeServer[server.FileName] over server) issues m;
        }
    }
    
    // Dispatch other commands
    process server accepts m:ReqFileMessage
    {
        dispatch (endpoint NamedPipeServer[server.FileName] over server) accepts m;
    }
    
    process server issues m:ResFileMessage where !(GetCommand(m.Header) in {SMB2PacketHeaderCommand.SMB2Read, SMB2PacketHeaderCommand.SMB2Ioctl})
    {
        dispatch (endpoint NamedPipeServer[server.FileName] over server) issues m;
    }
    
    // Check if the Buffer need reassembled and hold the partial data and the message in cache
    bool IsNeedReassemble(any buffer, optional uint status, any message origin)
    {
        if (buffer is binary && status != nothing)
        {
            // The current message or the message it followed to has returned STATUS_BUFFER_OVERFLOW
            if ((status == 0x80000005) || origins.Count > 0)
            {
                bufferData += (buffer as binary);
                origins += [origin];
                return true;
            }
        }
        return false;
    }

    void DispatchReassembledResponse(ResFileMessage reMsg)
    {
        reMsg#IsReassembled = true;
        reMsg.SourceData = bufferData;
        reMsg.Origins = origins;
        dispatch (endpoint NamedPipeServer[server.FileName] over server) issues reMsg;
        origins = [];
        bufferData = $[];
    }
    
    // Release the messages stalled in the cache
    void ReleaseOrigins()
    {
        if (origins != null && origins.Count > 0)
        {
            foreach (var m in origins)
            {
                DisplayTopLevelMessage(m);
            }
            origins = null;
        }
    }
    
    // endpoint destructor
    ~endpoint(NamedPipeReassembleServer server)
    {
        ReleaseOrigins();
    }
}

autostart actor MsrpceOverSmb2Server(SMB2.NamedPipeServer server)
{
    binary incompleteRequestSourceData = $[];
    binary incompleteResponseSourceData = $[];
    array<any message> requestMsgOrigins = [];
    array<any message> responseMsgOrigins = [];
    
    process server issues s:SMB2.Messages.ReadResponse where incompleteResponseSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Response.Buffer)
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s#SMBFileId != nothing ? s#SMBFileId as ulong : 0];
        MsrpceProcessSmbMessages(reasseblyServer, s.Response.Buffer, ref incompleteResponseSourceData, GetStatus(s.Header), ref responseMsgOrigins, s, CoReassemblyIssuesDispatcher);
    }

    process server accepts s:SMB2.Messages.WriteRequest where incompleteRequestSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Request.Buffer)
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s.Request.FileId.Persistent];
        MsrpceProcessSmbMessages(reasseblyServer, s.Request.Buffer, ref incompleteRequestSourceData, nothing, ref requestMsgOrigins, s, CoReassemblyAcceptsDispatcher);
    }
    
    process server accepts s:SMB2.Messages.IoctlRequest where (s.Request.Buffer is binary) && (incompleteRequestSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Request.Buffer as binary))
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s.Request.FileId.Persistent];
        MsrpceProcessSmbMessages(reasseblyServer, s.Request.Buffer as binary, ref incompleteRequestSourceData, nothing, ref requestMsgOrigins, s, CoReassemblyAcceptsDispatcher);
    }
    
    process server issues s:SMB2.Messages.IoctlResponse where (s.Response.Buffer is binary) && (incompleteResponseSourceData.Count > 0 || IsRpcconnCommonHdrT(s.Response.Buffer as binary))
    {
        var reasseblyServer = endpoint ServerOverNamedpipe[s#SMBFileId != nothing ? s#SMBFileId as ulong : 0];
        MsrpceProcessSmbMessages(reasseblyServer, s.Response.Buffer as binary, ref incompleteResponseSourceData, GetStatus(s.Header), ref responseMsgOrigins, s, CoReassemblyIssuesDispatcher);
    }
    
    ~endpoint(SMB2.NamedPipeServer server)
    {
        MSRPCE.DispatchOriginsToRevive(ref requestMsgOrigins);
        MSRPCE.DispatchOriginsToRevive(ref responseMsgOrigins);
    }
}

//[MS-NLMP] has no reference on SMB2 how uses NLMP, the materials are described in [MS-SMB2].
//Therefore, it is not very reasonable to keep the following actor in this OPN file.
//To solve the problem, either 1. update [MS-NLMP] to add the SMB2 reference or 2. move the following actor to the SMB2.opn file
//However, the second option of moving the following actor to the SMB2.opn has some risks since it will cause a cyclic reference: SMB2 -> NLMP -> MSRPCE -> SMB2,
//which will make the MA crash. Need further review on how to deal with this problem.
autostart actor NLMPOverSMB2(SMB2.Server server)
{
    bool micPresent = false;
    // $[4E544C4D53535000] = "NTLMSSP", which is the entry of messages.
    observe server issues s:SMB2.Messages.SessionSetupResponse where ((s.Response.Buffer is binary) && (s.Response.Buffer as binary).Segment(0,8) == $[4E544C4D53535000])
    {
        binary payload = s.Response.Buffer as binary;
        var nlmpMessage = NlmpDecoder(payload, ref micPresent);
        if (nlmpMessage != nothing && ((nlmpMessage as any message) is NlmpMessage))
        {
            s.Response.Buffer = nlmpMessage;
            s#Embedded = {"NLMP" -> s.Response.Buffer};
        }
    }
    
    observe server accepts s:SMB2.Messages.SessionSetupRequest where ((s.Request.Buffer is binary) && (s.Request.Buffer as binary).Segment(0,8) == $[4E544C4D53535000])
    {
        binary payload = s.Request.Buffer as binary;
        var nlmpMessage = NlmpDecoder(payload, ref micPresent);
        if (nlmpMessage != nothing)
        {
            s.Request.Buffer = nlmpMessage;
            any message nlmp = nlmpMessage as any message;
            s#Embedded = {"NLMP" -> nlmp};
        }
    }
}

 //Decode GSSAPI and SPNG structure for SMB2
 //Note: This actor is working on endpoint VirtualOperationServer to make sure GSSAPI strucutre gets decoded
 //before SMB2 operation get constructed, since the operation construction will usually trigger the message
 //stack get serialized into message store
autostart actor GssapiOverSmb2(SMB2.VirtualOperationServer server) precedes SMB2.VirtualOperationServer
{
    bool micPresent = false;
    observe server accepts s:SMB2.Messages.SessionSetupRequest where (s.Header.Command == 0x0001
                                                                        && (s.Request.Buffer is binary)
                                                                        && (s.Request.Buffer as binary).Count > 0
                                                                        && (s.Request.Buffer as binary)[0] in {0x60, 0xA0, 0xA1})
    {
        bool result = IsGssapiMessageOverSmb2(s, ref micPresent);
        ValidationCheck(result, s, DiagnosisLevel.Warning, "SMB2: The SecurityBlob in type SMB2SessionSetupRequest should be decoded as GSSAPI.");
    }
    
    observe server issues s:SMB2.Messages.SessionSetupResponse where (GetCommand(s.Header) == 0x0001
                                                                        && (s.Response.Buffer is binary)
                                                                        && (s.Response.Buffer as binary).Count > 0
                                                                        && (s.Response.Buffer as binary)[0] in {0x60, 0xA0, 0xA1})
    {
        bool result = IsGssapiMessageOverSmb2(s, ref micPresent);
        ValidationCheck(result, s, DiagnosisLevel.Warning, "SMB2: The SecurityBlob in type SMB2SessionSetupResponse should be decoded as GSSAPI.");
    }

    observe server issues s:SMB2.Messages.NegotiateResponse where (GetCommand(s.Header) == 0x0000
                                                                    && (s.Response.Buffer is binary)
                                                                    && (s.Response.Buffer as binary).Count > 0
                                                                    && (s.Response.Buffer as binary)[0] in {0x60, 0xA0, 0xA1})
    {
        bool result = IsGssapiMessageOverSmb2(s, ref micPresent);
        ValidationCheck(result, s, DiagnosisLevel.Warning, "SMB2: The SecurityBlob in type SMB2NegotiateResponse should be decoded as GSSAPI.");
    }
}

bool IsGssapiMessageOverSmb2((SMB2.Messages.SessionSetupRequest
                            | SMB2.Messages.SessionSetupResponse
                            | SMB2.Messages.NegotiateResponse) Smb2Msg, ref bool micPresent)
{
    bool result = false;
    switch (Smb2Msg)
    {
        case msg:SMB2.Messages.SessionSetupRequest =>
            if (msg.Request.Buffer is binary)
            {
                stream s = msg.Request.Buffer as binary;
                var m = GssapiDecoder(s, ref micPresent);
                if (m != nothing)
                {
                    msg.Request.Buffer = m;
                    result = true;
                    SetEmbeddedForNlmp(msg, m as GssapiType);
                }
            }
        case msg:SMB2.Messages.SessionSetupResponse =>
            if (msg.Response.Buffer is binary)
            {
                stream s = msg.Response.Buffer as binary;
                var m = GssapiDecoder(s, ref micPresent);
                if (m != nothing)
                {
                    msg.Response.Buffer = m;
                    result = true;
                    SetEmbeddedForNlmp(msg, m as GssapiType);
                }
            }
        case msg:SMB2.Messages.NegotiateResponse =>
            if (msg.Response.Buffer is binary)
            {
                stream s = msg.Response.Buffer as binary;
                var m = GssapiDecoder(s, ref micPresent);
                if (m != nothing)
                {
                    msg.Response.Buffer = m;
                    result = true;
                    SetEmbeddedForNlmp(msg, m as GssapiType);
                }
            }
        default =>
            result = false;
    }
    return result;
}

// -------------------------------------------
// Types and funtions for the message decoding

// Keep the values during the decoding
type DecodingCache
{
    // Keep the values from the request message to decode the buffer in reponse message for QueryInfo
    map<double, byte> queryInfoTypeMap = {};
    map<double, byte> queryInfoClassMap = {};
    // Keep the values from the request message to decode the buffer in reponse message for IOCTL
    map<double, uint?> hashRetrievalTypeMap = {};
    map<double, uint?> hashVersionMap = {};
    
    // Indicates what PduFull is set in etw provider
    bool pduFull = true;
}

// Defined for look ahead the field values in the Header part
type SMB2Header
{
    ushort StructureSize;
    ushort CreditCharge;
    uint Status;
    ushort Command;
    ushort Credit;
    SMB2PacketHeaderFlags Flags;
    uint NextCommand;
    ulong MessageId;
    ulong AsyncId;
    ulong SessionId;
}

// Decode the message by the command type
T DecodeMessage<T>(stream data, string command)
{
    switch (data)
    {
        case m:T from BinaryDecoder<T> =>
            return m;
        default =>
            TryDecodeHeaderOnlyMessage(data, command);
    }
    T t;
    return t; // return null
}

// Decode the message by the command type and get value of the FileId
T DecodeMessage<T>(binary data, string command, void(T, ulong) fidSetter, ulong(T) fileId)
{
    switch (data)
    {
        case m:T from BinaryDecoder<T> =>
            ulong fid = fileId(m);
            fidSetter(m, fid);
            return m;
        default =>
            TryDecodeHeaderOnlyMessage(data, command);
    }
    T t;
    return t; // return null
}

void SetReqFileId(ReqFileMessage m, ulong fid)
{
    m#FileId = fid;
}

void SetResFileId(ResFileMessage m, ulong fid)
{
    m#FileId = fid;
}

// Get the VirtualOperationServer endpoint binding over the lower transport endpoint
VirtualOperationServer GetVirtualOperationServer((SMBOverTCP.Server | NBTSS.Server) server, ulong index)
{
    VirtualOperationServer node;
    switch (server)
    {
        case lowerNode:SMBOverTCP.Server =>
            node = endpoint VirtualOperationServer[index] over lowerNode;
            node.server = endpoint SMB2.Server over lowerNode;
            
        case lowerNode:NBTSS.Server =>
            node = endpoint VirtualOperationServer[index] over lowerNode;
            node.server = endpoint SMB2.Server over lowerNode;
        
        default =>
            // No binding of the lower endpoint for other transports
            node = endpoint VirtualOperationServer[index];
            node.server = endpoint SMB2.Server;
            return node;
    }

    if (node.server.supportsMultiChannel)
    {
        // Remove the binding of the lower endpoint if the server supports establishing multiple channels for sessions.
        node.server = endpoint SMB2.Server;
    }
    
    return node;
}

// Try to decode the insufficient data into the header only message
void TryDecodeHeaderOnlyMessage(stream data, string msgName)
{
    bool isRequest = ((data.PeekByte(16 * 8) as int) & 0x01) == 0; // Look ahead the ServerToRedir bit
    switch (data)
    {
        case m: SMB2HeaderOnly from BinaryDecoder<SMB2HeaderOnly[isRequest]> =>
            m#SMB2MessageName = msgName;
            DisplayTopLevelMessage(m);
        default =>
            ThrowDecodingException(msgName);
    }
}

// Decoding the request messages
void DecodeAndDispatchRequestMessages(DecodingCache dc, binary payload, (SMBOverTCP.Server | NBTSS.Server) server)
{
    // The beginning offset of current message
    int offset = 0;
    // The beginning offset of next message
    int nextOffset = 0;
    var streamLength = payload.Count;

    // Keep the file name for the related operation in a compounded request chain
    string fileNameRelated = "";

    while (offset + 64 < streamLength) // 64 is the total size of the Header part
    {
        switch (payload.Segment(offset + 4, 44))
        {
            case header:SMB2Header from BinaryDecoder<SMB2Header> =>
                nextOffset = (header.NextCommand == 0 ? streamLength : header.NextCommand + offset) as int;
                var messageData = payload.Segment(offset, nextOffset - offset);

                /* Always take AsyncId as Virtual Operation endpoint index if the header is AsyncHeader, because AsyncId will be unique in a server connection scope.
                 * Besides that, all requests will use Sync Header, except CancelRequest might use AsyncHeader.
                 */
                bool isAsyncCommand = (header.Flags & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) > 0;
                ulong index = isAsyncCommand ? header.AsyncId : header.MessageId;
                var node = GetVirtualOperationServer(server, index);
                node.isRequestLost = false;
                node.IsAsyncRequest = isAsyncCommand;
                node.server.hasAnyMessageDecodeFailed = true;
                any message m;
                switch (header.Command)
                {
                    case SMB2PacketHeaderCommand.SMB2Negotiate =>
                        m = DecodeMessage<Messages.NegotiateRequest>(messageData, "NegotiateRequest");

                    case SMB2PacketHeaderCommand.SMB2SessionSetup =>
                        var tm = DecodeMessage<Messages.SessionSetupRequest>(messageData, "SessionSetupRequest");
                        if (tm != null)
                        {
                            if (messageData.Count < tm.Request.SecurityBufferOffset + tm.Request.SecurityBufferLength)
                            {
                                ReportInsufficientData(tm, "SMB2", "Buffer", "SessionSetupRequest", !dc.pduFull);                                                                                  
                            }
                            m = tm;
                        }

                    case SMB2PacketHeaderCommand.SMB2Logoff =>
                        m = DecodeMessage<Messages.LogoffRequest>(messageData, "LogoffRequest");

                    case SMB2PacketHeaderCommand.SMB2TreeConnect =>
                        m = DecodeMessage<Messages.TreeConnectRequest>(messageData, "TreeConnectRequest");

                    case SMB2PacketHeaderCommand.SMB2TreeDisconnect =>
                        m = DecodeMessage<Messages.TreeDisconnectRequest>(messageData, "TreeDisconnectRequest");

                    case SMB2PacketHeaderCommand.SMB2Create =>
                        m = DecodeMessage<Messages.CreateRequest>(messageData, "CreateRequest");

                    case SMB2PacketHeaderCommand.SMB2Close =>
                        m = DecodeMessage<Messages.CloseRequest>(messageData, "CloseRequest", SetReqFileId,
                            (Messages.CloseRequest f) => f.Request.FileId.Persistent);

                    case SMB2PacketHeaderCommand.SMB2Flush =>
                        m = DecodeMessage<Messages.FlushRequest>(messageData, "FlushRequest", SetReqFileId,
                            (Messages.FlushRequest f) => f.Request.FileId.Persistent);

                    case SMB2PacketHeaderCommand.SMB2Read =>
                        m = DecodeMessage<Messages.ReadRequest>(messageData, "ReadRequest", SetReqFileId,
                            (Messages.ReadRequest f) => f.Request.FileId.Persistent);

                    case SMB2PacketHeaderCommand.SMB2Write =>
                        var tm = DecodeMessage<Messages.WriteRequest>(messageData, "WriteRequest", SetReqFileId,
                            (Messages.WriteRequest f) => f.Request.FileId.Persistent);
                        if (tm != null)
                        {
                            if (messageData.Count < tm.Request.DataOffset + tm.Request.Length)
                            {
                                ReportInsufficientData(tm, "SMB2", "Buffer", "WriteRequest", !dc.pduFull);                                                                                                                  
                            }
                            m = tm;
                        }
                        
                    case SMB2PacketHeaderCommand.SMB2Lock =>
                        m = DecodeMessage<Messages.LockRequest>(messageData, "LockRequest", SetReqFileId,
                            (Messages.LockRequest f) => f.Request.FileId.Persistent);

                    case SMB2PacketHeaderCommand.SMB2Ioctl =>
                        var tm = DecodeMessage<Messages.IoctlRequest>(messageData, "IoctlRequest", SetReqFileId,
                            (Messages.IoctlRequest f) => f.Request.FileId.Persistent);
                        if (tm != null)
                        {
                            if (messageData.Count < tm.Request.InputOffset + tm.Request.InputCount)
                            {
                                ReportInsufficientData(tm, "SMB2", "Buffer", "IoctlRequest", !dc.pduFull);                                                                                                                                                  
                            }
                        
                            // Keep the HashRetrievalType in cache for the reponse message
                            switch (tm.Request.Buffer)
                            {
                                case buffer:SrvReadHashRequest =>
                                {
                                    var key = CombineAsDouble(header.MessageId, header.SessionId);
                                    dc.hashRetrievalTypeMap[key] = buffer.HashRetrievalType;
                                    dc.hashVersionMap[key] = buffer.HashVersion;
                                }
                            }
                            m = tm;
                        }

                    case SMB2PacketHeaderCommand.SMB2Echo =>
                        m = DecodeMessage<Messages.EchoRequest>(messageData, "EchoRequest");
                        
                    case SMB2PacketHeaderCommand.SMB2Cancel =>
                        m = DecodeMessage<Messages.CancelRequest>(messageData, "CancelRequest");
                    
                    case SMB2PacketHeaderCommand.SMB2QueryDirectory =>
                        var tm = DecodeMessage<Messages.QueryDirectoryRequest>(messageData, "QueryDirectoryRequest", SetReqFileId,
                            (Messages.QueryDirectoryRequest f) => f.Request.FileId.Persistent);
                        if (tm != null)
                        {
                            var key = CombineAsDouble(header.MessageId, header.SessionId);
                            dc.queryInfoClassMap[key] = tm.Request.FileInformationClass;
                            m = tm;
                        }

                    case SMB2PacketHeaderCommand.SMB2ChangeNotify =>
                        m = DecodeMessage<Messages.ChangeNotifyRequest>(messageData, "ChangeNotifyRequest", SetReqFileId,
                            (Messages.ChangeNotifyRequest f) => f.Request.FileId.Persistent);

                    case SMB2PacketHeaderCommand.SMB2QueryInfo =>
                        var tm = DecodeMessage<Messages.QueryInfoRequest>(messageData, "QueryInfoRequest", SetReqFileId,
                            (Messages.QueryInfoRequest f) => f.Request.FileId.Persistent);
                        if (tm != null)
                        {
                            var key = CombineAsDouble(header.MessageId, header.SessionId);
                            dc.queryInfoTypeMap[key] = tm.Request.InfoType;
                            dc.queryInfoClassMap[key] = tm.Request.FileInfoClass;
                            if (messageData.Count < tm.Request.InputBufferOffset + tm.Request.InputBufferLength)
                            {
                                ReportInsufficientData(tm, "SMB2", "Buffer", "QueryInfoRequest", !dc.pduFull);                                                                                                                                                                                  
                            }
                            m = tm;
                        }

                    case SMB2PacketHeaderCommand.SMB2SetInfo =>
                        var tm = DecodeMessage<Messages.SetInfoRequest>(messageData, "SetInfo Request", SetReqFileId, 
                            (Messages.SetInfoRequest f) => f.Request.FileId.Persistent);
                        if (tm != null)
                        {
                            if (messageData.Count < tm.Request.BufferOffset + tm.Request.BufferLength)
                            {
                                ReportInsufficientData(tm, "SMB2", "Buffer", "SetInfoRequest", !dc.pduFull);                                                                                                                                                                                                                  
                            }
                            m = tm;
                        }
                        
                    case SMB2PacketHeaderCommand.SMB2OplockBreak =>
                        // Look ahead the value of the StructureSize field in request package
                        var structureSize = BinaryDecoder<ushort>(messageData.Segment(64,2));
                        if (structureSize == 24)
                        {
                            m = DecodeMessage<Messages.OplockBreakAcknowledgment>(messageData, "OplockBreakAcknowledgment", SetReqFileId,
                                (Messages.OplockBreakAcknowledgment f) => f.Acknowledgment.FileId.Persistent);
                        }
                        else
                        {
                            m = DecodeMessage<Messages.LeaseBreakAcknowledgment>(messageData, "LeaseBreakAcknowledgment");
                        }

                    default =>
                        ThrowDecodingExceptionWithReason("SMB2", "unknown SMB2 request message");    
                }
                
                if (m != null)
                {
                    // Update the FileName anotation for the related operation in a compounded request chain
                    if (fileNameRelated != "" && m is ReqFileMessage)
                    {
                        ReqFileMessage rfm = m as ReqFileMessage;
                        rfm#SMBFileName = fileNameRelated;
                    }
                    node.server.hasAnyMessageDecodeFailed = false;
                    // Dipatch the message
                    dispatch node accepts m;
                    
                    // Set annotation for create request.
                    if (m is Messages.CreateRequest)
                    {
                        var createReq = m as Messages.CreateRequest;
                        createReq#SMBFileName = (createReq.Request.Buffer.Name == "" || createReq.Request.Buffer == null) ? "*NULL*": createReq.Request.Buffer.Name;
                        createReq#SMBFileName = (createReq#SMBFileName as string ) + "@#" + (createReq.FrameSequenceNumber as string);
                        if (header.NextCommand != 0)
                        {
                            fileNameRelated = createReq#SMBFileName as string;
                        }
                    }
                    m = null;
                }
                // Update the offset value to the beginning of next message
                offset = nextOffset;
            default =>
                ThrowDecodingException("SMB2", "SMB2Header");
        }
    }
}

// Decoding the response messages
void DecodeAndDispatchResponseMessages(DecodingCache dc,  binary payload, (SMBOverTCP.Server | NBTSS.Server) server)
{
    int offset = 0;
    int nextOffset = 0;
    var streamLength = payload.Count;

    while (offset + 64 < streamLength) // 64 is the total size of the Header part
    {
        switch (payload.Segment(offset + 4, 44))
        {
            case header:SMB2Header from BinaryDecoder<SMB2Header> =>
                nextOffset = (header.NextCommand == 0 ? streamLength : header.NextCommand + offset) as int;
                var messageData = payload.Segment(offset, nextOffset - offset);
                // Look ahead the value of the StructureSize field in reponse package
                var structureSize = BinaryDecoder<ushort>(messageData.Segment(64, 2)) as ushort;
                var node = GetVirtualOperationServer(server, header.MessageId);
                node.server.hasAnyMessageDecodeFailed = true;
                any message m;
                bool isAsyncCommand = (header.Flags & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) > 0;
                if (IsErrorResponse(header.Command, header.Status, structureSize, isAsyncCommand))
                {
                    /* Take AsyncId as high priority for Virtual Operation endpoint index if the header is AsyncHeader, because AsyncId will be unique in a server connection scope.
                     * If the endpoint got by AsyncId has no AsyncRequest, we will choose MessageId as the endpoint index again.
                     */
                    if (isAsyncCommand)
                    {
                        var temp = GetVirtualOperationServer(server, header.AsyncId);
                        if (temp.IsAsyncRequest)
                        {
                            node = temp;
                            node.server.hasAnyMessageDecodeFailed = true;
                        }
                        else
                        {
                            // Just for a case identifier for OPN logic correction and give OPN developer possible error notes when it is found in regression test.
                            ValidationCheck(header.MessageId != 0 || header.Command == SMB2PacketHeaderCommand.SMB2Negotiate, null, DiagnosisLevel.Error, "SMB2: AsyncHeader in Response should not contain MessageId equals 0.");
                        }
                    }
                    stream s = messageData;
                    switch (s)
                    {
                        case tm:Messages.ErrorResponse from BinaryDecoder<Messages.ErrorResponse[header.Status]> =>
                            // Manully decode the SymbolicLinkErrorResponseErrorData.PathBuffer in details
                            switch(tm.Response.ErrorData)
                            {
                                case errorData:SymbolicLinkErrorResponseErrorData =>
                                    var pos1 = s.BitPosition + errorData.SubstituteNameOffset * 8;
                                    var len1 = errorData.SubstituteNameLength;
                                    string substituteName = BinaryDecoder<string>(s.PeekBytes(pos1, len1)) as string;
                                    var pos2 = s.BitPosition + errorData.PrintNameOffset * 8;
                                    var len2 = errorData.PrintNameLength;
                                    string printName = BinaryDecoder<string>(s.PeekBytes(pos2, len2)) as string;
                                    errorData.PathBuffer = new PathBuffer
                                        {
                                            SubstituteName = substituteName,
                                            PrintName = printName
                                        };
                            }
                            m = tm;
                        default =>
                            TryDecodeHeaderOnlyMessage(messageData,"ErrorResponse");
                    }
                }
                else
                {
                    switch (header.Command)
                    {
                        case SMB2PacketHeaderCommand.SMB2Negotiate =>
                            var tm = DecodeMessage<Messages.NegotiateResponse>(messageData, "NegotiateResponse");
                            if (tm != null)
                            {
                                /* WORKAROUND: Assign the DialectRevision to global variable SMB2DialectRevision.
                                 * Will remove this global variable in the Server endpoint when BUG#39968 and 43830 is fixed
                                 * BUG#39968: The value parameter feature doesn't work properly when a type overriding a type with value parameters.
                                 */
                                SMB2DialectRevision = tm.Response.DialectRevision;
                                if (messageData.Count < tm.Response.SecurityBufferLength + tm.Response.SecurityBufferOffset)
                                {
                                    ReportInsufficientData(tm, "SMB2", "Buffer", "NegotiateResponse", !dc.pduFull);                                                                                                                                                                                                                  
                                }
                                m = tm;
                            }

                        case SMB2PacketHeaderCommand.SMB2SessionSetup =>
                            var tm = DecodeMessage<Messages.SessionSetupResponse>(messageData, "SessionSetupResponse");
                            if (tm != null)
                            {
                                if (messageData.Count < tm.Response.SecurityBufferOffset + tm.Response.SecurityBufferLength)
                                {
                                    ReportInsufficientData(tm, "SMB2", "Buffer", "SessionSetupResponse", !dc.pduFull);                                                                                                                                                                                                                                                      
                                }
                                m = tm;
                            }
                            
                        case SMB2PacketHeaderCommand.SMB2Logoff =>
                            m = DecodeMessage<Messages.LogoffResponse>(messageData, "LogoffResponse");

                        case SMB2PacketHeaderCommand.SMB2TreeConnect =>
                            m = DecodeMessage<Messages.TreeConnectResponse>(messageData, "TreeConnectResponse");
                            
                        case SMB2PacketHeaderCommand.SMB2TreeDisconnect =>
                            m = DecodeMessage<Messages.TreeDisconnectResponse>(messageData, "TreeDisconnectResponse");

                        case SMB2PacketHeaderCommand.SMB2Create =>
                            m = DecodeMessage<Messages.CreateResponse>(messageData, "CreateResponse", SetResFileId,
                                (Messages.CreateResponse f) => f.Response.FileId.Persistent);

                        case SMB2PacketHeaderCommand.SMB2Close =>
                            m = DecodeMessage<Messages.CloseResponse>(messageData, "CloseResponse");

                        case SMB2PacketHeaderCommand.SMB2Flush =>
                            m = DecodeMessage<Messages.FlushResponse>(messageData, "FlushResponse");

                        case SMB2PacketHeaderCommand.SMB2Read =>
                            var tm = DecodeMessage<Messages.ReadResponse>(messageData, "ReadResponse");
                            if (tm != null)
                            {
                                if (messageData.Count < tm.Response.DataOffset + tm.Response.DataLength)
                                {
                                    ReportInsufficientData(tm, "SMB2", "Buffer", "ReadResponse", !dc.pduFull);                                                                                                                                                                                                                                                                                          
                                }
                                m = tm;
                            }
                                    
                        case SMB2PacketHeaderCommand.SMB2Write =>
                            m = DecodeMessage<Messages.WriteResponse>(messageData, "WriteResponse");

                        case SMB2PacketHeaderCommand.SMB2Lock =>
                            m = DecodeMessage<Messages.LockResponse>(messageData, "LockResponse");

                        case SMB2PacketHeaderCommand.SMB2Ioctl =>
                            var key = CombineAsDouble(header.MessageId, header.SessionId);
                            uint? hashRetrievalType = null;
                            uint? hashVersion = null;
                            if (key in dc.hashRetrievalTypeMap)
                            {
                                hashRetrievalType = dc.hashRetrievalTypeMap[key];
                                dc.hashRetrievalTypeMap = dc.hashRetrievalTypeMap.Remove(key);
                            } 
                            if (key in dc.hashVersionMap)
                            {
                                hashVersion = dc.hashVersionMap[key];
                                dc.hashVersionMap = dc.hashVersionMap.Remove(key);
                            } 
                            switch (messageData)
                            {
                                case tm:Messages.IoctlResponse from BinaryDecoder<Messages.IoctlResponse[hashRetrievalType, hashVersion]> =>
                                    tm#FileId = tm.Response.FileId.Persistent;
                                    if (messageData.Count < tm.Response.OutputOffset + tm.Response.OutputCount)
                                    {
                                        ReportInsufficientData(tm, "SMB2", "Buffer", "IoctlResponse", !dc.pduFull);                                                                                                                                                                                                                                                                                          
                                    }
                                    m = tm;
                                default =>
                                    TryDecodeHeaderOnlyMessage(messageData, "IoctlResponse");
                            }
                            
                        case SMB2PacketHeaderCommand.SMB2Echo =>
                            m = DecodeMessage<Messages.EchoResponse>(messageData, "EchoResponse");

                        case SMB2PacketHeaderCommand.SMB2QueryDirectory =>
                            var key = CombineAsDouble(header.MessageId, header.SessionId);
                            var queryInfoClass = key in dc.queryInfoClassMap ? dc.queryInfoClassMap[key] : nothing;
                            switch (messageData)
                            {
                                case tm:Messages.QueryDirectoryResponse from BinaryDecoder<Messages.QueryDirectoryResponse[queryInfoClass]> =>
                                    if (messageData.Count < tm.Response.OutputBufferOffset + tm.Response.OutputBufferLength)
                                    {
                                        ReportInsufficientData(tm, "SMB2", "Buffer", "QueryDirectoryResponse", !dc.pduFull);                                                                                                                                                                                                                                                                                                                                  
                                    }
                                    m = tm;
                                default =>
                                    TryDecodeHeaderOnlyMessage(messageData, "QueryDirectoryResponse");
                            }
                            
                        case SMB2PacketHeaderCommand.SMB2ChangeNotify =>
                            m = DecodeMessage<Messages.ChangeNotifyResponse>(messageData, "ChangeNotifyResponse");

                        case SMB2PacketHeaderCommand.SMB2QueryInfo =>
                            var key = CombineAsDouble(header.MessageId, header.SessionId);
                            optional byte queryInfoType = key in dc.queryInfoTypeMap ? dc.queryInfoTypeMap[key] : nothing;
                            optional byte queryInfoClass = key in dc.queryInfoClassMap ? dc.queryInfoClassMap[key] : nothing;
                            switch (messageData)
                            {
                                case tm:Messages.QueryInfoResponse from BinaryDecoder<Messages.QueryInfoResponse[queryInfoType, queryInfoClass]> =>
                                    if (messageData.Count < tm.Response.OutputBufferOffset + tm.Response.OutputBufferLength)
                                    {
                                        ReportInsufficientData(tm, "SMB2", "Buffer", "QueryInfoResponse", !dc.pduFull);                                                                                                                                                                                                                                                                                                                                                                          
                                    }
                                    m = tm;
                                default =>
                                    TryDecodeHeaderOnlyMessage(messageData, "QueryInfoResponse");
                            }
                            
                        case SMB2PacketHeaderCommand.SMB2SetInfo =>
                            m = DecodeMessage<Messages.SetInfoResponse>(messageData, "SetInfoResponse");

                        case SMB2PacketHeaderCommand.SMB2OplockBreak =>
                            // Use the StructureSize to differentiate between an oplock break message and a lease break message
                            if (structureSize == 24)
                            {
                                // If the MessageId field of the SMB2 header of the response is 0xFFFFFFFFFFFFFFFF, this MUST be processed as an oplock break indication.
                                if (header.MessageId == InvalidMessageId)
                                {
                                    node.isRequestLost = false;
                                    m = DecodeMessage<Messages.OplockBreakNotification>(messageData, "OplockBreakNotification", SetResFileId,
                                        (Messages.OplockBreakNotification f) => f.Notification.FileId.Persistent);
                                }
                                else
                                {
                                    m = DecodeMessage<Messages.OplockBreakResponse>(messageData, "OplockBreakResponse", SetResFileId,
                                        (Messages.OplockBreakResponse f) => f.Response.FileId.Persistent);
                                }
                            }
                            else if (structureSize == 44)
                            {
                                node.isRequestLost = false;
                                m = DecodeMessage<Messages.LeaseBreakNotification>(messageData, "LeaseBreakNotification");
                            }
                            else
                            {
                                m = DecodeMessage<Messages.LeaseBreakResponse>(messageData, "LeaseBreakResponse");
                            }

                        default =>
                            ThrowDecodingExceptionWithReason("SMB2", "unknown SMB2 response message");
                    }
                }
                if (m != null)
                {
                    ValidationCheck((header.Flags & SMB2PacketHeaderFlags.SMB2FlagsServerToRedir) > 0, m, DiagnosisLevel.Error, "SMB2: The SMB2FlagsServerToRedir bit of the Header.Flags field in response must be set to true.");
                    ErrorCodeIf((header.Status & 0xC0000000) == 0xC0000000 && !(header.Status in IgnoredErrorCode), m, DiagnosisLevel.Warning, "SMB2: The Status of the message is " + NtStatusValuesToText(header.Status) + "(" + Utility.DecToHexFormat(header.Status) + "). Please refer to " + NtStatusValuesToText(header.Status) + " in Technical Document MS-ERREF.");
                    if (node.isRequestLost && header.Command > 0) // Exclude for SMB2PacketHeaderCommand.SMB2Negotiate message
                    {
                        ReportInsufficientData(m, DiagnosisLevel.Warning, "SMB2: Incomplete operation due to missing corresponding request.");
                    }
                    node.server.hasAnyMessageDecodeFailed = false;
                    // Dipatch the message
                    dispatch node issues m;
                }
                offset = nextOffset;
            default =>
                ThrowDecodingException("SMB2", "SMB2Header");
        }
    }
}

// -------------------------------------------
// Messages

// Base message for all the SMB2 messages except for CancelRequest
message ReqMessage
{
    SMB2PacketHeaderSync[true] Header where ValidationCheck((value.Flags & SMB2PacketHeaderFlags.SMB2FlagsServerToRedir) == 0, this, DiagnosisLevel.Error, "SMB2: The SMB2FlagsServerToRedir bit of the Header.Flags field in request must be set to false");
}

// Base message for all the reponse messages
message ResMessage 
{
    SMB2PacketHeader Header;
}

// Get MessageId of a ResMessage
ulong get MessageId(this ResMessage response)
{
    ulong messageId;
    if (response.Header is  SMB2.SMB2PacketHeaderSync[false])
    {
        SMB2.SMB2PacketHeaderSync[false] header = response.Header as SMB2.SMB2PacketHeaderSync[false];
        messageId = header.MessageId;
    }
    else
    {
        SMB2.SMB2PacketHeaderAsync[false] header = response.Header as SMB2.SMB2PacketHeaderAsync[false];
        messageId = header.MessageId;
    }
    return messageId;
}

// Get Credit of a ResMessage
ulong get Credit(this ResMessage response)
{
    ushort credit;
    if (response.Header is  SMB2.SMB2PacketHeaderSync[false])
    {
        SMB2.SMB2PacketHeaderSync[false] header = response.Header as SMB2.SMB2PacketHeaderSync[false];
        credit = header.Credit;
    }
    else
    {
        SMB2.SMB2PacketHeaderAsync[false] header = response.Header as SMB2.SMB2PacketHeaderAsync[false];
        credit = header.Credit;
    }
    return credit;
}

    
// Base message for all the request messages that have file name property
message ReqFileMessage:ReqMessage
{
}

// Base message for all the reponse messages that have file name property
message ResFileMessage:ResMessage
{
}

// Header only message for in case that the data is insufficient for the body part or the body part can't be decoded successfully
message SMB2HeaderOnly[bool isRequest]
{
    (SMB2PacketHeaderSync[isRequest] | SMB2PacketHeaderAsync[isRequest]) Header
        where ValidationCheck(false, this, DiagnosisLevel.Error, "SMB2: The body part cannot be decoded successfully.");
    
    override string ToString()
    {
        return (this#SMB2MessageName is nothing) ? "" : ((this#SMB2MessageName as string) + ", ") + "Header Only" + (Header.ToString() == "" ? "" : (", "+ Header.ToString()));
    }
}

contract Messages
{
    // Protocol Negotiation
    accepts NegotiateRequest:ReqMessage
    {
        SMB2NegotiateRequest Request;
        invariant Header != null && Request != null;
        override string ToString()
        {
            string summary = "NegotiateRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + ", Dialects: ";
            bool needComma = false;
            if (Request.Dialects.Count > 1)
            {
                summary += "[";
            }
            foreach (var e in Request.Dialects)
            {           
                if (needComma)
                {
                    summary += ", ";
                }
                else
                {
                    needComma = true;
                }
                summary += SMB2.DialectRevisionToText(e);
            }
            if (Request.Dialects.Count > 1)
            {
                summary += "]";
            }
            summary += ", Capabilities: " + EnumToString(Request.Capabilities, "SMB2.SMB2NegotiateRequestCapabilities") + ", ClientGuid: {" + (Request.ClientGuid as string) + "}";
            return summary;
        }
    }

    issues NegotiateResponse:ResMessage
    {
        SMB2NegotiateResponse Response;
        invariant Header != null && Response != null;
        override string ToString()
        {
            return "NegotiateResponse, " + Header.ToString() + ", DialectRevision: " + SMB2.DialectRevisionToText(Response.DialectRevision) + ", Capabilities: " + EnumToString(Response.Capabilities, "SMB2.SMB2NegotiateResponseCapabilities");
        }
    }
    
    // User Authentication
    accepts SessionSetupRequest:ReqMessage
    {
        SMB2SessionSetupRequest Request;
        invariant Header != null && Request != null;
        override string ToString()
        {
            return "SessionSetupRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + ", Flags: " + EnumToString(Request.Flags, "SMB2.SMB2SessionSetupRequestFlags") + ", PreviousSessionId: " + DecToHexFormat(Request.PreviousSessionId);
        }
    }

    issues SessionSetupResponse:ResMessage
    {
        SMB2SessionSetupResponse Response;
        invariant Header != null && Response != null;
        override string ToString()
        {
            string summary = "SessionSetupResponse, " + Header.ToString() + (((Response.SessionFlags & SMB2SessionSetupResponseSessionFlags.SMB2SessionFlagEncryptData) > 0) ? ", SessionFlags: ENCRYPT_DATA" : "") + ", SessionId: ";
            if (Header is SMB2PacketHeaderSync)
            {
                summary += DecToHexFormat((Header as SMB2PacketHeaderSync).SessionId);
            }
            else if (Header is SMB2PacketHeaderAsync)
            {
                summary += DecToHexFormat((Header as SMB2PacketHeaderAsync).SessionId);
            }
            return summary;
        }
    }

    accepts LogoffRequest:ReqMessage
    {
        SMB2LogoffRequest Request;
        invariant Header != null && Request != null;
        override string ToString()
        {    
            return "LogoffRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + ", SessionId: " + DecToHexFormat(GetSessionId(Header));
        }
    }

    issues LogoffResponse:ResMessage
    {
        SMB2LogoffResponse Response;
        invariant Header != null && Response != null;
        override string ToString()
        {
            return "LogoffResponse, " + Header.ToString();
        }
    }

    // Share Access
    accepts TreeConnectRequest:ReqMessage
    {
        SMB2TreeConnectRequest Request;
        invariant Header != null && Request != null;
        override string ToString()
        {
            return "TreeConnectRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + ", Path: " + Request.Buffer;
        }
    }

    issues TreeConnectResponse:ResMessage
    {
        SMB2TreeConnectResponse Response;
        invariant Header != null && Response != null;
        override string ToString()
        {
            return "TreeConnectResponse, " + Header.ToString() + ", ShareFlags: " + Response.ShareFlags.ToString() + ", TreeId: " + DecToHexFormat(GetTreeId(Header)) + ", Capabilities: " + EnumToString(Response.Capabilities, "SMB2.SMB2TreeConnectResponseCapabilities");
        }
    }

    accepts TreeDisconnectRequest:ReqMessage
    {
        SMB2TreeDisconnectRequest Request;
        invariant Header != null && Request != null;
        override string ToString()
        {    
            return "TreeDisconnectRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + ", TreeId: " + DecToHexFormat(GetTreeId(Header));
        }
    }

    issues TreeDisconnectResponse:ResMessage
    {
        SMB2TreeDisconnectResponse Response;
        invariant Header != null && Response != null;
        override string ToString()
        {
            return "TreeDisconnectResponse, " + Header.ToString() + ", TreeId: " + DecToHexFormat(GetTreeId(Header));
        }
    }

    // File Access
    accepts CreateRequest:ReqFileMessage
    {
        SMB2CreateRequest Request;
        invariant Header != null && Request != null;
        
        override string ToString()
        {    
            string summary = "CreateRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this) + ", RequestedOplockLevel: " + EnumToString(Request.RequestedOplockLevel, "SMB2.SMB2CreateRequestRequestedOplockLevel");
            if (Request.Buffer.CreateContextList != nothing)
            {
                var buffer = Request.Buffer.CreateContextList as array<SMB2CreateContextRequest>;
                int count = buffer.Count;
                string comma = "";
                summary += ", CreateContext: ";
                if (count > 1)
                {
                    summary += "[";
                }
                for(int i = 0; i < count; i++)
                {
                    summary += comma + buffer[i].Buffer.ToString();
                    comma = ", ";
                }
                if (count > 1)
                {
                    summary += "]";
                }
            }
            return summary;
        }
    }

    issues CreateResponse:ResFileMessage
    {
        SMB2CreateResponse Response;
        invariant Header != null && Response != null;
        override string ToString()
        {
            string summary = "CreateResponse, " + Header.ToString() + GetFileNameOrFID(this) + ", OplockLevel: " + EnumToString(Response.OplockLevel, "SMB2.SMB2CreateResponseOplockLevel");
            if (Response.Buffer != nothing)
            {
                var buffer = Response.Buffer as array<SMB2CreateContextResponse>;
                int count = buffer.Count;
                string comma = "";
                summary += ", CreateContext: ";
                if (count > 1)
                {
                    summary += "[";
                }
                for(int i = 0; i < count; i++)
                {
                    summary += comma + buffer[i].Buffer.ToString();
                    comma = ", ";
                }
                if (count > 1)
                {
                    summary += "]";
                }
            }
            return summary;
        }
    }

    accepts CloseRequest:ReqFileMessage
    {
        SMB2CloseRequest Request;
        invariant Header != null && Request != null;
        override string ToString()
        {
            return "CloseRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this);
        }
    }

    issues CloseResponse:ResFileMessage
    {
        SMB2CloseResponse Response;
        invariant Header != null && Response != null;
        override string ToString()
        {
            return "CloseResponse, " + Header.ToString() + GetFileNameOrFID(this);
        }
    }

   accepts ReadRequest:ReqFileMessage
    {
        SMB2ReadRequest Request;
        invariant Header != null && Request != null;
        
        override string ToString()
        {    
            string summary = "ReadRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this);
            summary += ", TreeId: " + DecToHexFormat(GetTreeId(Header)) + ", Length: " + (Request.Length as string) + ", Offset: " + (Request.Offset as string);
            if ((Request.Channel & SMB2ReadRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    }

    issues ReadResponse:ResFileMessage
    {
        SMB2ReadResponse Response;
        invariant Header != null && Response != null;

        override string ToString()
        {
            string summary = "ReadResponse";
            if (this#IsReassembled != nothing)
            {
                summary += ", Reassembled";
            }
            summary += ", "+ Header.ToString() + GetFileNameOrFID(this) + ", TreeId: " + DecToHexFormat(GetTreeId(Header)) + ", DataLength: " + (Response.DataLength as string);
            return summary;
        }
    }
    
    accepts WriteRequest:ReqFileMessage
    {
        SMB2WriteRequest Request;
        invariant Header != null && Request != null;
        
        override string ToString()
        {    
            string summary = "WriteRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this);
            summary += ", Length: " + (Request.Length as string) + ", Offset: " + (Request.Offset as string);
            if ((Request.Channel & SMB2WriteRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    }

    issues WriteResponse:ResFileMessage
    {
        SMB2WriteResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "WriteResponse, " + Header.ToString() + GetFileNameOrFID(this) + ", Count: " + (Response.Count as string);
        }
    }

    accepts LockRequest:ReqFileMessage
    {
        SMB2LockRequest Request;
        invariant Header != null && Request != null;
        
        override string ToString()
        {
            return "LockRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this);
        }
    }

    issues LockResponse:ResFileMessage
    {
        SMB2LockResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "LockResponse, " + Header.ToString() + GetFileNameOrFID(this);
        }
    }

    accepts IoctlRequest:ReqFileMessage
    {
        SMB2IoctlRequest Request;
        invariant Header != null && Request != null;
        
        override string ToString()
        {
            return "IoctlRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this) + ", CtlCode: " + SMB2.CtlCodeToText(Request.CtlCode);
        }
    }

    issues IoctlResponse[uint? HashRetrievalType, uint? HashVersion]:ResFileMessage
    {
        SMB2IoctlResponse[HashRetrievalType, HashVersion] Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            string summary = "IoctlResponse";
            if (this#IsReassembled != nothing)
            {
                summary += ", Reassembled";
            }
            summary += ", "+ Header.ToString() + GetFileNameOrFID(this) + ", CtlCode: " + SMB2.CtlCodeToText(Response.CtlCode);
            return summary;
        }
    }

    accepts QueryInfoRequest:ReqFileMessage
    {
        SMB2QueryInfoRequest Request;
        invariant Header != null && Request != null;
        
        override string ToString()
        {
            string summary = "QueryInfoRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this);
            summary += ", InfoType: " + InfoTypeToText(Request.InfoType) + ", FileInfoClass: " + FileInfoClassToText(Request.InfoType, Request.FileInfoClass);
            return summary;
        }
    }

    issues QueryInfoResponse[optional byte QueryInfoType, optional byte QueryInfoClass]:ResFileMessage
    {
        SMB2QueryInfoResponse[QueryInfoType, QueryInfoClass] Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "QueryInfoResponse, " + Header.ToString() + GetFileNameOrFID(this);
         }
    }

    accepts SetInfoRequest:ReqFileMessage
    {
        SMB2SetInfoRequest Request;
        invariant Header != null && Request != null;
        
        override string ToString()
        {
            string summary = "SetInfoRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this);
            summary += ", InfoType: " + InfoTypeToText(Request.InfoType) + ", FileInfoClass: " + FileInfoClassToText(Request.InfoType, Request.FileInfoClass);
            return summary;            
        }
    }

    issues SetInfoResponse:ResFileMessage
    {
        SMB2SetInfoResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "SetInfoResponse, " + Header.ToString() + GetFileNameOrFID(this);
         }
    }

    accepts FlushRequest:ReqFileMessage
    {
        SMB2FlushRequest Request; 
        invariant Header != null && Request != null;
        
        override string ToString()
        {
            return "FlushRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this);
        }
    }

    issues FlushResponse:ResFileMessage
    {
        SMB2FlushResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "FlushResponse, " + Header.ToString() + GetFileNameOrFID(this);
        }
    }

    accepts CancelRequest
    {
        SMB2PacketHeaderReq Header;
        SMB2CancelRequest Request;
        invariant Header != null && Request != null;
        
        override string ToString()
        {
            return "CancelRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString()));
        }
    }

    // Directory Access
    accepts QueryDirectoryRequest:ReqFileMessage
    {
        SMB2QueryDirectoryRequest Request;
        invariant Header != null && Request!= null;
        
        override string ToString()
        {
            string summary = "QueryDirectoryRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString()));
            summary += ", Flags: " + EnumToString(Request.Flags, "SMB2.SMB2QueryDirectoryRequestFlags") + GetFileNameOrFID(this) + ", SearchPattern: " + Request.Buffer;
            summary += ", FileInformationClass: " + EnumToString(Request.FileInformationClass, "SMB2.SMB2QueryDirectoryRequestFileInformationClass");
            return summary;
        }
    }

    issues QueryDirectoryResponse[optional byte QueryInfoClass]:ResFileMessage
    {
        SMB2QueryDirectoryResponse[QueryInfoClass] Response;
        invariant Header != null && Response!= null;
        
        override string ToString()
        {
            return "QueryDirectoryResponse, " + Header.ToString() + GetFileNameOrFID(this);
        }
    }

    accepts ChangeNotifyRequest:ReqFileMessage
    {
        SMB2ChangeNotifyRequest Request;
        invariant Header != null && Request!= null;
        
        override string ToString()
        {
            string summary = "ChangeNotifyRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + GetFileNameOrFID(this);
            summary += ", CompletionFilter: " + EnumToString(Request.CompletionFilter, "SMB2.SMB2ChangeNotifyRequestCompletionFilter");
            return summary;
        }
    }

    issues ChangeNotifyResponse:ResFileMessage
    {
        SMB2ChangeNotifyResponse Response;
        invariant Header != null && Response!= null;
        
        override string ToString()
        {
            return "ChangeNotifyResponse, " + Header.ToString() + GetFileNameOrFID(this);
        }
    }

    // Cache Coherency
    issues OplockBreakNotification:ResFileMessage
    {
        SMB2OplockBreakNotification Notification;
        invariant Header != null && Notification != null;
        
        override string ToString()
        {
            return "OplockBreakNotification, " + Header.ToString() + ", FileName: " + this.FileName + ", OplockLevel: " + EnumToString(Notification.OplockLevel, "SMB2.SMB2OplockBreakNotificationOplockLevel");
        }
    }

    accepts OplockBreakAcknowledgment:ReqFileMessage
    {
        SMB2OplockBreakAcknowledgment Acknowledgment where value.StructureSize == 24;
        invariant Header != null && Acknowledgment != null;
        
        override string ToString()
        {
            return "OplockBreakAcknowledgment" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + ", FileName: " + this.FileName + ", OplockLevel: " + EnumToString(Acknowledgment.OplockLevel, "SMB2.SMB2OplockBreakAcknowledgmentOplockLevel");            
        }
    }
    
    issues OplockBreakResponse:ResFileMessage
    {
        SMB2OplockBreakResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {    
            return "OplockBreakResponse, " + Header.ToString() + ", FileName: " + this.FileName + ", OplockLevel: " + EnumToString(Response.OplockLevel, "SMB2.SMB2OplockBreakResponseOplockLevel");            
        }
    }
    
    issues LeaseBreakNotification:ResMessage
    {
        SMB2LeaseBreakNotification Notification;
        invariant Header != null && Notification != null;
        
        override string ToString()
        {
            string summary = "LeaseBreakNotification, " + Header.ToString() + ", CurrentLeaseState: " + SMB2LeaseBreakNotificationCurrentLeaseStateToText(Notification.CurrentLeaseState);
            summary += ", NewLeaseState: " + SMB2LeaseBreakNotificationNewLeaseStateToText(Notification.NewLeaseState);
            return summary;
        }
    }

    accepts LeaseBreakAcknowledgment:ReqMessage
    {
        SMB2LeaseBreakAcknowledgment Acknowledgment where value.StructureSize == 36;
        invariant Header != null && Acknowledgment != null;
        
        override string ToString()
        {
            return "LeaseBreakAcknowledgment" + (Header.ToString() == "" ? "" : (", "+ Header.ToString())) + ", LeaseState: " + SMB2LeaseBreakAcknowledgmentLeaseStateToText(Acknowledgment.LeaseState) + ", LeaseKey: {" + (Acknowledgment.LeaseKey as string) + "}";           
        }
    }
    
    issues LeaseBreakResponse:ResMessage
    {
        SMB2LeaseBreakResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "LeaseBreakResponse, " + Header.ToString() + ", LeaseState: " + SMB2LeaseBreakResponseLeaseStateToText(Response.LeaseState);           

        }
    }
    
    // Simple Messaging
    accepts EchoRequest:ReqMessage
    {
        SMB2EchoRequest Request;
        invariant Header != null && Request != null;
        
        override string ToString()
        {
            return "EchoRequest" + (Header.ToString() == "" ? "" : (", "+ Header.ToString()));
        }
    }

    issues EchoResponse:ResMessage
    {
        SMB2EchoResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "EchoResponse, " + Header.ToString();
        }
    }
    
    // ERROR Response Packet
    issues ErrorResponse[uint Status]:ResFileMessage
    {
        SMB2ErrorResponse[Status] Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "ErrorResponse, " + Header.ToString();
        }
    }
}

message TransformMessage[ushort EncryptAlgorithm]
{
    SMB2TransformHeader[EncryptAlgorithm] Header;
    binary Data;
    
    override string ToString()
    {
        return "TransformMessage, Encrypted";
    }
}

contract VirtualOperations
{
    // Future Reference: enable virtual operation accept multi-message types, normal response and error response.
    virtual operation Negotiate
    {
        in GUID ClientGuid = request.ClientGuid;
        out SMB2NegotiateResponseDialectRevision DialectRevision = response.DialectRevision;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Negotiate, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", ClientGuid: {" + (ClientGuid as string) + "}, DialectRevision: " + SMB2.DialectRevisionToText(DialectRevision);
        }
    }
    =
    accepts Messages.NegotiateRequest{Header is var header, Request is var request}
    issues Messages.NegotiateResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2}), Response is var response};

    virtual operation NegotiateFailure
    {
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "NegotiateFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status));
        }
    }
    =
    accepts Messages.NegotiateRequest{Header is var header}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation SessionSetup
    {
        in SMB2SessionSetupRequestFlags Flags = request.Flags;
        out SMB2SessionSetupResponseSessionFlags SessionFlags = response.SessionFlags;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);

        override string ToString()
        {
            return "SessionSetup, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", Flags: " + EnumToString(Flags, "SMB2.SMB2SessionSetupRequestFlags") + (((SessionFlags & SMB2SessionSetupResponseSessionFlags.SMB2SessionFlagEncryptData) > 0) ? ", SessionFlags: ENCRYPT_DATA" : "");
        }
    }
    =
    accepts Messages.SessionSetupRequest{Header is var header, Request is var request}
    issues Messages.SessionSetupResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2}), Response is var response};

    virtual operation SessionSetupFailure
    {
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "SessionSetupFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status));
        }
    }
    exception uint = AddTwoOptionalNTStatus(status1, status2)
    =
    accepts Messages.SessionSetupRequest{Header is var header}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation Logoff
    {
        out UINT64 SessionId = AddTwoOptionalUint64(SessionId1, SessionId2);
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Logoff, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", SessionId: " + DecToHexFormat(SessionId);
        }
    }
    =
    accepts Messages.LogoffRequest{Header is var header}
    issues Messages.LogoffResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1, SessionId is var SessionId1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2, SessionId is var SessionId2})};

    virtual operation LogoffFailure
    {
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "LogoffFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status));
        }
    }
    =
    accepts Messages.LogoffRequest{Header is var header}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation TreeConnect
    {
        in string Path = request.Buffer;
        out uint TreeId = treeId;
        out SMB2TreeConnectResponseCapabilities Capabilities = response.Capabilities;
        out optional NTSTATUS Status = status;
        
        override string ToString()
        {
            string summary = "TreeConnect";
            if (Status != nothing)
            {
                summary += ", Status: " + ((Status as NTSTATUS) == 0 ? "Success" : NtStatusValuesToText(Status as NTSTATUS));
            }
            summary += ", Path: " + (Path as string) + ", TreeID: " + DecToHexFormat(TreeId) + ", Capabilities: " + EnumToString(Capabilities, "SMB2.SMB2TreeConnectResponseCapabilities");
           return summary;
        }
    }
    =
    accepts Messages.TreeConnectRequest{Header is var header, Request is var request}
    issues Messages.TreeConnectResponse{Header is SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status, TreeId is var treeId}, Response is var response};

    virtual operation TreeConnectFailure
    {
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "TreeConnectFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status));
        }
    }
    =
    accepts Messages.TreeConnectRequest{Header is var header}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation TreeDisconnect
    {
        in ULONG TreeId = header.TreeId;
        out optional NTSTATUS Status = status;
        
        override string ToString()
        {
            string summary = "TreeDisconnect";
            if (Status != nothing)
            {
                summary += ", Status: " + ((Status as NTSTATUS) == 0 ? "Success" : NtStatusValuesToText(Status as NTSTATUS));
            }
            summary += ", TreeId: " + DecToHexFormat(TreeId);
            return summary;
        }
    }
    =
    accepts Messages.TreeDisconnectRequest{Header is var header}
    issues Messages.TreeDisconnectResponse{Header is SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status}};

    virtual operation TreeDisconnectFailure
    {
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "TreeDisconnectFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status));
        }
    }
    =
    accepts Messages.TreeDisconnectRequest{Header is var header}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation Create
    {
        in string Name = buffer.Name == "" ? "*NULL*" : buffer.Name;
        out SMB2Fileid FileId = response.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Create, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileName: " + Name;
        }
    }
    =
    accepts Messages.CreateRequest{Header is var header, Request is SMB2CreateRequest{Buffer is var buffer}}
    issues Messages.CreateResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2}), Response is var response};

    virtual operation CreateFailure
    {
        in string Name = buffer.Name == "" ? "*NULL*" : buffer.Name;
        in UINT64 MessageId = header.MessageId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "CreateFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status));
        }
    }
    exception uint = AddTwoOptionalNTStatus(status1, status2)
    =
    accepts Messages.CreateRequest{Header is var header, Request is SMB2CreateRequest{Buffer is var buffer}}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation CreateWithInterimResponse
    {
        out string Name = name;
        out SMB2Fileid FileId = response.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Create, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileName: " + Name;
        }
    }
    =
    issues VirtualOperations.CreateFailure{Name is var name, MessageId is var messageId, Status == 0x00000103}
    issues Messages.CreateResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2}), Response is var response};

    virtual operation CreateFailureWithInterimResponse
    {
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "CreateFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status));
        }
    }
    =
    issues VirtualOperations.CreateFailure{Name is var name, MessageId is var messageId, Status == 0x00000103}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};

    virtual operation Close
    {
        in SMB2Fileid FileId = request.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Close, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    accepts Messages.CloseRequest{Header is var header, Request is var request}
    issues Messages.CloseResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation CloseFailure
    {
        in SMB2Fileid FileId = request.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "CloseFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    accepts Messages.CloseRequest{Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation Read
    {
        in SMB2Fileid FileId = request.FileId;
        in ULONG Length = request.Length;
        in SMB2ReadRequestChannel Channel = request.Channel;
        in UINT64 Offset = request.Offset;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            string summary = "Read, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + GetFileNameOrFID(this) +
                ", Read " + (Length as string) + " bytes from offset " + (Offset as string);
            if ((Channel & SMB2ReadRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    }
    =
    accepts Messages.ReadRequest{Header is var header, Request is var request}
    issues Messages.ReadResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    virtual operation ReadFailure
    {
        in SMB2Fileid FileId = request.FileId;
        in ULONG Length = request.Length;
        in SMB2ReadRequestChannel Channel = request.Channel;
        in UINT64 Offset = request.Offset;
        in UINT64 MessageId = header.MessageId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "ReadFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + GetFileNameOrFID(this);
        }
    }
    exception uint = AddTwoOptionalNTStatus(status1, status2)
    =
    accepts Messages.ReadRequest{Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation ReadWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out ULONG Length = length;
        out SMB2ReadRequestChannel Channel = channel;
        out UINT64 Offset = offset;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            string summary = "Read, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", " + GetFileNameOrFID(this) +
                ", Read " + (Length as string) + " bytes from offset " + (Offset as string);
            if ((Channel & SMB2ReadRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    }
    =
    issues VirtualOperations.ReadFailure{FileId is var fileId, Length is var length, Channel is var channel, Offset is var offset, MessageId is var messageId, Status == 0x00000103}
    issues Messages.ReadResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};

    virtual operation ReadFailureWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "ReadFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", " + GetFileNameOrFID(this);
        }
    }
    =
    issues VirtualOperations.ReadFailure{FileId is var fileId, MessageId is var messageId, Status == 0x00000103}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};

    virtual operation Write
    {
        in SMB2Fileid FileId = request.FileId;
        in SMB2WriteRequestChannel Channel = request.Channel;
        in ULONG Length = request.Length;
        in UINT64 Offset = request.Offset;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            string summary = "Write, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", Write " + (Length as string) + " bytes from offset " + (Offset as string);
            if ((Channel & SMB2WriteRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    }
    =
    accepts Messages.WriteRequest{Header is var header, Request is var request}
    issues Messages.WriteResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation WriteFailure
    {
        in SMB2Fileid FileId = request.FileId;
        in SMB2WriteRequestChannel Channel = request.Channel;
        in ULONG Length = request.Length;
        in UINT64 Offset = request.Offset;
        in UINT64 MessageId = header.MessageId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "WriteFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    exception uint = AddTwoOptionalNTStatus(status1, status2)
    =
    accepts Messages.WriteRequest{Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation WriteWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out SMB2WriteRequestChannel Channel = channel;
        out ULONG Length = length;
        out UINT64 Offset = offset;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            string summary = "Write, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", Write " + (Length as string) + " bytes from offset " + (Offset as string);
            if ((Channel & SMB2WriteRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    }
    =
    issues VirtualOperations.WriteFailure{FileId is var fileId, Channel is var channel, Length is var length, Offset is var offset, MessageId is var messageId, Status == 0x00000103}
    issues Messages.WriteResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};

    virtual operation WriteFailureWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "WriteFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    issues VirtualOperations.WriteFailure{FileId is var fileId, MessageId is var messageId, Status == 0x00000103}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};

    virtual operation Lock
    {
        in SMB2Fileid FileId = request.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Lock, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    accepts Messages.LockRequest{Header is var header, Request is var request}
    issues Messages.LockResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation LockFailure
    {
        in SMB2Fileid FileId = request.FileId;
        in UINT64 MessageId = header.MessageId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "LockFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    accepts Messages.LockRequest{Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation LockWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Lock, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    issues VirtualOperations.LockFailure{FileId is var fileId, MessageId is var messageId, Status == 0x00000103}
    issues Messages.LockResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};
    
    virtual operation LockFailureWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "LockFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    issues VirtualOperations.LockFailure{FileId is var fileId, MessageId is var messageId, Status == 0x00000103}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};

    virtual operation Ioctl
    {
        in SMB2Fileid FileId = request.FileId;
        in ULONG CtlCode = request.CtlCode;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Ioctl, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", CtlCode: " + SMB2.CtlCodeToText(CtlCode);
        }
    }
    =
    accepts Messages.IoctlRequest{Header is var header, Request is var request}
    issues Messages.IoctlResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation IoctlFailure
    {
        in SMB2Fileid FileId = request.FileId;
        in ULONG CtlCode = request.CtlCode;
        in UINT64 MessageId = header.MessageId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "IoctlFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", CtlCode: " + SMB2.CtlCodeToText(CtlCode);
        }
    }
    exception uint = AddTwoOptionalNTStatus(status1, status2)
    =
    accepts Messages.IoctlRequest{Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation IoctlWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out ULONG CtlCode = ctlCode;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Ioctl, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", CtlCode: " + SMB2.CtlCodeToText(CtlCode);
        }
    }
    =
    issues VirtualOperations.IoctlFailure{FileId is var fileId, CtlCode is var ctlCode, MessageId is var messageId, Status == 0x00000103}
    issues Messages.IoctlResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2}), Response is var response};
    
    virtual operation IoctlFailureWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out ULONG CtlCode = ctlCode;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "IoctlFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", CtlCode: " + SMB2.CtlCodeToText(CtlCode);
        }
    }
    =
    issues VirtualOperations.IoctlFailure{FileId is var fileId, CtlCode is var ctlCode, MessageId is var messageId, Status == 0x00000103}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};

    virtual operation QueryInfo
    {
        in SMB2Fileid FileId = request.FileId;
        in BYTE InfoType = request.InfoType;
        in BYTE FileInfoClass = request.FileInfoClass;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "QueryInfo, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", FileInfoClass: " + FileInfoClassToText(InfoType, FileInfoClass);
        }
    }
    =
    accepts Messages.QueryInfoRequest{Header is var header, Request is var request}
    issues Messages.QueryInfoResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
        
    virtual operation QueryInfoFailure
    {
        in SMB2Fileid FileId = request.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "QueryInfoFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    exception uint = AddTwoOptionalNTStatus(status1, status2)
    =
    accepts Messages.QueryInfoRequest{Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation SetInfo
    {
        in SMB2Fileid FileId = request.FileId;
        in BYTE InfoType = request.InfoType;
        in BYTE FileInfoClass = request.FileInfoClass;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "SetInfo, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) +
                ", FileInfoClass: " + FileInfoClassToText(InfoType, FileInfoClass);
        }
    }
    =
    accepts Messages.SetInfoRequest{Header is var header, Request is var request}
    issues Messages.SetInfoResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation SetInfoFailure
    {
        in SMB2Fileid FileId = request.FileId;
        in BYTE InfoType = request.InfoType;
        in BYTE FileInfoClass = request.FileInfoClass;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "SetInfoFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    accepts Messages.SetInfoRequest{Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation Flush
    {
        in SMB2Fileid FileId = request.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Flush, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    accepts Messages.FlushRequest{Header is var header, Request is var request}
    issues Messages.FlushResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation FlushFailure
    {
        in SMB2Fileid FileId = request.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "FlushFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    accepts Messages.FlushRequest{Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation CancelSuccess
    {
        out NTSTATUS Status = 0xC0000120; // 0xC0000120 is NtStatus."STATUS_CANCELLED"
        out UINT64 MessageId = AddTwoOptionalUint64(messageId1, messageId2);
        
        override string ToString()
        {
            return "CancelSuccess, Status: " + NtStatusMap[Status] + ", MessageId: " + DecToHexFormat(MessageId);
        }
    }
    =
    accepts Messages.CancelRequest{Header is var header, Header is (SMB2PacketHeaderSync{MessageId is var messageId1} | SMB2PacketHeaderAsync{MessageId is var messageId2})}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == GetMessageId(header), Status == 0xC0000120} | // 0xC0000120 is NtStatus."STATUS_CANCELLED"
                                                SMB2PacketHeaderAsync{MessageId == GetMessageId(header), Status == 0xC0000120} |
                                                SMB2PacketHeaderAsync{AsyncId == GetAsyncId(header), Status == 0xC0000120})};
    
    virtual operation QueryDirectory
    {
        in SMB2Fileid FileId = request.FileId;
        in FileInformationClasses FileInformationClass = request.FileInformationClass;
        in string Buffer = request.Buffer;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "QueryDirectory, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) +
                ", SearchPattern: " + (Buffer == "" ? "NULL":Buffer) + 
                ", FileInformationClass: " + FileInformationClassesToText(FileInformationClass);
        }
    }
    =
    accepts Messages.QueryDirectoryRequest{Header is var header, Request is var request}
    issues Messages.QueryDirectoryResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation QueryDirectoryFailure
    {
        in SMB2Fileid FileId = request.FileId;
        in FileInformationClasses FileInformationClass = request.FileInformationClass;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "QueryDirectoryFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", FileInformationClass: " + FileInformationClassesToText(FileInformationClass);
        }
    }
    exception uint = AddTwoOptionalNTStatus(status1, status2)
    =
    accepts Messages.QueryDirectoryRequest{Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation ChangeNotify
    {
        in SMB2Fileid FileId = request.FileId;
        in SMB2ChangeNotifyRequestCompletionFilter CompletionFilter = request.CompletionFilter;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "ChangeNotify, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", " + ", FileId: " + DecToHexFormat(FileId.Persistent) +
                ", CompletionFilter: " + EnumToString(CompletionFilter, "SMB2.SMB2ChangeNotifyRequestCompletionFilter");
        }
    }
    =
    accepts Messages.ChangeNotifyRequest{Header is var header, Request is var request}
    issues Messages.ChangeNotifyResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation ChangeNotifyFailure
    {
        in SMB2Fileid FileId = request.FileId;
        in SMB2ChangeNotifyRequestCompletionFilter CompletionFilter = request.CompletionFilter;
        in UINT64 MessageId = header.MessageId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "ChangeNotifyFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) +
                ", CompletionFilter: " + EnumToString(CompletionFilter, "SMB2.SMB2ChangeNotifyRequestCompletionFilter");
        }
    }
    exception uint = AddTwoOptionalNTStatus(status1, status2)
    =
    accepts Messages.ChangeNotifyRequest {Header is var header, Request is var request}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation ChangeNotifyWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out SMB2ChangeNotifyRequestCompletionFilter CompletionFilter = completionFilter;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "ChangeNotify, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", " + ", FileId: " + DecToHexFormat(FileId.Persistent) +
                ", CompletionFilter: " + EnumToString(CompletionFilter, "SMB2.SMB2ChangeNotifyRequestCompletionFilter");
        }
    }
    =
    issues VirtualOperations.ChangeNotifyFailure{CompletionFilter is var completionFilter, FileId is var fileId, MessageId is var messageId, Status == 0x00000103}
    issues Messages.ChangeNotifyResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};

    virtual operation ChangeNotifyFailureWithInterimResponse
    {
        out SMB2Fileid FileId = fileId;
        out SMB2ChangeNotifyRequestCompletionFilter CompletionFilter = completionFilter;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "ChangeNotifyFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) +
                ", CompletionFilter: " + EnumToString(CompletionFilter, "SMB2.SMB2ChangeNotifyRequestCompletionFilter");
        }
    }
    =
    issues VirtualOperations.ChangeNotifyFailure{CompletionFilter is var completionFilter, FileId is var fileId, MessageId is var messageId, Status == 0x00000103}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == messageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == messageId, Status is var status2})};
    
    // Future Reference: enable virtual operation accept multi-message types, OplockBreakResponse and OplockBreakNotificaiton
    virtual operation OplockBreak
    {
        in SMB2OplockBreakAcknowledgmentOplockLevel OplockLevel = ack.OplockLevel;
        in SMB2Fileid FileId = ack.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);

        override string ToString()
        {
            return "OplockBreak, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", OplockLevel: " + EnumToString(OplockLevel, "SMB2.SMB2OplockBreakAcknowledgmentOplockLevel");
        }
    }
    =
    accepts Messages.OplockBreakAcknowledgment{Header is var header, Acknowledgment is var ack}
    issues Messages.OplockBreakResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
    
    virtual operation OplockBreakFailure
    {
        in SMB2Fileid FileId = ack.FileId;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);


        override string ToString()
        {

            return "OplockBreakFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    }
    =
    accepts Messages.OplockBreakAcknowledgment{Header is var header, Acknowledgment is var ack}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation LeaseBreak
    {
        in GUID LeaseKey = ack.LeaseKey;
        out SMB2LeaseBreakResponseLeaseState LeaseState = leaseState;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);

        override string ToString()
        {
            return "LeaseBreak, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status)) +
                ", LeaseState: " + SMB2LeaseStateToText(LeaseState) +
                ", LeaseKey: {" + LeaseKey.ToString() + "}";
        }
    }
    =
    accepts Messages.LeaseBreakAcknowledgment{Header is var header, Acknowledgment is var ack}
    issues Messages.LeaseBreakResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2}),
        Response is SMB2LeaseBreakResponse{LeaseState is var leaseState}};

    virtual operation LeaseBreakFailure
    {
        in GUID LeaseKey = ack.LeaseKey;
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);

        override string ToString()
        {
            return "LeaseBreakFailure, Status: " + NtStatusValuesToText(Status) + 
                ", LeaseKey: {" + LeaseKey.ToString() + "}";
        }
    }
    =
    accepts Messages.LeaseBreakAcknowledgment{Header is var header, Acknowledgment is var ack}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation Echo
    {
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "Echo, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status));
        }
    }
    =
    accepts Messages.EchoRequest{Header is var header}
    issues Messages.EchoResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};

    virtual operation EchoFailure
    {
        out NTSTATUS Status = AddTwoOptionalNTStatus(status1, status2);
        
        override string ToString()
        {
            return "EchoFailure, Status: " + (Status == 0 ? "Success" : NtStatusValuesToText(Status));
        }
    }
    =
    accepts Messages.EchoRequest{Header is var header}
    issues Messages.ErrorResponse{Header is (SMB2PacketHeaderSync{MessageId == header.MessageId, Status is var status1} | SMB2PacketHeaderAsync{MessageId == header.MessageId, Status is var status2})};
}

// -------------------------------------------
// Data types

// 2.2.1   SMB2 Packet Header
pattern SMB2PacketHeader = SMB2PacketHeaderSync[false] | SMB2PacketHeaderAsync[false];
pattern SMB2PacketHeaderReq = SMB2PacketHeaderSync[true] | SMB2PacketHeaderAsync[true];

// 2.2.1.1   SMB2 Packet Header - ASYNC
type SMB2PacketHeaderAsync[bool IsRequest]
{
    ULONG ProtocolId where ValidationCheckValue(value == 0xFE534D42, null, true, ReferenceType.Type, "SMB2", "ProtocolId", "SMB2PacketHeaderAsync", "(in network order) 0xFE, 'S', 'M', and 'B'", value)
        with BinaryEncoding{Endian = Endian.Big},
            Documentation
               {Description = "The protocol identifier. The value MUST be(in network order) 0xFE, 'S', 'M', and 'B'."};

    USHORT StructureSize where ValidationCheckValue(value == 64, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2PacketHeaderAsync", 64, value)
          with Documentation
           {Description = "MUST be set to 64, which is the size, in bytes, of the SMB2 header structure."};

    USHORT CreditCharge
          with Documentation
           {Description = "In the SMB 2.002 dialect, this field MUST NOT be used and MUST be reserved. The sender MUST set this to 0, and the receiver MUST ignore it. In the SMB 2.1 dialect, this field indicates the number of credits that this request consumes."};

    optional [|IsRequest && SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] USHORT ChannelSequence
          with Documentation
           {Description = "This field is an indication to the server about the client's Channel change."};
    optional [|IsRequest && SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] USHORT Reserved
          with Documentation
           {Description = "This field SHOULD be set to zero and the server MUST ignore it on receipt."};

    optional [|!IsRequest || SMB2DialectRevision != SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] NTSTATUS Status
          with Documentation
           {Description = "The status code for a response. For a request, the client MUST set this field to 0 and the server MUST ignore it on receipt. For a response, this field can be set to any value. For a list of valid status codes, see [MS-ERREF] section ."};

    SMB2PacketHeaderCommand Command
          where ValidationCheck(InRange<SMB2PacketHeaderCommand>(value), null, DiagnosisLevel.Error,
                () => Format(COMMON_STR_CHECK_VALUE_IN_RANGE, ["SMB2", "Command", COMMON_STR_TYPE, "SMB2PacketHeaderAsync", COMMON_STR_MUST, "0x0000", "0x0012", Utility.DecToHexFormat(value)]))
          with Documentation
           {Description = "The command code of this packet. This field MUST contain one of the following valid commands:"};

    USHORT Credit //$"CreditRequest/CreditResponse"
          with Documentation
           {Description = "On a request, this field indicates the number of credits the client is requesting. On a response, it indicates the number of credits granted to the client."};

    SMB2PacketHeaderFlags Flags
          with Documentation
           {Description = "A flags field, which indicates how to process the operation. This field MUST be constructed using the following values:"};

    ULONG NextCommand
          with Documentation
           {Description = "For a compounded request, this field MUST be set to the offset, in bytes, from the beginning of this SMB2 header to the start of the subsequent 8-byte aligned SMB2 header. If this is not a compounded request, or this is the last header in a compounded request, this value MUST be 0."};

    UINT64 MessageId
          with Documentation
           {Description = "A value that identifies a message request and response uniquely across all messages that are sent on the same SMB 2 Protocol transport connection."};

    UINT64 AsyncId
          with Documentation
           {Description = "A unique identification number that is created by the server to handle operations Asynchronously, as specified in section ."};
    
    UINT64 SessionId
          with Documentation
           {Description = "Uniquely identifies the established session for the command. This MUST be 0 for requests that do not have an associated user context. This MUST be 0 for the first SMB2 SESSION_SETUP Request for a specified security principal. The following SMB 2 Protocol commands do not require the SessionId to be set to a nonzero value received from a previous SMB2 SESSION_SETUP Response. The client MUST set the SessionId to 0, and the server SHOULD ignore this value for the following commands:"};

    binary Signature where ValidationCheck(value == $[00000000000000000000000000000000] || (Flags & SMB2PacketHeaderFlags.SMB2FlagsSigned) > 0, null, DiagnosisLevel.Error, "SMB2: The Signature field in type SMB2PacketHeaderAsync must be zero if the message is not signed, not " + value.ToString() + ".")
        with BinaryEncoding{Length = 16},
            Documentation
               {Description = "The 16-byte signature of the message, if SMB2_FLAGS_SIGNED is set in the Flags field of the SMB2 header. If the message is not signed, this field MUST be 0."};
    override string ToString()
    {
        string summary = "";
        if (!IsRequest)
        {
            summary = "Status: " + StatusToText(this) + ", ";//  Status
        }
        summary += "MessageId: " + (MessageId as string) + ", AsyncId: " + (AsyncId as string);
        return summary;
    }
}
with Documentation
       {Description = "If the SMB2_FLAGS_Async_COMMAND bit is set in Flags, the header takes the following form."};

pattern SMB2PacketHeaderCommand = enum USHORT
{
    SMB2Negotiate      = 0x0000,
    SMB2SessionSetup   = 0x0001,
    SMB2Logoff         = 0x0002,
    SMB2TreeConnect    = 0x0003,
    SMB2TreeDisconnect = 0x0004,
    SMB2Create         = 0x0005,
    SMB2Close          = 0x0006,
    SMB2Flush          = 0x0007,
    SMB2Read           = 0x0008,
    SMB2Write          = 0x0009,
    SMB2Lock           = 0x000A,
    SMB2Ioctl          = 0x000B,
    SMB2Cancel         = 0x000C,
    SMB2Echo           = 0x000D,
    SMB2QueryDirectory = 0x000E,
    SMB2ChangeNotify   = 0x000F,
    SMB2QueryInfo      = 0x0010,
    SMB2SetInfo        = 0x0011,
    SMB2OplockBreak    = 0x0012,
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2PacketHeaderFlags = flags ULONG
{
    SMB2FlagsSigned = 0x00000008
        with Documentation
            {Description = "When set, indicates that this packet has been signed. The use of this flag is as specified in 3.1.5.1."},
    SMB2FlagsRelatedOperations = 0x00000004
        with Documentation
            {Description = "When set in an SMB2 request, indicates that this request is a related operation in a compounded request chain. The use of this flag in an SMB2 request is as specified in .When set in an SMB2 compound response, indicates that the request corresponding to this response was part of a related operation in a compounded request chain. The use of this flag in an SMB2 response is as specified in ."},       
    SMB2FlagsAsyncCommand = 0x00000002
        with Documentation
            {Description = "When set, indicates that this is an Async SMB2 header. Always set for headers of the form described in this section."},
    SMB2FlagsServerToRedir = 0x00000001
        with Documentation
            {Description = "When set, indicates the message is a response rather than a request. This MUST be set on responses sent from the server to the client, and MUST NOT be set on requests sent from the client to the server."},
    SMB2FlagsDFSOperations = 0x10000000
        with Documentation
            {Description = "When set, indicates that this command is a Distributed File System(DFS) operation. The use of this flag is as specified in ."},
    SMB2FlagsReplayOperation = 0x20000000
        with Documentation
            {Description = "This flag is only valid for the SMB 3.x dialect family. When set, it indicates that this command is a replay operation. The client MUST ignore this bit on receipt."}
};


// 2.2.1.2   SMB2 Packet Header - SYNC
type SMB2PacketHeaderSync[bool IsRequest]
{
    ULONG ProtocolId where ValidationCheckValue(value == 0xFE534D42, null, true, ReferenceType.Type, "SMB2", "ProtocolId", "SMB2PacketHeaderSync", "(in network order) 0xFE, 'S', 'M', and 'B'", value)
        with BinaryEncoding {Endian = Endian.Big},
       Documentation
          {Description = "The protocol identifier. The value MUST be (in network order) 0xFE, 'S', 'M', and 'B'."};
  
    USHORT StructureSize where ValidationCheckValue(value == 64, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2PacketHeaderSync", 64, value)
        with Documentation
           {Description = "This MUST be set to 64, which is the size, in bytes, of the SMB2 header structure."};
    
    USHORT CreditCharge
        with Documentation
           {Description = "In the SMB 2.002 dialect, this field MUST NOT be used and MUST be reserved. The sender MUST set this to 0, and the receiver MUST ignore it. In the SMB 2.1 dialect, this field indicates the number of credits that this request consumes."};
  
    optional [|IsRequest && SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] USHORT ChannelSequence
          with Documentation
           {Description = "This field is an indication to the server about the client's Channel change."};
    optional [|IsRequest && SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] USHORT Reserved
          with Documentation
           {Description = "This field SHOULD be set to zero and the server MUST ignore it on receipt."};

    optional [|!IsRequest || SMB2DialectRevision != SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber|] NTSTATUS Status
        with Documentation
           {Description = "The status code for a response. For a request, the client MUST set this field to 0 and the server MUST ignore it on receipt. For a response, this field can be set to any value. For a list of valid status codes, see [MS-ERREF] section ."};
  
    SMB2PacketHeaderSyncCommand Command
        where ValidationCheck(InRange<SMB2PacketHeaderSyncCommand>(value), null, DiagnosisLevel.Error, 
            () => Format(COMMON_STR_CHECK_VALUE_IN_RANGE, ["SMB2", "Command", COMMON_STR_TYPE, "SMB2PacketHeaderSync", COMMON_STR_MUST, "0x0000", "0x0012", value]))
        with Documentation
           {Description = "The command code of this packet. This field MUST contain one of the following valid commands."};
  
    USHORT Credit//$"CreditRequest/CreditResponse"
        with Documentation
           {Description = "On a request, this field indicates the number of credits the client is requesting. On a response, it indicates the number of credits granted to the client."};
  
    SMB2PacketHeaderFlags Flags where (Flags & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) == 0
        with Documentation
           {Description = "A Flags field indicates how to process the operation. This field MUST be constructed using the following values:"};
  
    ULONG NextCommand
        with Documentation
           {Description = "For a compounded request, this field MUST be set to the offset, in bytes, from the beginning of this SMB2 header to the start of the subsequent 8-byte aligned SMB2 header. If this is not a compounded request, or this is the last header in a compounded request, this value MUST be 0."};
  
    UINT64 MessageId
        with Documentation
           {Description = "A value that identifies a message request and response uniquely across all messages that are sent on the same SMB 2 Protocol transport connection."};
  
    ULONG Reserved2// where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "SMB2: SMB2PacketHeaderSync.Reserved2 field must not be used and must be reserved. The client should set this field to zero. The server must ignore this field on receipt.")
        with Documentation
           {Description = "The client SHOULD set this field to 0. The server MAY ignore this field on receipt."};
  
    ULONG TreeId
        with Documentation
           {Description = "Uniquely identifies the tree connect for the command. This MUST be 0 for the SMB2 TREE_CONNECT Request. The TreeId MAY be any unsigned 32-bit integer that is received from a previous SMB2 TREE_CONNECT Response. The following SMB 2 Protocol commands do not require the TreeId to be set to a nonzero value received from a previous SMB2 TREE_CONNECT Response. TreeId SHOULD be set to 0 for the following commands:"};
  
    UINT64 SessionId
        with Documentation
           {Description = "Uniquely identifies the established session for the command. This MUST be 0 for requests that do not have a user context that is associated with them. This MUST be 0 for the first SMB2 SESSION_SETUP Request for a specified security principal. The following SMB 2 Protocol commands do not require the SessionId to be set to a nonzero value received from a previous SMB2 SESSION_SETUP Response. The client MUST set SessionId to 0, and the server SHOULD ignore this value for the following commands:"};
  
    binary Signature where ValidationCheck(value == $[00000000000000000000000000000000] || (Flags & SMB2PacketHeaderFlags.SMB2FlagsSigned) > 0, null, DiagnosisLevel.Error, "SMB2: The Signature field in type SMB2PacketHeaderSync must be zero if the message is not signed, not " + value.ToString() + ".")
        with BinaryEncoding{Length = 16},
             Documentation
                 {Description = "The 16-byte signature of the message, if SMB2_FLAGS_SIGNED is set in the Flags field of the SMB2 header. If the message is not signed, this field MUST be 0."};
    override string ToString()
    {
        string summary = "";
        if (!IsRequest)
        {
            summary = "Status: " + StatusToText(this);
        }
        return summary;
    }
}
with Documentation
       {Description = "If the SMB2_FLAGS_Async_COMMAND bit is not set in Flags, the header takes the following form."};

pattern SMB2PacketHeaderSyncCommand = enum USHORT
{
    SMB2Negotiate      = 0x0000,
    SMB2SessionSetup   = 0x0001,
    SMB2Logoff         = 0x0002,
    SMB2TreeConnect    = 0x0003,
    SMB2TreeDisconnect = 0x0004,
    SMB2Create         = 0x0005,
    SMB2Close          = 0x0006,
    SMB2Flush          = 0x0007,
    SMB2Read           = 0x0008,
    SMB2Write          = 0x0009,
    SMB2Lock           = 0x000A,
    SMB2Ioctl          = 0x000B,
    SMB2Cancel         = 0x000C,
    SMB2Echo           = 0x000D,
    SMB2QueryDirectory = 0x000E,
    SMB2ChangeNotify   = 0x000F,
    SMB2QueryInfo      = 0x0010,
    SMB2SetInfo        = 0x0011,
    SMB2OplockBreak    = 0x0012,
    ...
}with Documentation {EmbeddedType = true};

// 2.2.2   SMB2 ERROR Response Packet
type SMB2ErrorResponse[uint Status]
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2ErrorResponse", 9, value)
        with Documentation
           {Description = "The server MUST set this field to 9, indicating the size of the response structure, not including the header. The server MUST set it to this value regardless of how long ErrorData[] actually is in the response being sent."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2ErrorResponse", value)
        with Documentation
           {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    ULONG ByteCount
        with Documentation
           {Description = "The number of bytes of data contained in ErrorData[]."};

    ([|ByteCount == 0|] byte
    | [|Status == 0x8000002D|] SymbolicLinkErrorResponseErrorData // STATUS_STOPPED_ON_SYMLINK
    | string) ErrorData with BinaryEncoding{Length = ByteCount / 2},
        Documentation
            {Description = "A variable-length data field that contains extended error information. If the Status code in the header of the response is set to STATUS_STOPPED_ON_SYMLINK, this field MUST contain a Symbolic Link Error Response as specified in section . If the ByteCount field is zero then the server MUST supply an ErrorData field that is one byte in length, and SHOULD set that byte to zero; the client MUST ignore it on receipt.windows–based SMB2 servers leave this one byte of ErrorData uninitialized and it might contain any value."};
}
with Documentation
       {Description = "The SMB2 ERROR Response packet is sent by the server to respond to a request that has failed or encountered an error. This response is composed of an SMB2 Packet Header(section ) followed by this response structure."};

// 2.2.2.1   Symbolic Link Error Response
type SymbolicLinkErrorResponseErrorData
{
    ULONG SymLinkLength
        with Documentation
           {Description = "The length, in bytes, of the response including the variable-length portion and excluding SymLinkLength."};

    ULONG SymLinkErrorTag where ValidationCheckValue(value == 0x4C4D5953, null, true, ReferenceType.Type, "SMB2", "SymLinkErrorTag", "SymbolicLinkErrorResponseErrorData", "0x4C4D5953", value)
        with Documentation
           {Description = "The server MUST set this field to 0x4C4D5953."};

    ULONG ReparseTag where ValidationCheckValue(value == 0xA000000C, null, true, ReferenceType.Type, "SMB2", "ReparseTag", "SymbolicLinkErrorResponseErrorData", "0xA000000C", value)
        with Documentation
           {Description = "The type of link encountered. The server MUST set this field to 0xA000000C."};

    USHORT ReparseDataLength where ValidationCheck(value >= 12, null, DiagnosisLevel.Error, () => "SMB2: The ReparseDataLength field in type SymbolicLinkErrorResponseErrorData must be greater than or equal to 12, not " + Utility.DecToHexFormat(value) + ".")
        with Documentation
           {Description = "The length, in bytes, of the variable-length portion of the symbolic link error response plus the size of the static portion, not including SymLinkLength, SymLinkErrorTag, ReparseTag, ReparseDataLength, and UnparsedPathLength. The server MUST set this to the size of PathBuffer[], in bytes, plus 12.(12 is the size of SubstituteNameOffset, SubstituteNameLength, PrintNameOffset, PrintNameLength, and Flags.)"};

    USHORT UnparsedPathLength
        with Documentation
           {Description = "The length, in bytes, of the unparsed portion of the path. The unparsed portion is the remaining part of the path after the symbolic link. See section  for examples."};

    USHORT SubstituteNameOffset
        with Documentation
           {Description = "The offset, in bytes, from the beginning of the PathBuffer field, at which the substitute name is located. The substitute name is the name the client MUST use to access this file if it requires to follow the symbolic link."};

    USHORT SubstituteNameLength
        with Documentation
           {Description = "The length, in bytes, of the substitute name string. If there is a terminating null character at the end of the string, it is not included in the SubstituteNameLength count. This value MUST be greater than or equal to 0."};

    USHORT PrintNameOffset
        with Documentation
           {Description = "The offset, in bytes, from the beginning of the PathBuffer field, at which the print name is located. The print name is the user-friendly name the client MUST return to the application if it requests the name of the symbolic link target."};

    USHORT PrintNameLength
        with Documentation
           {Description = "The length, in bytes, of the print name string. If there is a terminating null character at the end of the string, it is not included in the PrintNameLength count. This value MUST be greater than or equal to 0."};

    SymbolicLinkErrorResponseFlags Flags
        where ValidationCheck(InRange<SymbolicLinkErrorResponseFlags>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "Flags", COMMON_STR_TYPE, "SymbolicLinkErrorResponseErrorData", COMMON_STR_MUST, "0x00000000, 0x00000001", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "A 32-bit bit field that specifies whether the substitute is an absolute target path name or a path name relative to the directory containing the symbolic link."};
    // Will manully decode the PathBuffer in detail later
    PathBuffer PathBuffer with Encoding{Ignore =  true},
        Documentation
            {Description = "A buffer that contains the Unicode strings for the substitute name and the print name, as described by SubstituteNameOffset, SubstituteNameLength, PrintNameOffset, and PrintNameLength. The substitute name string MUST be a Unicode path to the target of the symbolic link. The print name string MUST be a Unicode string, suitable for display to a user, that also identifies the target of the symbolic link."};
}
with Documentation
       {Description = "The Symbolic Link Error Response is used to indicate that a symbolic link was encountered on create; it describes the target path that the client must use if it requires to follow the symbolic link. This structure is contained in the ErrorData section of the SMB2 ERROR Response(section ). This structure MUST NOT be returned in an SMB2 ERROR Response unless the Status code in the header of that response is set to STATUS_STOPPED_ON_SYMLINK.windows servers will never follow a symlink. It is the client's responsibility to evaluate the symlink and access the actual file using the symlink. A windows server only returns STATUS_STOPPED_ON_SYMLINK when the open fails due to presence of a symlink. The structure has the following format."};

type PathBuffer
{
    string SubstituteName;
    string PrintName;
}

pattern SymbolicLinkErrorResponseFlags = enum ULONG
{
    SYMLinkFlagPath = 0x00000000
        with Documentation
            {Description = "The substitute name is an absolute target path name."},
    SYMLinkFlagRelative = 0x00000001
        with Documentation
            {Description = "When this Flags value is set, the substitute name is a path name relative to the directory containing the symbolic link."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.3   SMB2 NEGOTIATE Request
type SMB2NegotiateRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 36, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2NegotiateRequest", 36, value)
          with Documentation
           {Description = "The client MUST set this field to 36, indicating the size of a NEGOTIATE request. This is not the size of the structure with a single dialect in the Dialects[] array. This value MUST be set regardless of the number of dialects sent."};

    USHORT DialectCount where ValidationCheckGreaterThan(value > 0, null, true, ReferenceType.Type, "SMB2", "DialectCount", "SMB2NegotiateRequest", 0, value)
          with Documentation
           {Description = "The number of dialects that are contained in the Dialects[] array. This value MUST be greater than 0.windows-based SMB2 servers fail the request and return STATUS_INVALID_PARAMETER, if the DialectCount field is greater than 64."};

    SMB2NegotiateRequestSecurityMode SecurityMode
          with Documentation
           {Description = "The security mode field specifies whether SMB signing is enabled, required at the server, or both. This field MUST be constructed using the following values."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2NegotiateRequest", value)
          with Documentation
           {Description = "The client MUST set this to 0, and the server SHOULD ignore it on receipt."};

    SMB2NegotiateRequestCapabilities Capabilities
          with Documentation
           {Description = "If the client implements the SMB 3.x dialect family, the Capabilities field MUST be constructed using the following values. Otherwise, this field MUST be set to 0."};

    GUID ClientGuid
          with Documentation
           {Description = "It MUST be a GUID(as specified in [MS-DTYP] section ) generated by the client, if the client implements SMB 2.1 dialect. Otherwise, the client MUST set this to 0."};

    FILETIME ClientStartTime where ValidationCheckReservedZero(value.dwLowDateTime == 0 && value.dwHighDateTime == 0, null, true, ReferenceType.Type, "SMB2", "ClientStartTime", "SMB2NegotiateRequest", value.ToString())
          with DisplayInfo {ToText = SMB2.FileTimeToText}, 
          Documentation
           {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    array<SMB2NegotiateRequestDialects> Dialects
        with BinaryEncoding{Length = DialectCount},
            Documentation
               {Description = "An array of one or more 16-bit integers specifying the supported dialect revision numbers. The array MUST contain at least one of the following values.A windows_vista RTM–based client would send a value of zero in the Dialects array in SMB2 NEGOTIATE Request and a windows_vista RTM-based server would acknowledge with a value of 6 in DialectRevision in SMB2 NEGOTIATE Response. This behavior is deprecated."};
}
with Documentation
       {Description = "The SMB2 NEGOTIATE Request packet is used by the client to notify the server what dialects of the SMB 2 Protocol the client understands. This request is composed of an SMB2 header, as specified in section , followed by this request structure."};

pattern SMB2NegotiateRequestCapabilities = flags ULONG
{
    SMB2GlobalCapDfs = 0x00000001
        with Documentation
            {Description = "When set, indicates that the client supports the Distributed File System (DFS)."},
    SMB2GlobalCapLeasing = 0x00000002
        with Documentation
            {Description = "When set, indicates that the client supports leasing."},
    SMB2GlobalCapLargeMtu = 0x00000004
        with Documentation
            {Description = "When set, indicates that the client supports multi-credit operations."},
    SMB2GlobalCapMultiChannel = 0x00000008
        with Documentation
            {Description = "When set, indicates that the client supports establishing multiple channels for a single session."},
    SMB2GlobalCapPersistentHandles = 0x00000010
        with Documentation
            {Description = "When set, indicates that the client supports persistent handles."},
    SMB2GlobalCapDirectoryLeasing = 0x00000020
        with Documentation
            {Description = "When set, indicates that the client supports directory leasing."},
    SMB2GlobalCapEncryption = 0x00000040
        with Documentation
            {Description = "When set, indicates that the client supports encryption."}
} with Documentation {EmbeddedType = true};

pattern SMB2NegotiateRequestSecurityMode = flags USHORT
{
    SMB2NegotiateSigningEnabled = 0x0001
        with Documentation
               {Description = "When set, indicates that security signatures are enabled on the client. The client MUST set this bit if the SMB2_NEGOTIATE_SIGNING_REQUIRED bit is not set, and MUST NOT set this bit if the SMB2_NEGOTIATE_SIGNING_REQUIRED bit is set. The server MUST ignore this bit."},
    SMB2NegotiateSigningRequired = 0x0002
        with Documentation
               {Description = "When set, indicates that security signatures are required by the client."},
} with Documentation {EmbeddedType = true};


pattern SMB2NegotiateRequestDialects = enum USHORT
{
    SMB2002DialectRevisionNumber = 0x0202
        with Documentation
            {Description = "SMB 2.002 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, Windows Server 2012, Windows 8.1, and Windows Server 2012 R2 support this dialect revision."},
    SMB21DialectRevisionNumber = 0x0210
        with Documentation
            {Description = "SMB 2.1 dialect revision number. Windows Vista SP1 and Windows Server 2008 do not support this dialect revision."},
    SMB30DialectRevisionNumber = 0x0300
        with Documentation
            {Description = "SMB 3.0 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, and Windows Server 2008 R2 do not support this dialect revision."},
    SMB302DialectRevisionNumber = 0x0302
        with Documentation
            {Description = "SMB 3.02 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, and Windows Server 2012 do not support the SMB 3.02 dialect."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.4   SMB2 NEGOTIATE Response
type SMB2NegotiateResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 65, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2NegotiateResponse", 65, value)
        with Documentation
            {Description = "The server MUST set this field to 65, indicating the size of the response structure, not including the header. The server MUST set it to this value, regardless of how long Buffer[] actually is in the response being sent."};

    SMB2NegotiateResponseSecurityMode SecurityMode
        with Documentation
            {Description = "The security mode field specifies whether SMB signing is enabled, required at the server, or both. This field MUST be constructed using the following values."};

    SMB2NegotiateResponseDialectRevision DialectRevision
        with Documentation
            {Description = "The preferred common SMB 2 Protocol dialect number from the Dialects array that is sent in the SMB2 NEGOTIATE Request(SECTION ) or the SMB2 wildcard revision number. The server SHOULD set this field to one of the following values.A windows_vista RTM–based client would send a value of zero in the Dialects array in SMB2 NEGOTIATE Request and a windows_vista RTM–based server would acknowledge with a value of 6 in DialectRevision in SMB2 NEGOTIATE Response. This behavior is deprecated."}
        with DisplayInfo{ToText = SMB2.DialectRevisionToText};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "SMB2", "Reserved", "SMB2NegotiateResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server SHOULD set this to 0, and the client MUST ignore it on receipt.windows-based SMB2 servers may set this field to any value."};

    GUID ServerGuid
        with Documentation
            {Description = "A globally unique identifier that is generated by the server to uniquely identify this server. This field MUST NOT be used by a client as a secure method of identifying a server.windows–based SMB2 servers generate a new ServerGuid each time they are started."};

    SMB2NegotiateResponseCapabilities Capabilities
        with Documentation
            {Description = "The Capabilities field specifies protocol capabilities for the server. This field MUST be constructed using the following values."};

    ULONG MaxTransactSize
        with Documentation
            {Description = "The maximum size, in bytes, of the buffer that can be used for QUERY_INFO, QUERY_DIRECTORY, SET_INFO and CHANGE_NOTIFY operations. This field is applicable only for buffers sent by the client in SET_INFO requests, or returned from the server in QUERY_INFO, QUERY_DIRECTORY, and CHANGE_NOTIFY responses.windows clients do not enforce the MaxTransactSize value."};

    ULONG MaxReadSize
        with Documentation
            {Description = "The maximum size, in bytes, of the Length in an SMB2 READ Request(section ) that the server will accept."};

    ULONG MaxWriteSize
        with Documentation
            {Description = "The maximum size, in bytes, of the Length in an SMB2 WRITE Request that the server will accept."};

    FILETIME SystemTime
        with Documentation
            {Description = "The system time of the SMB2 server when the SMB2 NEGOTIATE Request was processed; in FILETIME format as specified in [MS-DTYP] section ."};

    FILETIME ServerStartTime
        with Documentation
            {Description = "The SMB2 server start time, in FILETIME format as specified in [MS-DTYP] section ."};

    USHORT SecurityBufferOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the security buffer."};

    USHORT SecurityBufferLength
        with Documentation
            {Description = "The length, in bytes, of the security buffer."};

    ULONG Reserved2
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server may set this to any value, and the client MUST ignore it on receipt."};

    // WORKAROUND: Remove this padding. Related bug#16407: TrailPadding/LeadPadding in BinaryEncoding aspect doesn't effect
    optional [|SecurityBufferOffset > 128|] array<byte> BufferPadding with BinaryEncoding{Length = SecurityBufferOffset - 128 as uint};
    (binary | any) Buffer // WORKAROUND: Remove Length = SecurityBufferLength aspect to surpport the partial packet
        with Documentation
            {Description = "The variable-length buffer that contains the security buffer for the response, as specified by SecurityBufferOffset and SecurityBufferLength. The buffer SHOULD contain a token as produced by the GSS protocol as specified in section . If SecurityBufferLength is 0, this field is empty and then client-initiated authentication, with an authentication protocol of the client's choice, will be used instead of server-initiated SPNEGO authentication as described in [MS-AUTHSO] section .[MS-AUTHSO] section 3.2.2."};
}
with Documentation
       {Description = "The SMB2 NEGOTIATE Response packet is sent by the server to notify the client of the preferred common dialect. This response is composed of an SMB2 header, as specified in section , followed by this response structure."};

pattern SMB2NegotiateResponseSecurityMode = flags USHORT
{
    SMB2NegotiateSigningEnabled = 0x0001
        with Documentation
            {Description = "When set, indicates that security signatures are enabled on the server. The server MUST set this bit, and the client MUST return STATUS_INVALID_NETWORK_RESPONSE if the flag is missing."},
    SMB2NegotiateSigningRequired = 0x0002
        with Documentation
            {Description = "When set, indicates that security signatures are required by the server."},
}with Documentation {EmbeddedType = true};

pattern SMB2NegotiateResponseDialectRevision = enum USHORT
{
    SMB2002DialectRevisionNumber = 0x0202
        with Documentation
            {Description = "SMB 2.002 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2 support this dialect revision."},
    SMB21DialectRevisionNumber = 0x0210
        with Documentation
            {Description = "SMB 2.1 dialect revision number. Windows Vista SP1 and Windows Server 2008 do not support this dialect revision."},
    SMB30DialectRevisionNumber = 0x0300
        with Documentation
            {Description = "SMB 3.0 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7 and Windows Server 2008 R2 do not support this dialect revision."},
    SMB302DialectRevisionNumber = 0x0302
        with Documentation
            {Description = "SMB 3.02 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, and Windows Server 2012 do not support this dialect revision."},
    SMB2WildcardRevisionNumber = 0x02FF
        with Documentation
            {Description = "SMB2 wildcard revision number; indicates that the server supports SMB 2.1 or future dialect revisions and expects the client to send a subsequent SMB2 Negotiate request to negotiate the actual SMB 2 Protocol revision to be used. The wildcard revision number is sent only in response to a multi-protocol negotiate request with the \"SMB 2.???\" dialect string.The \"SMB 2.???\" dialect string is not supported by SMB2 clients and servers in  Windows Vista SP1 and Windows Server 2008."},
    ...
} with Documentation {EmbeddedType = true};


pattern SMB2NegotiateResponseCapabilities = flags ULONG
{
    SMB2GlobalCapDfs = 0x00000001
         with Documentation
            {Description = "When set, indicates that the server supports the Distributed File System(DFS)."},
    SMB2GlobalCapLeasing = 0x00000002
         with Documentation
             {Description = "When set, indicates that the server supports leasing. This flag is not valid for the SMB 2.002 dialect."},
     SMB2GlobalCapLargeMtu = 0x00000004
         with Documentation
             {Description = "When set, indicates that the server supports multi-credit operations. This flag is not valid for the SMB 2.002 dialect."},
     SMB2GlobalCapMultiChannel = 0x00000008
         with Documentation
             {Description = "When set, indicates that the server supports establishing multiple channels for a single session. This flag is not valid for the SMB 2.002 and SMB 2.1 dialects."},
     SMB2GlobalCapPersistentHandles = 0x00000010
         with Documentation
             {Description = "When set, indicates that the server supports persistent handles. This flag is not valid for the SMB 2.002 and SMB 2.1 dialects."},
     SMB2GlobalCapDirectoryLeasing = 0x00000020
         with Documentation
             {Description = "When set, indicates that the server supports directory leasing. This flag is not valid for the SMB 2.002 and SMB 2.1 dialects."},
     SMB2GlobalCapEncryption = 0x00000040
         with Documentation
             {Description = "When set, indicates that the server supports encryption. This flag is not valid for the SMB 2.002 and SMB 2.1 dialects."},
} with Documentation {EmbeddedType = true};

// 2.2.5   SMB2 SESSION_SETUP Request
type SMB2SessionSetupRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 25, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2SessionSetupRequest", 25, value)
        with Documentation
            {Description = "The client MUST set this field to 25, indicating the size of the request structure, not including the header. The client MUST set it to this value regardless of how long Buffer[] actually is in the request being sent."};

    SMB2SessionSetupRequestFlags Flags 
        where ValidationCheck(InRange<SMB2SessionSetupRequestFlags>(value), null, DiagnosisLevel.Error, 
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "Flags", COMMON_STR_TYPE, "SMB2SessionSetupRequest", COMMON_STR_MUST, "0x00, 0x01", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The number of other transport connections that are already established. The client MUST set this field to 0 regardless of the number of outstanding connections."};

    SMB2SessionSetupRequestSecurityMode SecurityMode
        with Documentation
            {Description = "The security mode field specifies whether SMB signing is enabled, required at the server, or both. This field MUST be constructed using the following values."};

    SMB2SessionSetupRequestCapabilities Capabilities 
        where ValidationCheckCombinationValueIncludeZero(InRange<SMB2SessionSetupRequestCapabilities>(value), null,
            true, ReferenceType.Type, "SMB2", "Capabilities", "SMB2SessionSetupRequest","0x00000001, 0x00000002, 0x00000004, 0x00000008", value) 
        with Documentation
            {Description = "Specifies protocol capabilities for the client. This field MUST be constructed using the following values."};

    ULONG Channel where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Channel", "SMB2SessionSetupRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    USHORT SecurityBufferOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB 2 Protocol header to the security buffer."};

    USHORT SecurityBufferLength
        with Documentation
            {Description = "The length, in bytes, of the security buffer."};

    UINT64 PreviousSessionId
        with Documentation
            {Description = "A previously established session identifier. If this is a reconnect, the client MUST set this value to its previous session identifier to allow the server to reconnect. If this is not a reconnect, the client MUST set this to 0."};
    
    // WORKAROUND: Remove this padding. Related bug#16407: TrailPadding/LeadPadding in BinaryEncoding aspect doesn't effect
    optional [|SecurityBufferOffset > 88|] array<byte> BufferPadding with BinaryEncoding{Length = SecurityBufferOffset - 88 as uint};
    (binary | any) Buffer // WORKAROUND: Remove Length = SecurityBufferLength aspect to surpport the partial packet
        with Documentation
            {Description = "A variable-length buffer that contains the security buffer for the request, as specified by SecurityBufferOffset and SecurityBufferLength. If the server initiated authentication using SPNEGO, the buffer MUST contain a token as produced by the GSS protocol as specified in section . If the client initiated authentication, see section , the buffer SHOULDwindows clients set the Buffer with a token as produced by the NTLM authentication protocol in the case, see [MS-NLMP] section . contain a token as produced by an authentication protocol of the client's choice."};
}
with Documentation
       {Description = "The SMB2 SESSION_SETUP Request packet is sent by the client to request a new authenticated session within a new or existing SMB 2 Protocol transport connection to the server. This request is composed of an SMB2 header as specified in section  followed by this request structure."};
       
pattern SMB2SessionSetupRequestSecurityMode = flags BYTE
{
    SMB2NegotiateSigningEnabled = 0x01
        with Documentation
            {Description = "When set, indicates that security signatures are enabled on the client. The client MUST set this bit if the SMB2_NEGOTIATE_SIGNING_REQUIRED bit is not set, and MUST NOT set this bit if the SMB2_NEGOTIATE_SIGNING_REQUIRED bit is set. The server MUST ignore this bit."},
    SMB2NegotiateSigningRequired = 0x02
        with Documentation
            {Description = "When set, indicates that security signatures are required by the client."},
} with Documentation {EmbeddedType = true};

pattern SMB2SessionSetupRequestCapabilities = flags ULONG
{
    SMB2GlobalCapDfs = 0x00000001
        with Documentation
            {Description = "When set, indicates that the client supports the Distributed File System(DFS)."},
    SMB2GlobalCapUnused1 = 0x00000002
        with Documentation
            {Description = "SHOULD be set to zero, and server MUST ignore."},
    SMB2GlobalCapUnused2 = 0x00000004
        with Documentation
            {Description = "SHOULD be set to zero and server MUST ignore."},
    SMB2GlobalCapUnused3 = 0x00000008
        with Documentation
            {Description = "SHOULD be set to zero and server MUST ignore."}
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2SessionSetupRequestFlags = flags BYTE
{
    SMB2SessionFlagBinding = 0x01
        with Documentation
            {Description = "When set, indicates that the request is to bind an existing session to a new connection."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.6   SMB2 SESSION_SETUP Response
type SMB2SessionSetupResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2SessionSetupResponse", 9, value)
        with Documentation
            {Description = "The server MUST set this to 9, indicating the size of the fixed part of the response structure not including the header. The server MUST set it to this value regardless of how long Buffer[] actually is in the response."};

    SMB2SessionSetupResponseSessionFlags SessionFlags
        with Documentation
            {Description = "A flags field that indicates additional information about the session. This field MUST contain either 0 or one of the following values:"};

    USHORT SecurityBufferOffset 
        where ValidationCheck(value >= 72, null, DiagnosisLevel.Error, () => "SMB2: The SecurityBufferOffset field in type SMB2SessionSetupResponse must be greater than or equal to 72, not " + Utility.DecToHexFormat(value) + ".")
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the security buffer."};

    USHORT SecurityBufferLength
        with Documentation
            {Description = "The length, in bytes, of the security buffer."};
    
    // WORKAROUND: Remove this padding. Related bug#16407: TrailPadding/LeadPadding in BinaryEncoding aspect doesn't effect
    optional [|SecurityBufferOffset > 72|] array<byte> BufferPadding with BinaryEncoding{Length = SecurityBufferOffset - 72 as uint};
    (binary | any) Buffer // WORKAROUND: Remove Length = SecurityBufferLength aspect to surpport the partial packet
        with Documentation
            {Description = "A variable-length buffer that contains the security buffer for the response, as specified by SecurityBufferOffset and SecurityBufferLength. If the server initiated authentication using SPNEGO, the buffer MUST contain a token as produced by the GSS protocol as specified in section . If the client initiated authentication, see section , the buffer SHOULDwindows clients set the Buffer with a token as produced by the NTLM authentication protocol in the case, see [MS-NLMP] section . contain a token as produced by an authentication protocol of the client's choice."};
}
with Documentation
       {Description = "The SMB2 SESSION_SETUP Response packet is sent by the server in response to an SMB2 SESSION_SETUP Request packet. This response is composed of an SMB2 header, as specified in section , that is followed by this response structure:"};

pattern SMB2SessionSetupResponseSessionFlags = flags USHORT
{
   SMB2SessionFlagIsGuest = 0x0001
       with Documentation
           {Description = "If set, the client has been authenticated as a guest user."},
   SMB2SessionFlagIsNull = 0x0002
       with Documentation
           {Description = "If set, the client has been authenticated as an anonymous user."},
   SMB2SessionFlagEncryptData = 0x0004
       with Documentation
           {Description = "If set, the server requires encryption of messages on this session, per the conditions specified in section . This flag is only valid for the SMB 3.x dialect family."},
} with Documentation {EmbeddedType = true};


// 2.2.7   SMB2 LOGOFF Request
type SMB2LogoffRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LogoffRequest", 4, value)
        with Documentation
            {Description = "The client MUST set this field to 4, indicating the size of the request structure not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LogoffRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 LOGOFF Request packet is sent by the client to request termination of a particular session. This request is composed of an SMB2 header as specified in section  followed by this request structure."};

// 2.2.8   SMB2 LOGOFF Response
type SMB2LogoffResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LogoffResponse", 4, value)
        with Documentation
            {Description = "The server MUST set this field to 4, indicating the size of the response structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LogoffResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 LOGOFF Response packet is sent by the server to confirm that an SMB2 LOGOFF Request(section ) was completed successfully. This response is composed of an SMB2 header, as specified in section , followed by this request structure:"};

// 2.2.9   SMB2 TREE_CONNECT Request
type SMB2TreeConnectRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2TreeConnectRequest", 9, value)
        with Documentation
            {Description = "The client MUST set this field to 9, indicating the size of the request structure, not including the header. The client MUST set it to this value regardless of how long Buffer[] actually is in the request being sent."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TreeConnectRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    USHORT PathOffset
        with Documentation
            {Description = "The offset, in bytes, of the full share path name from the beginning of the packet header."};

    USHORT PathLength
        with Documentation
            {Description = "The length, in bytes, of the path name."};

    // WORKAROUND: Remove this padding. Related bug#16407: TrailPadding/LeadPadding in BinaryEncoding aspect doesn't effect
    optional [|PathOffset > 72|] array<byte> PathPadding with BinaryEncoding{Length = PathOffset - 72 as uint};
    string Buffer with BinaryEncoding{Length = (PathLength / 2) as uint}, //LeadPadding = (PathOffset - 72) * 8 as uint}}
             Documentation
                {Description = "A variable-length buffer that contains the path name of the share in Unicode in the form \\\\server\\share for the request, as described by PathOffset and PathLength. The server component of the path MUST be less than 256 characters in length, and it MUST be a NetBIOS name, a fully qualified domain name(FQDN), or a textual IPv4 or IPv6 address. The share component of the path MUST be less than or equal to 80 characters in length. The share name MUST NOT contain any invalid characters, as specified in [MS-FSCC] section .The windowsSMB 2 Protocol client translates any names of the form \\\\server\\pipe to \\\\server\\IPC$ before sending a request on the network."};
}
with Documentation
       {Description = "The SMB2 TREE_CONNECT Request packet is sent by a client to request access to a particular share on the server. This request is composed of an SMB2 Packet Header(section ) that is followed by this request structure."};

// 2.2.10   SMB2 TREE_CONNECT Response
type SMB2TreeConnectResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 16, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2TreeConnectResponse", 16, value)
        with Documentation
            {Description = "The server MUST set this field to 16, indicating the size of the response structure, not including the header."};

    SMB2TreeConnectResponseShareType ShareType
        where ValidationCheck(InRange<SMB2TreeConnectResponseShareType>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "ShareType", COMMON_STR_TYPE, "SMB2TreeConnectResponse", COMMON_STR_MUST, "0x01, 0x02, 0x03", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The type of share being accessed. This field MUST contain one of the following values."};

    BYTE Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TreeConnectResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    SMB2TreeConnectResponseShareFlags ShareFlags
        with Documentation
            {Description = "This field contains properties for this share."};

    SMB2TreeConnectResponseCapabilities Capabilities
        with Documentation
            {Description = "Indicates various capabilities for this share. This field MUST be constructed using the following value."};

    ([|ShareType == SMB2TreeConnectResponseShareType.SMB2ShareTypeDisk|] DirectoryAccessMask
        | FilePipePrinterAccessMask) MaximalAccess
        with Documentation
            {Description = "Contains the maximal access for the user that establishes the tree connect on the share based on the share's permissions. This value takes the form as specified in section ."};
}
with Documentation
       {Description = "The SMB2 TREE_CONNECT Response packet is sent by the server when an SMB2 TREE_CONNECT request is processed successfully by the server. The server MUST set the TreeId of the newly created tree connect in the SMB 2 Protocol header of the response. This response is composed of an SMB2 Packet Header(section ) that is followed by this response structure."};

pattern SMB2TreeConnectResponseShareType = enum BYTE
{
    SMB2ShareTypeDisk = 0x01
        with Documentation {Description = "Physical disk share."},
    SMB2ShareTypePipe = 0x02
        with Documentation {Description = "Named pipe share."},
    SMB2ShareTypeprint = 0x03
        with Documentation {Description = "Printer share."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2ShareflagCachingType = enum BYTE
{
    SMB2ShareflagManualCaching = 0x00
        with Documentation
            {Description = "The client may cache files that are explicitly selected by the user for offline use."},
    SMB2ShareflagAutoCaching = 0x01
        with Documentation
            {Description = "The client may automatically cache files that are used by the user for offline access."},
    SMB2ShareflagVdoCaching = 0x02
        with Documentation
            {Description = "The client may automatically cache files that are used by the user for offline access and may use those files in an offline mode even if the share is available."},
    SMB2ShareflagNoCaching = 0x03
        with Documentation {Description = "Offline caching MUST NOT occur."},
    ...
 }with Documentation {EmbeddedType = true};
        
type SMB2TreeConnectResponseShareFlags
{
    SMB2ShareflagCachingType SMB2ShareflagCaching
        where ValidationCheck(InRange<SMB2ShareflagCachingType>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "ShareFlagCaching", COMMON_STR_TYPE, "SMB2TreeConnectResponse", COMMON_STR_MUST, "0x00, 0x01, 0x02, 0x03", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 4};
    byte Reserved1 with BinaryEncoding{Width = 2};
    bool SMB2ShareflagDfsRoot with BinaryEncoding{Width = 1};
    bool SMB2ShareflagDfs with BinaryEncoding{Width = 1};
   
    bool SMB2ShareflagEncryptData with BinaryEncoding{Width = 1};
    bool SMB2ShareflagEnableHashV2 with BinaryEncoding{Width = 1};
    bool SMB2ShareflagEnableHashV1 with BinaryEncoding{Width = 1};
    bool SMB2ShareflagForceLeveliiOplock with BinaryEncoding{Width = 1};
    bool SMB2ShareflagAccessBasedDirectoryEnum with BinaryEncoding{Width = 1};
    bool SMB2ShareflagAllowNamespaceCaching with BinaryEncoding{Width = 1};
    bool SMB2ShareflagForceSharedDelete with BinaryEncoding{Width = 1};
    bool SMB2ShareflagRestrictExclusiveOpens with BinaryEncoding{Width = 1};

    USHORT Reserved2;
    override string ToString()
    {
        string shareflags = "";
        bool flag = false;
        if (SMB2ShareflagDfsRoot)
        {
            shareflags += "DfsRoot";
            flag = true;
        }
        if (SMB2ShareflagDfs)
        {
            shareflags += flag ? "|Dfs" : "Dfs";
            flag = true;
        }
        if (SMB2ShareflagEncryptData)
        {
            shareflags += flag ? "|EncryptData" : "EncryptData";
            flag = true;
        }
        if (SMB2ShareflagEnableHashV2)
        {
            shareflags += flag ? "|EnableHashV2" : "EnableHashV2";
            flag = true;
        }
        if (SMB2ShareflagEnableHashV1)
        {
            shareflags += flag ? "|EnableHashV1" : "EnableHashV1";
            flag = true;
        }
        if (SMB2ShareflagForceLeveliiOplock)
        {
            shareflags += flag ? "|ForceLeveliiOplock" : "ForceLeveliiOplock";
            flag = true;
        }
        if (SMB2ShareflagAccessBasedDirectoryEnum)
        {
            shareflags += flag ? "|AccessBasedDirectoryEnum" : "AccessBasedDirectoryEnum";
            flag = true;
        }
        if (SMB2ShareflagAllowNamespaceCaching)
        {
            shareflags += flag ? "|AllowNamespaceCaching" : "AllowNamespaceCaching";
            flag = true;
        }
        if (SMB2ShareflagForceSharedDelete)
        {
            shareflags += flag ? "|ForceSharedDelete" : "ForceSharedDelete";
            flag = true;
        }
        if (SMB2ShareflagRestrictExclusiveOpens)
        {
            shareflags += flag ? "|RestrictExclusiveOpens" : "RestrictExclusiveOpens";
            flag = true;
        }
        return shareflags;
    }
    
} with Documentation {EmbeddedType = true};
 
pattern SMB2TreeConnectResponseCapabilities = flags ULONG
{
    SMB2_SHARE_CAP_DFS = 0x00000008
        with Documentation
        {Description = "The specified share is present in a DFS tree structure. The server MUST set the SMB2_SHARE_CAP_DFS bit in the Capabilities field if the per-share property Share.IsDfs is TRUE."},
    SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY = 0x00000010
        with Documentation
        {Description = "The specified share is continuously available. This flag is only valid for the SMB 3.x dialect family."},
    SMB2_SHARE_CAP_SCALEOUT = 0x00000020
        with Documentation
            {Description = "The specified share is present on a server configuration which facilitates faster recovery of durable handles. This flag is only valid for the SMB 3.x dialect family."},
    SMB2_SHARE_CAP_CLUSTER = 0x00000040
        with Documentation
            {Description = "The specified share is present on a server configuration which provides monitoring of the availability of share through the Witness service specified in [MS-SWN]. This flag is only valid for the SMB 3.x dialect family."},
    SMB2_SHARE_CAP_ASYMMETRIC = 0x00000080
       with Documentation
            {Description = "The specified share is present on a server configuration that allows dynamic changes in the ownership of the share. This flag is only valid for the SMB 3.02 dialect."}
} with Documentation {EmbeddedType = true};

// 2.2.11   SMB2 TREE_DISCONNECT Request
type SMB2TreeDisconnectRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2TreeDisconnectRequest", 4, value)
        with Documentation
            {Description = "The client MUST set this field to 4, indicating the size of the request structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TreeDisconnectRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 TREE_DISCONNECT Request packet is sent by the client to request that the tree connect that is specified in the TreeId within the SMB2 header be disconnected. This request is composed of an SMB2 header, as specified in section , that is followed by this variable-length request structure."};

// 2.2.12   SMB2 TREE_DISCONNECT Response
type SMB2TreeDisconnectResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2TreeDisconnectResponse", 4, value)
        with Documentation
            {Description = "The server MUST set this field to 4, indicating the size of the response structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TreeDisconnectResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 TREE_DISCONNECT Response packet is sent by the server to confirm that an SMB2 TREE_DISCONNECT Request(section ) was successfully processed. This response is composed of an SMB2 header, as specified in section , that is followed by this request structure."};

// 2.2.13   SMB2 CREATE Request
type SMB2CreateRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 57, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CreateRequest", 57, value)
        with Documentation
            {Description = "The client MUST set this field to 57, indicating the size of the request structure, not including the header. The client MUST set it to this value regardless of how long Buffer[] actually is in the request being sent."};

    BYTE SecurityFlags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "SecurityFlags", "SMB2CreateRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it."};

    SMB2CreateRequestRequestedOplockLevel RequestedOplockLevel
        where ValidationCheck(InRange<SMB2CreateRequestRequestedOplockLevel>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "RequestedOplockLevel", COMMON_STR_TYPE, "SMB2CreateRequest", COMMON_STR_MUST, "0x00, 0x01, 0x08, 0x09, 0xFF", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The requested oplock level. This field MUST contain one of the following values.windows-based clients never use exclusive oplocks. Because there are no situations where the client would require an exclusive oplock where it would not also require an SMB2_OPLOCK_LEVEL_BATCH, it always requests an SMB2_OPLOCK_LEVEL_BATCH. For named pipes, the server MUST always revert to SMB2_OPLOCK_LEVEL_NONE irrespective of the value of this field."};

    SMB2CreateRequestImpersonationLevel ImpersonationLevel
        where ValidationCheck(InRange<SMB2CreateRequestImpersonationLevel>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "ImpersonationLevel", COMMON_STR_TYPE, "SMB2CreateRequest", COMMON_STR_MUST, "0x00000001, 0x00000002, 0x00000003", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "This field specifies the impersonation level requested by the application that is issuing the create request, and MUST contain one of the following values. The server MUST validate this field, but otherwise ignore it."};

    UINT64 SmbCreateFlags where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "SMB2", "SmbCreateFlags", "SMB2CreateRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client SHOULD set this field to zero, and the server MUST ignore it on receipt."};

    UINT64 Reserved
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client sets this to any value, and the server MUST ignore it on receipt."};

    FilePipePrinterAccessMask DesiredAccess
        with Documentation
            {Description = "The level of access that is required, as specified in section ."};
    
    FileAttributes FileAttributes
        with Documentation
            {Description = "This field MUST be a combination of the values specified in [MS-FSCC] section , and MUST NOT include any values other than those specified in that section."};

    SMB2CreateRequestShareAccess ShareAccess
        with Documentation
            {Description = "Specifies the sharing mode for the open. If ShareAccess values of FILE_SHARE_READ, FILE_SHARE_WRITE and FILE_SHARE_DELETE are set for a printer file or a named pipe, the server SHOULDWhen opening a printer file or a named pipe, windows-based servers ignore these ShareAccess values. ignore these values. The field MUST be constructed using a combination of zero or more of the following bit values."};

    SMB2CreateRequestCreateDisposition CreateDisposition
        where ValidationCheck(InRange<SMB2CreateRequestCreateDisposition>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_VALUE_IN_RANGE, ["SMB2", "CreateDisposition", COMMON_STR_TYPE, "SMB2CreateRequest", COMMON_STR_MUST, "0x00000000", "0x00000005", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "Defines the action the server MUST take if the file that is specified in the name field already exists. For opening named pipes, this field may be set to any value by the client and MUST be ignored by the server. For other files, this field MUST contain one of the following values."};

    SMB2CreateRequestCreateOptions CreateOptions
        where ValidationCheck(InRange<SMB2CreateRequestCreateOptions>(value), null, 
            "SMB2: For CreateOptions in type SMB2CreateRequest, all bits that are not specified in the table in [MS-SMB2] should be zero, because they are reserved by Windows server implementations.")
        with Documentation
            {Description = "Specifies the options to be applied when creating or opening the file. Combinations of the bit positions listed below are valid, unless otherwise noted. This field MUST be constructed using the following values.windows server implementations reserve all bits that are not specified in the table. If any of the reserved bits are set, STATUS_NOT_SUPPORTED is returned."};

    USHORT NameOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the 8-byte aligned file name. If SMB2_FLAGS_DFS_OPERATIONS is set in the Flags field of the SMB2 header, the file name can be prefixed with DFS link information that will be removed during DFS name normalization as specified in section . Otherwise, the file name is relative to the share that is identified by the TreeId in the SMB2 header. The NameOffset field SHOULD be set to the offset of the Buffer field from the beginning of the SMB2 header. The file name(after DFS normalization if needed) MUST conform to the specification of a relative pathname in [MS-FSCC] section . A zero length file name indicates a request to open the root of the share."};

    USHORT NameLength
        with Documentation
            {Description = "The length of the file name, in bytes. If no file name is provided, this field MUST be set to 0."};

    ULONG CreateContextsOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the first 8-byte aligned SMB2_CREATE_CONTEXT structure in the request. If no SMB2_CREATE_CONTEXTs are being sent, this value MUST be 0."};

    ULONG CreateContextsLength
        with Documentation
            {Description = "The length, in bytes, of the list of SMB2_CREATE_CONTEXT structures sent in this request."};

    SMB2CreateRequestBuffer[NameOffset, NameLength, CreateContextsOffset, CreateContextsLength] Buffer
        with Documentation
           {Description = "A variable-length buffer that contains the Unicode file name and create context list, as defined by NameOffset, NameLength, CreateContextsOffset, and CreateContextsLength. In the request, the Buffer field MUST be at least one byte in length. The file name(after DFS normalization if needed) MUST conform to the specification of a relative pathname in [MS-FSCC] section ."};
    
    override string ToString()
    {
        string summary = "Da(";
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00000001) > 0 ? "R" : "";     // FILE_READ_DATA (LIST_DIRECTORY)
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00000002) > 0 ? "W" : "";     // FILE_WRITE_DATA (ADD_FILE)
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00000004) > 0 ? "A" : "";     // FILE_APPEND_DATA (ADD_SUBDIRECTORY)
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00000008) > 0 ? "E" : "";     // FILE_READ_EA
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00000010) > 0 ? "e" : "";     // FILE_WRITE_eA
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00000020) > 0 ? "X" : "";     // FILE_EXECUTE (TRAVERSE)
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00000040) > 0 ? "C" : "";     // FILE_DELETE_CHILD
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00000080) > 0 ? "r" : "";     // FILE_rEAD_ATTRIBUTES
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00000100) > 0 ? "w" : "";     // FILE_wRITE_ATTRIBUTES
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00010000) > 0 ? "D" : "";     // DELETE
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00020000) > 0 ? "c" : "";     // READ_cONTROL
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00040000) > 0 ? "d" : "";     // WRITE_dAC
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00080000) > 0 ? "o" : "";     // WRITE_oWNER
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x00100000) > 0 ? "S" : "";     // SYNCHRONIZE
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x01000000) > 0 ? "s" : "";     // ACCESS_sYSTEM_sECURITY
        summary += (DesiredAccess.FilePipePrinterAccessMaskFlags & 0x02000000) > 0 ? "M" : "";     // MAXIMUM_ALLOWED
        summary += "), Sh(";
        summary += (ShareAccess & SMB2CreateRequestShareAccess.FileShareRead) > 0 ? "R" : "";
        summary += (ShareAccess & SMB2CreateRequestShareAccess.FileShareWrite) > 0 ? "W" : "";
        summary += (ShareAccess & SMB2CreateRequestShareAccess.FileShareDelete) > 0 ? "D" : "";
        summary += "), ";
        
        summary += "CreateOptions = " + Utility.DecToHexFormat(CreateOptions) + ", ";
        
        if (Buffer.CreateContextList != nothing)
        {
            var buffer = Buffer.CreateContextList as array<SMB2CreateContextRequest>;
            int count = buffer.Count;
            for(int i = 0; i < count; i++)
            {
                if (i != count - 1)
                {
                    summary += buffer[i].Buffer.ToString() + "+";
                }
                else
                {
                    summary += buffer[i].Buffer.ToString();
                }
            }
        }
        return summary;
    }
}
with Documentation
       {Description = "The SMB2 CREATE Request packet is sent by a client to request either creation of or access to a file. In case of a named pipe or printer, the server MUST create a new file."};

type SMB2CreateRequestBuffer[ushort NameOffset, ushort NameLength, uint CreateContextsOffset, uint CreateContextsLength]
{
    optional [|NameOffset > 120|] array<byte> NamePadding with BinaryEncoding{Length = NameOffset - 120 as uint};
    string Name with BinaryEncoding{Length = NameLength/2 as uint}; // UTF16
    optional [|CreateContextsOffset > NameLength + NameOffset|] array<byte> BufferPadding with BinaryEncoding{Length = CreateContextsOffset - NameLength - NameOffset as uint};
    optional [|CreateContextsLength > 0|] array<SMB2CreateContextRequest> CreateContextList
        where ValidationCheck(GetLastNext() == 0, null, DiagnosisLevel.Error, "SMB2: The Next field in the last entry of SMB2CreateContextRequest must be zero, not " + (GetLastNext() as string) + ".");
    
    uint GetLastNext()
    {
        if (CreateContextList != nothing)
        {
            var buffer = CreateContextList as array<SMB2CreateContextRequest>;
            if (buffer.Count > 0)
            {
                return buffer[buffer.Count - 1].Next;
            }
        }
        return 0;
    }
}

pattern SMB2CreateRequestCreateOptions = flags ULONG
{
    FileDirectoryFile = 0x00000001
        with Documentation
            {Description = "The file being created or opened is a directory file. With this flag, the CreateDisposition field MUST be set to FILE_CREATE, FILE_OPEN_IF, or FILE_OPEN. With this flag, only the following CreateOptions values are valid: FILE_WRITE_THROUGH, FILE_OPEN_FOR_BACKUP_INTENT, FILE_DELETE_ON_CLOSE, and FILE_OPEN_REPARSE_POINT. If the file being created or opened already exists and is not a directory file and FILE_CREATE is specified in the CreateDisposition field, then the server MUST fail the request with STATUS_OBJECT_NAME_COLLISION. If the file being created or opened already exists and is not a directory file and FILE_CREATE is not specified in the CreateDisposition field, then the server MUST fail the request with STATUS_NOT_A_DIRECTORY. The server MUST fail an invalid CreateDisposition field or an invalid combination of CreateOptions flags with STATUS_INVALID_PARAMETER."},
    FileWriteThrough = 0x00000002
        with Documentation
            {Description = "The server MUST propagate writes to this open to persistent storage before returning success to the client on write operations."},
    FileSequentialOnly = 0x00000004
        with Documentation
            {Description = "This indicates that the application intends to read or write at sequential offsets using this handle, so the server SHOULD optimize for sequential access. However, the server MUST accept any access pattern. This flag value is incompatible with the FILE_RANDOM_ACCESS value."},
    FileNoIntermediateBuffering = 0x00000008
        with Documentation
            {Description = "The server or underlying object store SHOULD NOT cache data at intermediate layers and SHOULD allow it to flow through to persistent storage."},
    FileSynchronousIoAlert = 0x00000010
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileSynchronousIoNonalert = 0x00000020
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileNonDirectoryFile = 0x00000040
        with Documentation
            {Description = "The file being opened MUST NOT be a directory file or the server MUST fail the request with STATUS_FILE_IS_A_DIRECTORY. This flag MUST NOT be used with FILE_DIRECTORY_FILE or the server MUST fail the request with STATUS_INVALID_PARAMETER."},
    FileCompleteIfOplocked = 0x00000100
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileNoEaKnowledge = 0x00000200
        with Documentation
            {Description = "The caller does not understand how to handle extended attributes. If the request includes an SMB2_CREATE_EA_BUFFER create context, then the server MUST fail this request with STATUS_ACCESS_DENIED. If extended attributes with the FILE_NEED_EA flag(see [MS-FSCC] section ) set are associated with the file being opened, then the server MUST fail this request with STATUS_ACCESS_DENIED."},
    FileRandomAccess = 0x00000800
        with Documentation
            {Description = "This indicates that the application intends to read or write at random offsets using this handle, so the server SHOULD optimize for random access. However, the server MUST accept any access pattern. This flag value is incompatible with the FILE_SEQUENTIAL_ONLY value. If both FILE_RANDOM_ACCESS and FILE_SEQUENTIAL_ONLY are set, then FILE_SEQUENTIAL_ONLY is ignored."},
    FileDeleteOnClose = 0x00001000
        with Documentation
            {Description = "The file MUST be automatically deleted when the last open request on this file is closed. When this option is set, the DesiredAccess field MUST include the DELETE flag. This option is often used for temporary files."},
    FileOpenByFileID = 0x00002000
        with Documentation
            {Description = "This bit SHOULD be set to 0 and the server MUST fail the request with a STATUS_NOT_SUPPORTED error if this bit is set.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileOpenForBackupIntent = 0x00004000
        with Documentation
            {Description = "The file is being opened for backup intent. That is, it is being opened or created for the purposes of either a backup or a restore operation. The server MAY check to ensure that the caller is capable of overriding whatever security checks have been placed on the file to allow a backup or restore operation to occur. The server MAY check for access rights to the file before checking the DesiredAccess field."},
    FileNoCompression = 0x00008000
        with Documentation 
            {Description = "The file cannot be compressed. This bit is ignored when FILE_DIRECTORY_FILE is set in CreateOptions."},
    FileOpenRemoteInstance = 0x00000400
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server."},
    FileOpenRequiringOplock = 0x00010000
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server."},
    FileDisallowExclusive = 0x00020000
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server."},
    FileReserveOpfilter = 0x00100000
        with Documentation
            {Description = "This bit SHOULD be set to 0 and the server MUST fail the request with a STATUS_NOT_SUPPORTED error if this bit is set.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileOpenReparsePoint = 0x00200000
        with Documentation
            {Description = "If the file or directory being opened is a reparse point, open the reparse point itself rather than the target that the reparse point references."},
    FileOpenNoRecall = 0x00400000
        with Documentation
            {Description = "In an HSM(Hierarchical Storage Management) environment, this flag means the file SHOULD NOT be recalled from tertiary storage such as tape. The recall can take several minutes. The caller can specify this flag to avoid those delays."},
    FileOpenForFreeSpaceQuery = 0x00800000
        with Documentation
            {Description = "Open file to query for free space. The client SHOULD set this to 0 and the server MUST ignore it.windows_vista and windows_server_2008-based clients will set this bit when it is requested by the application.windows_vista, windows_server_2008, and windows_7-based clients will set this bit when it is requested by the application."}
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2CreateRequestRequestedOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00
        with Documentation {Description = "No oplock is requested."},
    SMB2OplockLevelII = 0x01
        with Documentation {Description = "A level II oplock is requested."},
    SMB2OplockLevelExclusive = 0x08
        with Documentation {Description = "An exclusive oplock is requested."},
    SMB2OplockLevelBatch = 0x09
        with Documentation {Description = "A batch oplock is requested."},
    SMB2OplockLevelLease = 0xFF
        with Documentation
            {Description = "A lease is requested. If set, the request packet MUST contain an SMB2_CREATE_REQUEST_LEASE create context. This value is only valid for the SMB 2.1 dialect."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2CreateRequestImpersonationLevel = enum ULONG
{
    Anonymous = 0x00000000
        with Documentation
            {Description = "The application-requested impersonation level is Anonymous."},
    Identification = 0x00000001
        with Documentation
            {Description = "The application-requested impersonation level is Identification."},
    Impersonation = 0x00000002
        with Documentation
            {Description = "The application-requested impersonation level is Impersonation."},
    Delegate = 0x00000003
        with Documentation
            {Description = "The application-requested impersonation level is Delegate."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2CreateRequestShareAccess = flags ULONG
{
    FileShareRead = 0x00000001
         with Documentation
             {Description = "When set, indicates that other opens are allowed to read this file while this open is present. This bit MUST NOT be set for a named pipe or a printer file. Each open creates a new instance of a named pipe. Likewise, opening a printer file always creates a new file."},
    FileShareWrite = 0x00000002
         with Documentation
             {Description = "When set, indicates that other opens are allowed to write this file while this open is present. This bit MUST NOT be set for a named pipe or a printer file. Each open creates a new instance of a named pipe. Likewise, opening a printer file always creates a new file."},
    FileShareDelete = 0x00000004
         with Documentation
             {Description = "When set, indicates that other opens are allowed to delete or rename this file while this open is present. This bit MUST NOT be set for a named pipe or a printer file. Each open creates a new instance of a named pipe. Likewise, opening a printer file always creates a new file."},
}with Documentation {EmbeddedType = true};
 
pattern SMB2CreateRequestCreateDisposition = enum ULONG
{
    FileSupersede = 0x00000000
        with Documentation
            {Description = "If the file already exists, supersede it. Otherwise, create the file. This value SHOULD NOT be used for a printer object.When opening a printer object, windows-based servers ignore this value."},
    FileOpen = 0x00000001
        with Documentation
            {Description = "If the file already exists, return success; otherwise, fail the operation. MUST NOT be used for a printer object."},
    FileCreate = 0x00000002
        with Documentation
            {Description = "If the file already exists, fail the operation; otherwise, create the file."},
    FileOpenIf = 0x00000003
        with Documentation
            {Description = "Open the file if it already exists; otherwise, create the file. This value SHOULD NOT be used for a printer object.When opening a printer object, windows-based servers ignore this value."},
    FileOverWrite = 0x00000004
        with Documentation
            {Description = "Overwrite the file if it already exists; otherwise, fail the operation. MUST NOT be used for a printer object."},
    FileOverWriteIf = 0x00000005
        with Documentation
            {Description = "Overwrite the file if it already exists; otherwise, create the file. This value SHOULD NOT be used for a printer object.When opening a printer object, windows-based servers ignore this value."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.13.1.1   File_Pipe_Printer_Access_Mask
type FilePipePrinterAccessMask
{
    FilePipePrinterAccessMaskFilePipePrinterAccessMask FilePipePrinterAccessMaskFlags
        where ValidationCheck(InRange<FilePipePrinterAccessMaskFilePipePrinterAccessMask>(value), null, 
            "SMB2: The FilePipePrinterAccessMaskFlags field in type FilePipePrinterAccessMask has one or more undefined bits. Please refer to File_Pipe_Printer_Access_Mask in Technical Document MS-SMB2.")  
        with Documentation
            {Description = "For a file, pipe, or printer, the value MUST be constructed using the following values(for a printer, the value MUST have at least one of the following: FILE_WRITE_DATA, FILE_APPEND_DATA, or GENERIC_WRITE)."};
}
with Documentation
       {Description = "The following SMB2 Access Mask flag values can be used when accessing a file, pipe or printer."};

// 2.2.13.1.2   Directory_Access_Mask
type DirectoryAccessMask
{
    DirectoryAccessMaskDirectoryAccessMask DirectoryAccessMaskValue
        with Documentation
            {Description = "For a directory, the value MUST be constructed using the following values:"};
}
with Documentation
       {Description = "The following SMB2 Access Mask flag values can be used when accessing a directory."};

pattern FilePipePrinterAccessMaskFilePipePrinterAccessMask = flags ULONG
{
    FileReadData = 0x00000001
        with Documentation
            {Description = "This value indicates the right to read data from the file or named pipe."},
    FileWriteData = 0x00000002
        with Documentation
            {Description = "This value indicates the right to write data into the file or named pipe beyond the end of the file."},
    FileAppendData = 0x00000004
        with Documentation
            {Description = "This value indicates the right to append data into the file or named pipe."},
    FileReadEa = 0x00000008
        with Documentation
            {Description = "This value indicates the right to read the extended attributes of the file or named pipe."},
    FileWriteEa = 0x00000010
        with Documentation
            {Description = "This value indicates the right to write or change the extended attributes to the file or named pipe."},
    FileExecute = 0x00000020
        with Documentation
            {Description = "This value indicates the right to execute the file."},
    FileDeleteChild = 0x00000040
        with Documentation
            {Description = "This value indicates the right to delete entries within a directory."},
    FileReadAttributes = 0x00000080
        with Documentation
            {Description = "This value indicates the right to read the attributes of the file."},
    FileWriteAttributes = 0x00000100
        with Documentation
            {Description = "This value indicates the right to change the attributes of the file."},
    Delete = 0x00010000
        with Documentation
            {Description = "This value indicates the right to delete the file."},
    ReadControl = 0x00020000
        with Documentation
            {Description = "This value indicates the right to read the security descriptor for the file or named pipe."},
    WriteDac = 0x00040000
        with Documentation
            {Description = "This value indicates the right to change the discretionary access control list(DACL) in the security descriptor for the file or named pipe. For the DACL data structure, see ACL in [MS-DTYP]."},
    WriteOwner = 0x00080000
        with Documentation
            {Description = "This value indicates the right to change the owner in the security descriptor for the file or named pipe."},
    Synchronize = 0x00100000
        with Documentation
            {Description = "SMB2 clients set this flag to any value.windows sets this flag to the value passed in by the higher-level application."},
    AccessSystemSecurity = 0x01000000
        with Documentation
            {Description = "This value indicates the right to read or change the system access control list(SACL) in the security descriptor for the file or named pipe. For the SACL data structure, see ACL in [MS-DTYP].windows fails the create request with STATUS_ACCESS_DENIED if the caller does not have the SeSecurityPrivilege, as specified in [MS-LSAD] section ."},
    MaximumAllowed = 0x02000000
        with Documentation
            {Description = "This value indicates that the client is requesting an open to the file with the highest level of access the client has on this file. If no access is granted for the client on this file, the server MUST fail the open with STATUS_ACCESS_DENIED."},
    GenericAll = 0x10000000
        with Documentation
            {Description = "This value indicates a request for all the access flags that are previously listed except MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY."},
    GenericExecute = 0x20000000
        with Documentation
            {Description = "This value indicates a request for the following combination of access flags listed above: FILE_READ_ATTRIBUTES| FILE_EXECUTE| SyncHRONIZE| READ_CONTROL."},
    GenericWrite = 0x40000000
        with Documentation
            {Description = "This value indicates a request for the following combination of access flags listed above: FILE_WRITE_DATA| FILE_APPEND_DATA| FILE_WRITE_ATTRIBUTES| FILE_WRITE_EA| SyncHRONIZE| READ_CONTROL."},
    GenericRead = 0x80000000
        with Documentation
            {Description = "This value indicates a request for the following combination of access flags listed above: FILE_READ_DATA| FILE_READ_ATTRIBUTES| FILE_READ_EA| SyncHRONIZE| READ_CONTROL."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.13.2   SMB2_CREATE_CONTEXT Request Values
type SMB2CreateContextRequest
{
    ULONG Next
        with Documentation
            {Description = "The offset from the beginning of this create context to the beginning of a subsequent 8-byte aligned create context. This field MUST be set to 0 if there are no subsequent contexts."};

    USHORT NameOffset
        with Documentation
            {Description = "The offset from the beginning of this structure to its 8-byte aligned name value. The name is represented as four or more ASCII characters and MUST be one of the values provided in the following table. The structure name indicates what information is encoded by the data payload. The following values are the valid create context values. The names are case-sensitive. More details are provided for each of these values in the following subsections."};

    USHORT NameLength
        with Documentation
            {Description = "The length, in bytes, of the create context name."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateContextRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. This value MUST be set to 0 by the client, and ignored by the server."};

    USHORT DataOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of this structure to the 8-byte aligned data payload. If DataLength is 0, the client SHOULD set this value to 0 and the server MUST ignore it on receipt.If DataLength is 0, windows-based clients set this field to any value."};

    ULONG DataLength
        with Documentation
            {Description = "The length, in bytes, of the data. The format of the data is determined by the type of SMB2_CREATE_CONTEXT request, as outlined in the following sections. The type is indicated in the NameOffset field in the message."};

    SMB2CreateContextRequestBuffer[NameOffset, NameLength, DataOffset, DataLength] Buffer
      with Documentation
             {Description = "A variable-length buffer that contains the name and data fields, as defined by NameOffset, NameLength, DataOffset, and DataLength."};

    optional [|Next > CreateContextLength()|] array<byte> TrailPadding with BinaryEncoding{Length = Next - CreateContextLength() as uint};
    
    uint CreateContextLength()
    {
        if (DataOffset == 0)
        {
            return (NameOffset + NameLength) as uint;
        }
        return (DataLength + DataOffset) as uint;
    }
    
    override string ToString()
    {
        return Buffer.ToString();
    }
}
with Documentation
       {Description = "The SMB2_CREATE_CONTEXT structure is used by the SMB2 CREATE Request and the SMB2 CREATE Response to encode additional flags and attributes: in requests to specify how the CREATE request MUST be processed, and in responses to specify how the CREATE request was in fact processed."};
       
type SMB2CreateContextRequestBuffer[ushort NameOffset, ushort NameLength, ushort DataOffset, uint DataLength]
{
    optional [|NameOffset > 16|] array<byte> NamePadding with BinaryEncoding{Length = NameOffset - 16 as uint};

    ([|NameLength == 16|] guid | string) Name 
        where ValidationCheck((value is SMB2CreateContextRequestValuesName
                            || value is ${6AA6BC45-A7EF-4AF7-9008-FA462E144D74}
                            || value is ${9ecfcb9c-c104-43e6-980e-158da1f6ec83}
                            || (value.ToString()) == ""), null, DiagnosisLevel.Error,
                            "SMB2: The Name field in type SMB2CreateContextRequestBuffer must be one of the values provided in pattern SMB2CreateContextRequestValuesName.") 
        with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = NameLength as uint};
    
    optional [|DataOffset > NameOffset + NameLength|] array<byte> DataPadding with BinaryEncoding{Length = DataOffset - NameOffset - NameLength as uint};
    
    ([|DataLength == 0|] Empty
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateEaBuffer|] FileFullEaInformation
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateSdBuffer|] SECURITY_DESCRIPTOR_NonRpc
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleRequest|] SMB2CreateDurableHandleRequest
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleRequestV2|] SMB2CreateDurableHandleRequestV2
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleReconnect|] SMB2CreateDurableHandleReconnect
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleReconnectV2|] SMB2CreateDurableHandleReconnectV2
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateQueryMaximalAccessRequest|] SMB2CreateQueryMaximalAccessRequest
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateAllocationSize|] SMB2CreateAllocationSize
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateTimewarpToken|] SMB2CreateTimewarpToken
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateRequestLease && DataLength == 32|] SMB2CreateRequestLease
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateRequestLease && DataLength >= 52|] SMB2CreateRequestLeaseV2
     | [|Name is {6AA6BC45-A7EF-4AF7-9008-FA462E144D74}|] SMB2CreateAppInstanceId
     | [|Name is {9ecfcb9c-c104-43e6-980e-158da1f6ec83}|] SVHDX_OPEN_DEVICE_CONTEXT
     | binary) Data with BinaryEncoding{Length = DataLength};
     
     // Future Reference: Remove this and use with BinaryEncoding{ComposedTypeWidth = DataLength * 8}
     optional [|Name is SMB2CreateContextRequestValuesName.SMB2CreateEaBuffer|] array<byte> TrailPadding with BinaryEncoding{Length = DataLength - (Data as FileFullEaInformation).Length() as uint};
     
     override string ToString()
     {
         string summary = "";
         if (Name is {6AA6BC45-A7EF-4AF7-9008-FA462E144D74})
         {
             summary += "AppInstance";
         }
         else
         {
             summary += Name as string;
         }
         switch(Data)
         {
             case dh2q:SMB2CreateDurableHandleRequestV2 =>
                summary += (dh2q.Flags & 0x00000002) > 0 ? "(P)" : "";
             case dh2c:SMB2CreateDurableHandleReconnectV2 =>
                summary += (dh2c.Flags & 0x00000002) > 0 ? "(P)" : "";
             case rqls:SMB2CreateRequestLease =>
                summary += "(" + SMB2LeaseStateToText(rqls.LeaseState) + ")";
             case rqls2:SMB2CreateRequestLeaseV2 =>
                summary += "(" + SMB2LeaseStateToText(rqls2.LeaseState);
                summary += (rqls2.Flags & 0x00000002) > 0 ? "-PK)" : ")";
         }
         return summary;
     }
}
     
pattern SMB2CreateContextRequestValuesName = enum string
{
    SMB2CreateEaBuffer = "ExtA"
        with Documentation
            {Description = "The data contains the extended attributes that MUST be stored on the created file."},
    SMB2CreateSdBuffer = "SecD"
        with Documentation
            {Description = "The data contains a security descriptor that MUST be stored on the created file."},
    SMB2CreateDurableHandleRequest = "DHnQ"
        with Documentation
            {Description = "The client is requesting the open to be durable(see section )."},
    SMB2CreateDurableHandleReconnect = "DHnC"
        with Documentation
            {Description = "The client is requesting to reconnect to a durable open after being disconnected(see section )."},
    SMB2CreateAllocationSize = "AlSi"
        with Documentation
            {Description = "The data contains the required allocation size of the newly created file."},
    SMB2CreateQueryMaximalAccessRequest = "MxAc"
        with Documentation
            {Description = "The client is requesting that the server return maximal access information."},
    SMB2CreateTimewarpToken = "TWrp"
        with Documentation
            {Description = "The client is requesting that the server open an earlier version of the file with the provided time stamp."},
    SMB2CreateQueryOnDiskId = "QFid"
        with Documentation
            {Description = "The client is requesting that the server return a 32-byte opaque blob that uniquely identifies the file being opened on disk. No data is passed to the server by the client."},
    SMB2CreateRequestLease = "RqLs"
        with Documentation
            {Description = "The client is requesting that the server return a lease. This value is only supported for the SMB 2.1 dialect."},
    SMB2CreateDurableHandleRequestV2 = "DH2Q"
        with Documentation
            {Description = "The client is requesting the open to be durable. This value is only supported for the SMB 3.x dialect family"},
    SMB2CreateDurableHandleReconnectV2 = "DH2C"
        with Documentation
            {Description = "The client is requesting to reconnect to a durable open after being disconnected. This value is only supported for the SMB 3.x dialect family"},
} with Documentation {EmbeddedType = true};

// 2.2.13.2.3   SMB2_CREATE_DURABLE_HANDLE_REQUEST
type SMB2CreateDurableHandleRequest
{
    binary DurableRequest where ValidationCheckReservedZero(value == $[00000000000000000000000000000000], null, true,  ReferenceType.Type, "SMB2", "DurableRequest", "SMB2CreateDurableHandleRequest", value.ToString()) with BinaryEncoding{Length = 16},
        Documentation
            {Description = "A 16-byte field that MUST NOT be used and MUST be reserved. This value MUST be set to 0 by the client and ignored by the server."};
}
with Documentation
       {Description = "When requesting a durable open, the client SHOULD also request a batch oplock(by setting RequestedOplockLevel to SMB2_OPLOCK_LEVEL_BATCH) or a handle caching lease(by using an SMB2_CREATE_REQUEST_LEASE Create Context with a LeaseState that includes SMB2_LEASE_HANDLE_CACHING). The server MUST ignore this Create Context if neither a batch oplock nor a handle caching lease is requested and granted. The format of the Data in the Buffer field of this SMB2_CREATE_CONTEXT MUST be as follows."};

// 2.2.13.2.4   SMB2_CREATE_DURABLE_HANDLE_RECONNECT
type SMB2CreateDurableHandleReconnect
{
    SMB2Fileid Data
        with Documentation
            {Description = "An SMB2Fileid structure, as specified in section , for the open that is being reestablished."};
}
with Documentation
       {Description = "The SMB2 CREATE_DURABLE_HANDLE_RECONNECT context is specified when the client is attempting to reestablish a durable open as specified in section ."};

// 2.2.13.2.5   SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST
type SMB2CreateQueryMaximalAccessRequest
{
    FILETIME Timestamp
        with Documentation
            {Description = "A time stamp in the FILETIME format, as specified in [MS-DTYP] section ."};
}
with Documentation
       {Description = "The SMB2 CREATE_QUERY_MAXIMAL_ACCESS_REQUEST context is specified on an SMB2 CREATE Request when the client is requesting the server to retrieve maximal access information as part of processing the open. The Data in the Buffer field of the SMB2_CREATE_CONTEXT MUST either contain the following structure or be empty(0 bytes in length)."};

// 2.2.13.2.6   SMB2_CREATE_ALLOCATION_SIZE
type SMB2CreateAllocationSize
{
    UINT64 AllocationSize
        with Documentation
            {Description = "The size, in bytes, that the newly created file MUST have reserved on disk."};
}
with Documentation
       {Description = "The SMB2 CREATE_ALLOCATION_SIZE context is specified on an SMB2 CREATE Request(section ) when the client is setting the allocation size of a file that is being newly created or overwritten. The Data in the Buffer field of the SMB2_CREATE_CONTEXT MUST be as follows."};

// 2.2.13.2.7   SMB2_CREATE_TIMEWARP_TOKEN
type SMB2CreateTimewarpToken
{
    FILETIME Timestamp
        with Documentation
            {Description = "The time stamp of the version of the file to be opened, in FILETIME format as specified in [MS-DTYP] section . If no version of this file exists at this time stamp, the operation MUST be failed."};
}
with Documentation
       {Description = "The SMB2_CREATE_TIMEWARP_TOKEN context is specified on an SMB2 CREATE Request(section ) when the client is requesting the server to open a version of the file at a previous point in time. The Data in the Buffer field of the SMB2_CREATE_CONTEXT MUST contain the following structure."};

pattern SMB2CreateRequestLeaseLeaseState = flags ULONG
{
   SMB2LeaseNone = 0x00
       with Documentation {Description = "No lease is requested."},
   SMB2LeaseReadCaching = 0x01
       with Documentation {Description = "A read caching lease is requested."},
   SMB2LeaseHandleCaching = 0x02
       with Documentation {Description = "A handle caching lease is requested."},
   SMB2LeaseWriteCaching = 0x04
       with Documentation {Description = "A write caching lease is requested."},
} with Documentation {EmbeddedType = true};

// 2.2.13.2.8   SMB2_CREATE_REQUEST_LEASE
type SMB2CreateRequestLease
{
    GUID LeaseKey
        with Documentation
                {Description = "A unique key that identifies the owner of the lease."};

    SMB2CreateRequestLeaseLeaseState LeaseState
        with Documentation
            {Description = "The requested lease state. This field MUST be constructed as a combination of the following values.windows_7 and windows_server_7 as SMB server support the following combinations of values: 0, READ, READ | WRITE, READ | HANDLE, READ | WRITE | HANDLE. windows_7 and windows_server_7 clients restrict requests accordingly."};

    ULONG LeaseFlags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseFlags", "SMB2CreateRequestLease", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    UINT64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2CreateRequestLease", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2_CREATE_REQUEST_LEASE context is specified on an SMB2 CREATE Request packet when the client is requesting the server to return a lease. This is only valid for the SMB 2.1 dialect. The Data in the Buffer field of the SMB2_CREATE_CONTEXT structure MUST contain the following structure."};

// 2.2.13.2.10   SMB2_CREATE_REQUEST_LEASE_V2
type SMB2CreateRequestLeaseV2
{
    GUID LeaseKey
        with Documentation
                {Description = "A unique key that identifies the owner of the lease."};

    SMB2CreateRequestLeaseV2LeaseState LeaseState
        with Documentation
            {Description = "The requested lease state. This field MUST be constructed as a combination of the following values.windows_7 and windows_server_7 as SMB server support the following combinations of values: 0, READ, READ | WRITE, READ | HANDLE, READ | WRITE | HANDLE. windows_7 and windows_server_7 clients restrict requests accordingly."};

    SMB2CreateRequestLeaseV2Flags Flags
        with Documentation
            {Description = "This field MUST be set as a combination of the following values."};

    UINT64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2CreateRequestLeaseV2", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    GUID ParentLeaseKey 
        with Documentation
            {Description = "A unique key that identifies the owner of the lease for the parent directory."};

    USHORT Epoch
        with Documentation
            {Description = "A 16-bit unsigned integer incremented by the server on a lease state change."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateRequestLeaseV2", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
        
}
with Documentation
       {Description = "The SMB2_CREATE_REQUEST_LEASE_V2 context is specified on an SMB2 CREATE Request when the client is requesting the server to return a lease on a file or a directory. This is only valid for the SMB 3.x dialect family. The data in the Buffer field of the SMB2_CREATE_CONTEXT (section 2.2.13.2) structure MUST contain the following structure."};

pattern SMB2CreateRequestLeaseV2LeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x00000001
        with Documentation
            {Description = "A read caching lease is requested."},
    SMB2LeaseHandleCaching = 0x00000002
        with Documentation
            {Description = "A handle caching lease is requested."},
    SMB2LeaseWriteCaching = 0x00000004
        with Documentation
            {Description = "A write caching lease is requested."}
} with Documentation {EmbeddedType = true};

pattern SMB2CreateRequestLeaseV2Flags = flags ULONG
{
    SMB2LeaseFlagParentLeaseKeySet = 0x00000004
        with Documentation
            {Description = "When set, indicates that the ParentLeaseKey is set."}
} with Documentation {EmbeddedType = true};

// 2.2.13.2.11   SMB2_CREATE_DURABLE_HANDLE_REQUEST_V2
type SMB2CreateDurableHandleRequestV2
{
    ULONG Timeout
        with Documentation
            {Description = "The time, in milliseconds, for which the server reserves the handle after a failover, waiting for the client to reconnect. To let the server use a default timeout value, the client MUST set this field to 0."};
    
    SMB2CreateDurableHandleRequestV2Flags Flags
        with Documentation
            {Description = "This field MUST be constructed by using zero or more of the following values."};
    
    UINT64 Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateDurableHandleRequestV2", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    // WORKAROUND: BUG35565 - Can't use "CreateGuid" to name a guid field, compile error occurs in cs file
    GUID Create_Guid
        with Documentation
            {Description = "A GUID that identifies the create request."};
}
with Documentation
        {Description = "The SMB2_CREATE_DURABLE_HANDLE_REQUEST_V2 packet is only valid for the SMB 3.x dialect family. When requesting a durable open, the client SHOULD also request a batch oplock (by setting RequestedOplockLevel to SMB2_OPLOCK_LEVEL_BATCH) or a handle caching lease (by using an SMB2_CREATE_REQUEST_LEASE or SMB2_CREATE_REQUEST_LEASE_V2 Create Context with a LeaseState that includes SMB2_LEASE_HANDLE_CACHING). The server MUST ignore this Create Context if neither a batch oplock nor a handle caching lease is requested and granted."};

pattern SMB2CreateDurableHandleRequestV2Flags = flags ULONG
{
    SMB2DhandleFlagPersistent = 0x00000002
        with Documentation
            {Description = "A persistent handle is requested."}
} with Documentation {EmbeddedType = true};

// 2.2.13.2.12   SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2
type SMB2CreateDurableHandleReconnectV2
{
    SMB2Fileid FileId
        with Documentation
            {Description = "An SMB2_FILEID structure, as specified in section 2.2.14.1, for the open that is being reestablished."};

    // WORKAROUND: BUG35565 - Can't use "CreateGuid" to name a guid field, compile error occurs in cs file
    GUID Create_Guid
        with Documentation
            {Description = "A unique ID that identifies the create request."};

    SMB2CreateDurableHandleReconnectV2Flags Flags
        with Documentation
            {Description = "This field MUST be constructed using zero or more of the following values"};
}
with Documentation
        {Description = "The SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 context is specified when the client is attempting to reestablish a durable open as specified in section 3.2.4.4. The SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 packet is only valid for the SMB 3.x dialect family."};

pattern SMB2CreateDurableHandleReconnectV2Flags = flags ULONG
{
    SMB2DhandleFlagPersistent = 0x00000002
        with Documentation
            {Description = "A persistent handle is requested."}
} with Documentation {EmbeddedType = true};

// 2.2.13.2.13   SMB2_CREATE_APP_INSTANCE_ID
type SMB2CreateAppInstanceId
{
    USHORT StructureSize where ValidationCheckValue(value == 20, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CreateAppInstanceId", 20, value)
        with Documentation
            {Description = "The client MUST set this field to 20, indicating the size of this structure."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateAppInstanceId", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. This field MUST be set to zero."};

    GUID AppInstanceId
        with Documentation
            {Description = "A unique ID that identifies an application instance."};
}
with Documentation
        {Description = "The SMB2_CREATE_APP_INSTANCE_ID context is specified on an SMB2 CREATE Request when the client is supplying an identifier provided by an application. The SMB2_CREATE_APP_INSTANCE_ID packet is only valid for the SMB 3.x dialect family. The client SHOULD also request a durable handle by using an SMB2_CREATE_DURABLE_HANDLE_REQUEST_V2 or SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 Create Context."};

// 2.2.14   SMB2 CREATE Response
type SMB2CreateResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 89, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CreateResponse", 89, value)
        with Documentation
            {Description = "The server MUST set this field to 89, indicating the size of the request structure, not including the header. The server MUST set this field to this value regardless of how long Buffer[] actually is in the request being sent."};

    SMB2CreateResponseOplockLevel OplockLevel
        where ValidationCheck(InRange<SMB2CreateResponseOplockLevel>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "OplockLevel", COMMON_STR_TYPE, "SMB2CreateResponse", COMMON_STR_MUST, "0x00, 0x01, 0x08, 0x09, 0xFF", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The oplock level that is granted to the client for this open. This field MUST contain one of the following values.windows-based clients never use exclusive oplocks. Because there are no situations where it would require an exclusive oplock where it would not also require an SMB2_OPLOCK_LEVEL_BATCH, it always requests an SMB2_OPLOCK_LEVEL_BATCH."};

    SMB2CreateResponseFlags Flags
        with Documentation
            {Description = "If the server implements the SMB 3.x dialect family, this field MUST be constructed using the following value. Otherwise, this field MUST NOT be used and MUST be reserved."};

    SMB2CreateResponseCreateAction CreateAction
        where ValidationCheck(InRange<SMB2CreateResponseCreateAction>(value), null, DiagnosisLevel.Error, 
            () => Format(COMMON_STR_CHECK_VALUE_IN_RANGE, ["SMB2", "CreateAction", COMMON_STR_TYPE, "SMB2CreateResponse", COMMON_STR_MUST, "0x00000000", "0x00000003", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The action taken in establishing the open. This field MUST contain one of the following values.windows-based SMB2 servers always return FILE_OPENED for pipes with successful opens."};

    FILETIME CreationTime
        with Documentation
            {Description = "The time when the file was created; in FILETIME format as specified in [MS-DTYP] section ."};

    FILETIME LastAccessTime
        with Documentation
            {Description = "The time the file was last accessed; in FILETIME format as specified in [MS-DTYP] section ."};

    FILETIME LastWriteTime
        with Documentation
            {Description = "The time when data was last written to the file; in FILETIME format as specified in [MS-DTYP] section ."};

    FILETIME ChangeTime
        with Documentation
            {Description = "The time when the file was last modified; in FILETIME format as specified in [MS-DTYP] section ."};

    LARGE_INTEGER AllocationSize
        with Documentation
            {Description = "The size, in bytes, of the data that is allocated to the file."};

    LARGE_INTEGER EndofFile
        with Documentation {Description = "The size, in bytes, of the file."};

    FileAttributes FileAttributes
        with Documentation
            {Description = "The attributes of the file. The valid flags are as specified in [MS-FSCC] section ."};

    ULONG Reserved2
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server SHOULD set this to 0, and the client MUST ignore it on receipt.windows-based SMB2 servers may set this field to any value."};

    SMB2Fileid FileId
        with Documentation {Description = "An SMB2Fileid, as specified in section ."};

    ULONG CreateContextsOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the first 8-byte aligned SMB2_CREATE_CONTEXT response that is contained in this response. If none are being returned in the response, this value MUST be 0. These values are specified in section ."};

    ULONG CreateContextsLength
        with Documentation
            {Description = "The length, in bytes, of the list of SMB2_CREATE_CONTEXT response structures that are contained in this response."};
    
    optional [|CreateContextsOffset > 152|] array<byte> BufferPadding with BinaryEncoding{Length = CreateContextsOffset - 152 as uint};
    optional [|CreateContextsLength > 0|] array<SMB2CreateContextResponse> Buffer
        where ValidationCheck(GetLastNext() == 0, null, DiagnosisLevel.Error, "SMB2: The Next field of the last entry of SMB2CreateContextResponse must be zero, not " + (GetLastNext() as string) + ".")
        with Documentation
            {Description = "A variable-length buffer that contains the list of create contexts that are contained in this response, as described by CreateContextsOffset and CreateContextsLength. This takes the form of a list of SMB2 CREATE_CONTEXT Response Values, as specified in section ."};
    
    uint GetLastNext()
    {
        if (Buffer != nothing)
        {
            var buffer = Buffer as array<SMB2CreateContextResponse>;
            if (buffer.Count > 0)
            {
                return buffer[buffer.Count - 1].Next;
            }
        }
        return 0;
    }
        
    override string ToString()
    {
        string summary = "";
        if (Buffer != nothing)
        {
            var buffer = Buffer as array<SMB2CreateContextResponse>;
            int count = buffer.Count;
            for(int i = 0; i < count; i++)
            {
                if (i != count - 1)
                {
                    summary += buffer[i].Buffer.ToString() + "+";
                }
                else
                {
                    summary += buffer[i].Buffer.ToString();
                }
            }
        }
        return summary;
    }
}
with Documentation
       {Description = "The SMB2 CREATE Response packet is sent by the server to notify the client of the status of its SMB2 CREATE Request. This response is composed of an SMB2 header, as specified in section , followed by this response structure."};

pattern SMB2CreateResponseFlags = flags BYTE
{
    SMB2CreateFlagReparsepoint = 0x01
        with Documentation
            {Description = "When set, indicates the last portion of the file path is a reparse point."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.14.1   SMB2_FILEID
type SMB2Fileid
{
    UINT64 Persistent
        with Documentation
                {Description = "A file handle that remains persistent when an open is reconnected after being lost on a disconnect, as specified in section . The server MUST return this file handle as part of an SMB2 CREATE Response "};

    UINT64 Volatile
        with Documentation
                {Description = "A file handle that MAY be changed when an open is reconnected after being lost on a disconnect, as specified in section . The server MUST return this file handle as part of an SMB2 CREATE Response. This value MUST NOT change unless a reconnection is performed. This value MUST be unique for all volatile handles on the SMB2 transport connection."};

    override string ToString()
    {
        return "Persistent = " + Utility.DecToHexFormat(Persistent) + ", Volatile = " + Utility.DecToHexFormat(Volatile);
    }
}
with Documentation
       {Description = "The SMB2 FILEID is used to represent an open to a file."};

// 2.2.14.2   SMB2_CREATE_CONTEXT Response Values
type SMB2CreateContextResponse
{
    ULONG Next;
    USHORT NameOffset;
    USHORT NameLength;
    USHORT Reserved;
    USHORT DataOffset;
    ULONG DataLength;
    SMB2CreateContextResponseBuffer[NameOffset, NameLength, DataOffset, DataLength] Buffer;
    optional [|Next > DataOffset + DataLength|] array<byte> TrailPadding with BinaryEncoding{Length = Next - DataOffset - DataLength as uint};
    
    override string ToString()
    {
        return Buffer.ToString();
    }
} with Documentation
       {Description = "The SMB2_CREATE_CONTEXT Response Values MUST take the same form as specified in section 2.2.13.2. The individual values that are contained in the data buffer of the create context responses varies, based on the name of the create context in the request. For each well-known name that is specified in the definition of the NameOffset field in section 2.2.13, representing a type of SMB2_CREATE_CONTEXT Request Values, the format of the response is provided below."};

type SMB2CreateContextResponseBuffer[ushort NameOffset, ushort NameLength, ushort DataOffset, uint DataLength]
{
    optional [|NameOffset > 1|] array<byte> NamePadding with BinaryEncoding{Length = NameOffset - 16 as uint};
    string Name where ValidationCheck(value == "" || value is SMB2CreateContextRequestValuesName, null, @"SMB2: The Name field in type SMB2CreateContextResponseBuffer is an undefined value. Please refer to SMB2_CREATE_CONTEXT Response Values in Technical Document MS-SMB2.")
        with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = NameLength as uint};
    optional [|DataOffset > NameOffset + NameLength|] array<byte> BufferPadding with BinaryEncoding{Length = DataOffset - NameOffset - NameLength as uint};
    
    ([|DataLength == 0|] Empty
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleRequest|] SMB2CreateDurableHandleResponse
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleRequestV2|] SMB2CreateDurableHandleResponseV2
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateRequestLease && DataLength == 32|] SMB2CreateResponseLease
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateRequestLease && DataLength >= 52|] SMB2CreateResponseLeaseV2
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateQueryMaximalAccessRequest|] SMB2CreateQueryMaximalAccessResponse
     | [|Name is SMB2CreateContextRequestValuesName.SMB2CreateQueryOnDiskId|] SMB2CreateQueryOnDiskId
     | binary) Data with BinaryEncoding{Length = DataLength};
    
    override string ToString()
    {
        string summary = Name as string;
        switch(Data)
        {
            case dh2q:SMB2CreateDurableHandleResponseV2 =>
                summary += (dh2q.Flags & 0x00000002) > 0 ? "(P)" : "";
            case rqls:SMB2CreateResponseLease =>
                summary += "(" + SMB2LeaseStateToText(rqls.LeaseState) + ")";
            case rqls2:SMB2CreateResponseLeaseV2 =>
                summary += "(" + SMB2LeaseStateToText(rqls2.LeaseState);
                summary += (rqls2.Flags & 0x00000002) > 0 ? "-PK)" : ")";
        }
        return summary;
    }
}

// 2.2.14.2.3   SMB2_CREATE_DURABLE_HANDLE_RESPONSE
type SMB2CreateDurableHandleResponse
{
    UINT64 Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateDurableHandleResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore the value on receipt."};
}
with Documentation
       {Description = "If the server succeeds in opening a durable handle to a file as requested by the client via the SMB2_CREATE_DURABLE_HANDLE_REQUEST(section ), it MUST send an SMB2 CREATE_DURABLE_HANDLE_RESPONSE back to the client to inform the client that the handle is durable."};

// 2.2.14.2.5   SMB2_CREATE_QUERY_MAXIMAL_ACCESS_RESPONSE
type SMB2CreateQueryMaximalAccessResponse
{
    NTSTATUS QueryStatus
        with Documentation
            {Description = "The resulting status code of the attempt to query maximal access. The MaximalAccess field is valid only if QueryStatus is STATUS_SUCCESS. The status code MUST be one of those defined in [MS-ERREF] section ."};

    FilePipePrinterAccessMask MaximalAccess
        with Documentation
            {Description = "The maximal access that the user who is described by SessionId has on the file or named pipe that was opened. This is an access mask value, as specified in section ."};
}
with Documentation
       {Description = "The SMB2 CREATE_QUERY_MAXIMAL_ACCESS_RESPONSE returns an SMB2_CREATE_CONTEXT in the response with the Name that is identified by SMB2_CREATE_QUERY_MAXIMAL ACCESS as specified in SMB2_CREATE_CONTEXT Request Values(section ), if the server attempts to query maximal access as part of processing a create request."};

// 2.2.14.2.9   SMB2_CREATE_QUERY_ON_DISK_ID
type SMB2CreateQueryOnDiskId
{
    UINT64 DiskFileId
        with Documentation
            {Description = "An 8-byte value that the client can use to identify the open file"};

    UINT64 VolumeId
        with Documentation
            {Description = "An 8-byte value that the client can use to identify the volume within which the file is opened"};
            
    binary Reserved where ValidationCheckZero(value == $[00000000000000000000000000000000], null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateQueryOnDiskId", value)
        with BinaryEncoding{Length = 16},
            Documentation
                {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The server responds with a 32-byte structure that the client can use to identify the open file in a volume. The SMB2_CREATE_QUERY_ON_DISK_ID returns an SMB2_CREATE_CONTEXT in the response with the Name that is identified by SMB2_CREATE_QUERY_ON_DISK_ID as specified in section ."};

pattern SMB2CreateResponseLeaseLeaseState = flags ULONG
{
    SMB2LeaseNone = 0x00
        with Documentation {Description = "No lease is granted."},
    SMB2LeaseReadCaching = 0x01
        with Documentation {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x02
        with Documentation {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x04
        with Documentation {Description = "A write caching lease is granted."}
} with Documentation {EmbeddedType = true};

pattern SMB2CreateResponseLeaseLeaseFlags = enum ULONG
{
    SMB2LeaseFlagBreakInProgress = 0x02
        with Documentation
            {Description = "A break for the lease identified by the lease key is in progress."}
} with Documentation {EmbeddedType = true};

// 2.2.14.2.10   SMB2_CREATE_RESPONSE_LEASE
type SMB2CreateResponseLease
{
    GUID LeaseKey
        with Documentation
                {Description = "A unique key that identifies the owner of the lease."};

    SMB2CreateResponseLeaseLeaseState LeaseState
        with Documentation
            {Description = "The granted lease state. This field MUST be constructed using the following values."};

    ULONG LeaseFlags where ValidationCheck(value == 0 || value is SMB2CreateResponseLeaseLeaseFlags, null, DiagnosisLevel.Error, 
        () => "SMB2: The LeaseFlags field in type SMB2CreateResponseLease must be set to zero or 0x02, not " + Utility.DecToHexFormat(2, value) + ".")
        with Documentation
            {Description = "This field MUST be set to zero or more of the following values."};

    ULONG64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2CreateResponseLease", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The server responds with a lease that is granted for this open. The data in the Buffer field of the SMB2_CREATE_CONTEXT structure MUST contain the following structure."};

// 2.2.14.2.11   SMB2_CREATE_RESPONSE_LEASE_V2
type SMB2CreateResponseLeaseV2
{
    GUID LeaseKey
        with Documentation
                {Description = "A unique key that identifies the owner of the lease."};

    SMB2CreateResponseLeaseV2LeaseState LeaseState
        with Documentation
            {Description = "The granted lease state. This field MUST be constructed using the following values."};

    ULONG Flags where ValidationCheck(value == 0 || value is SMB2CreateResponseLeaseV2Flags, null, DiagnosisLevel.Error, 
        () => "SMB2: The Flags field in type SMB2CreateResponseLeaseV2 must be set to zero or one of 0x00000002, 0x00000004 if the server implements SMB 2.1, not " + Utility.DecToHexFormat(8, value) + ".")
        with Documentation
            {Description = "This field MUST be set to zero or the following value."};
    
    ULONG64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2CreateResponseLeaseV2", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to zero, and the client MUST ignore it on receipt."};

    GUID ParentLeaseKey 
        with Documentation
            {Description = "A unique key that identifies the owner of the lease for the parent directory."};

    USHORT Epoch
        with Documentation
            {Description = "A 16-bit unsigned integer incremented by the server on a lease state change."};

    USHORT Reserved
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server SHOULD set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
        {Description = "The server responds with a lease that is granted for this open. The data in the Buffer field of the SMB2_CREATE_CONTEXT structure MUST contain the following structure. The SMB2_CREATE_RESPONSE_LEASE_V2 packet is only valid for the SMB 3.x dialect family."};

pattern SMB2CreateResponseLeaseV2LeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x00000001
        with Documentation
            {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x00000002
        with Documentation
            {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x00000004
        with Documentation
            {Description = "A write caching lease is granted."}
} with Documentation {EmbeddedType = true};

pattern SMB2CreateResponseLeaseV2Flags = flags ULONG
{
    SMB2LeaseFlagBreakInProgress = 0x00000002
        with Documentation
            {Description = "A break for the lease identified by the lease key is in progress."},
    SMB2LeaseFlagParentLeaseKeySet = 0x00000004
        with Documentation
            {Description = "When set, indicates that the ParentLeaseKey is set."}
} with Documentation {EmbeddedType = true};

// 2.2.14.2.12   SMB2_CREATE_DURABLE_HANDLE_RESPONSE_V2
type SMB2CreateDurableHandleResponseV2
{
    ULONG Timeout
        with Documentation
            {Description = "The server MUST set this field to the time, in milliseconds, that it waits for the client to reconnect after a failover."};

    SMB2CreateDurableHandleResponseV2Flags Flags
        with Documentation
            {Description = "This field MUST be constructed using zero or more of the following values"};
}
with Documentation
        {Description = "If the server succeeds in opening a durable handle to a file as requested by the client via the SMB2_CREATE_DURABLE_HANDLE_REQUEST_V2 (section 2.2.13.2.11), it MUST send an SMB2_CREATE_DURABLE_HANDLE_RESPONSE_V2 back to the client to inform the client that the handle is durable. The SMB2_CREATE_DURABLE_HANDLE_RESPONSE_V2 packet is only valid for the SMB 3.x dialect family. If the server does not mark it for durable operation or the server does not implement durable handles, it MUST ignore this request."};

pattern SMB2CreateDurableHandleResponseV2Flags = flags ULONG
{
    SMB2DhandleFlagPersistent = 0x00000002
        with Documentation
            {Description = "A persistent handle is granted."}
} with Documentation {EmbeddedType = true};

// 2.2.15   SMB2 CLOSE Request
type SMB2CloseRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CloseRequest", 24, value)
        with Documentation
            {Description = "The client MUST set this field to 24, indicating the size of the request structure, not including the header."};

    SMB2CloseRequestFlags Flags
        with Documentation
            {Description = "A Flags field indicates how to process the operation. This field MUST be constructed using the following value:"};

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CloseRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    SMB2Fileid FileId
        with Documentation
            {Description = "An SMB2Fileid structure, as specified in section ."};
}
with Documentation
       {Description = "The SMB2 CLOSE Request packet is used by the client to close an instance of a file that was opened previously with a successful SMB2 CREATE Request. This request is composed of an SMB2 header, as specified in section , followed by this request structure:"};

pattern SMB2CloseRequestFlags = flags USHORT
{
   SMB2CloseFlagPostqueryAttrib = 0x0001
       with Documentation
          {Description = "If set, the server MUST set the attribute fields in the response, as specified in section 2.2.16, to valid values. If not set, the client MUST NOT use the values that are returned in the response."},
}with Documentation {EmbeddedType = true};

pattern SMB2CloseResponseFlags = flags USHORT
{
    SMB2CloseFlagPostqueryAttrib = 0x0001
        with Documentation
            {Description = "If set, the client MUST use the attribute fields in the response. If not set, the client MUST NOT use the attribute fields that are returned in the response."},
}with Documentation {EmbeddedType = true};


// 2.2.16   SMB2 CLOSE Response
type SMB2CloseResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 60, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CloseResponse", 60, value)
        with Documentation
            {Description = "The server MUST set this field to 60, indicating the size of the response structure, not including the header."};

    SMB2CloseResponseFlags Flags
        with Documentation
            {Description = "A Flags field indicates how to process the operation. This field MUST be either zero or the following value"};

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CloseResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    FILETIME CreationTime with DisplayInfo {ToText = SMB2.FileTimeToText},
        Documentation
            {Description = "The time when the file was created; in FILETIME format as specified in [MS-DTYP] section . If the SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB flag in the SMB2 CLOSE Request was set, this field MUST be set to the value that is returned by the attribute query. If the flag is not set, the field SHOULD be set to zero and MUST NOT be checked on receipt."};

    FILETIME LastAccessTime with DisplayInfo {ToText = SMB2.FileTimeToText},
        Documentation
            {Description = "The time when the file was last accessed; in FILETIME format as specified in [MS-DTYP] section . If the SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB flag in the SMB2 CLOSE Request was set, this field MUST be set to the value that is returned by the attribute query. If the flag is not set, this field MUST be set to zero."};

    FILETIME LastWriteTime with DisplayInfo {ToText = SMB2.FileTimeToText},
        Documentation
            {Description = "The time when data was last written to the file; in FILETIME format as specified in [MS-DTYP] section . If the SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB flag in the SMB2 CLOSE Request was set, this field MUST be set to the value that is returned by the attribute query. If the flag is not set, this field MUST be set to zero."};

    FILETIME ChangeTime with DisplayInfo {ToText = SMB2.FileTimeToText},
        Documentation
            {Description = "The time when the file was last modified; in FILETIME format as specified in [MS-DTYP] section . If the SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB flag in the SMB2 CLOSE Request was set, this field MUST be set to the value that is returned by the attribute query. If the flag is not set, this field MUST be set to zero."};

    LARGE_INTEGER AllocationSize
        with Documentation
            {Description = "The size, in bytes, of the data that is allocated to the file. If the SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB flag in the SMB2 CLOSE Request was set, this field MUST be set to the value that is returned by the attribute query. If the flag is not set, this field MUST be set to zero."};

    LARGE_INTEGER EndofFile
        with Documentation
            {Description = "The size, in bytes, of the file. If the SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB flag in the SMB2 CLOSE Request was set, this field MUST be set to the value that is returned by the attribute query. If the flag is not set, this field MUST be set to zero."};

    FileAttributes FileAttributes
        with Documentation
            {Description = "The attributes of the file. If the SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB flag in the SMB2 CLOSE Request was set, this field MUST be set to the value that is returned by the attribute query. If the flag is not set, this field MUST be set to zero. For more information about valid flags, see [MS-FSCC] section ."};
}
with Documentation
       {Description = "The SMB2 CLOSE Response packet is sent by the server to indicate that an SMB2 CLOSE Request was processed successfully. This response is composed of an SMB2 header, as specified in section , followed by this response structure:"};

string FileTimeToText(any data)
{    
    if (data is FILETIME) 
    {
        FILETIME time = data as FILETIME;
        if (time.dwLowDateTime == 0 && time.dwHighDateTime == 0)
        {
            return "No Time Specified (0)";
        }
        else
        {
            return time.ToString();
        }
    } 
    else
    {
        return "Unknown Type";   
    } 
}      
       
// 2.2.17   SMB2 FLUSH Request
type SMB2FlushRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2FlushRequest", 24, value)
        with Documentation
            {Description = "The client MUST set this field to 24, indicating the size of the request structure, not including the header."};

    USHORT Reserved1 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved1", "SMB2FlushRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2FlushRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    SMB2Fileid FileId
        with Documentation {Description = "An SMB2Fileid, as specified in section ."};
}
with Documentation
       {Description = "The SMB2 FLUSH Request packet is sent by a client to request that a server flush all cached file information for a specified open of a file to the persistent store that backs the file. If the open refers to a named pipe, the operation will complete once all data written to the pipe has been consumed by a reader. This request is composed of an SMB2 header, as specified in section , followed by this request structure:"};

// 2.2.18   SMB2 FLUSH Response
type SMB2FlushResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2FlushResponse", 4, value)
        with Documentation
            {Description = "The server MUST set this field to 4, indicating the size of the response structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2FlushResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this field to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 FLUSH Response packet is sent by the server to confirm that an SMB2 FLUSH Request was successfully processed. This response is composed of an SMB2 header, as specified in section , followed by this request structure:"};

// 2.2.19   SMB2 READ Request
type SMB2ReadRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 49, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2ReadRequest", 49, value)
        with Documentation
            {Description = "The client MUST set this field to 49, indicating the size of the request structure, not including the header. The client MUST set it to this value regardless of how long Buffer[] actually is in the request being sent."};

    UCHAR Padding
        with Documentation
            {Description = "The requested offset from the start of the SMB2 header, in bytes, at which to place the data read in the SMB2 READ Response. This value is provided to optimize data placement on the client and is not binding on the server."};

    SMB2ReadRequestFlags Flags 
        where ValidationCheck(
            ((SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB302DialectRevisionNumber) ? (value == 0 || value is SMB2ReadRequestFlags.SMB2_READFLAG_READ_UNBUFFERED) : (value == 0)), 
            null, 
            DiagnosisLevel.Error,
            ((SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB302DialectRevisionNumber) ? ("SMB2: For the SMB 3.0.2 dialect, the Flags in type SMB2ReadRequest must be set to zero or 0x01, not " + DecToHexFormat(value) + ".") : ("SMB2: For the SMB 2.002, 2.1 and 3.0 dialects, the Flags in type SMB2ReadRequest must be set to zero, not " + DecToHexFormat(value) + "."))
            )
        with Documentation
            {Description = "For the SMB 2.002, 2.1 and 3.0 dialects, this field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt. For the SMB 3.02 dialect, this field MUST contain zero or more of the following values"};

    ULONG Length
        with Documentation
            {Description = "The length, in bytes, of the data to read from the specified file or pipe. The length of the data being read may be zero bytes."};

    UINT64 Offset
        with Documentation
            {Description = "The offset, in bytes, into the file from which the data MUST be read. If the read is being executed on a pipe, the Offset MUST be set to 0 by the client and MUST be ignored by the server."};

    SMB2Fileid FileId
        with Documentation {Description = "An SMB2Fileid, as specified in section ."};

    ULONG MinimumCount
        with Documentation
            {Description = "The minimum number of bytes to be read for this operation to be successful. If fewer than the minimum number of bytes are read by the server, the server MUST return an error rather than the bytes read."};

    SMB2ReadRequestChannel Channel
        with Documentation
            {Description = "For SMB 2.002 and 2.1 dialects, this field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt. For the SMB 3.x dialect family, this field MUST contain exactly one of the following values:"};

    ULONG RemainingBytes
        with Documentation
            {Description = "The number of subsequent bytes that the client intends to read from the file after this operation completes. This value is provided to facilitate read-ahead caching, and is not binding on the server."};

    USHORT ReadChannelInfoOffset where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "ReadChannelInfoOffset", "SMB2ReadRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt."};

    USHORT ReadChannelInfoLength where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "ReadChannelInfoLength", "SMB2ReadRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt."};

    BYTE Buffer where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Buffer", "SMB2ReadRequest", value)
        with Documentation
            {Description = "A variable-length buffer that contains the read channel information, as described by ReadChannelInfoOffset and ReadChannelInfoLength. Unused at present. The client MUST set one byte of this field to 0, and the server MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 READ Request packet is sent by the client to request a read operation on the file that is specified by the FileId. This request is composed of an SMB2 header, as specified in section , followed by this request structure:"};

pattern SMB2ReadRequestChannel = flags ULONG
{
    SMB2_CHANNEL_NONE = 0x00000000
        with Documentation
            {Description = "No channel information is present in the request. The ReadChannelInfoOffset and ReadChannelInfoLength fields MUST be set to 0 by the client and MUST be ignored by the server."},
    SMB2_CHANNEL_RDMA_V1 = 0x00000001
        with Documentation
            {Description = "One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures as specified in [MS-SMBD] section 2.2.3.1 are present in the channel information specified by ReadChannelInfoOffset and ReadChannelInfoLength fields."},
    SMB2_CHANNEL_RDMA_V1_INVALIDATE = 0x00000002
        with Documentation
            {Description = "This value is valid only for the SMB 3.02 dialect. One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures, as specified in [MS-SMBD] section 2.2.3.1, are present in the channel information specified by the ReadChannelInfoOffset and ReadChannelInfoLength fields. The server is requested to perform remote invalidation when responding to the request as specified in [MS-SMBD] section 3.1.4.2."},
}with Documentation {EmbeddedType = true};

pattern SMB2ReadRequestFlags = enum UCHAR
{
    SMB2_READFLAG_READ_UNBUFFERED = 0x01
        with Documentation
            {Description = "The server or underlying object store SHOULD NOT cache the read data at intermediate layers."}
	...
}with Documentation {EmbeddedType = true};

// 2.2.20   SMB2 READ Response
type SMB2ReadResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 17, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2ReadResponse", 17, value)
        with Documentation
            {Description = "The server MUST set this field to 17, indicating the size of the response structure, not including the header. This value MUST be used regardless of how large Buffer[] is in the actual response."};

    UCHAR DataOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the header to the data read being returned in this response."};

    UCHAR Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2ReadResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    ULONG DataLength
        with Documentation
            {Description = "The length, in bytes, of the data read being returned in this response."};

    ULONG DataRemaining
        with Documentation
            {Description = "The length, in bytes, of the data being sent on the Channel specified in the request."};
            
    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2ReadResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
    
    optional [|DataOffset > 80|] array<byte> DataPadding with BinaryEncoding{Length = DataOffset - 80 as uint};
    binary Buffer where ValidationCheck(value.Count > 0, null, "SMB2: The minimum length of Buffer in type SMB2ReadResponse is 1 byte, not " + (value.Count as string) + ".")
        // WORKAROUND: Remove Length = DataLength aspect to surpport the partial packet
        with Documentation
            {Description = "A variable-length buffer that contains the data read for the response, as described by DataOffset and DataLength. The minimum length is 1 byte. If 0 bytes are returned from the underlying object store, the server MUST send a failure response with status equal to STATUS_END_OF_FILE."};
}
with Documentation
       {Description = "The SMB2 READ Response packet is sent in response to an SMB2 READ Request packet. This response is composed of an SMB2 header, as specified in section , followed by this response structure:"};

// 2.2.21   SMB2 WRITE Request
type SMB2WriteRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 49, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2WriteRequest", 49, value)
        with Documentation
            {Description = "The client MUST set this field to 49, indicating the size of the request structure, not including the header. The client MUST set it to this value regardless of how long Buffer[] actually is in the request being sent."};

    USHORT DataOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the data being written."};

    ULONG Length
        with Documentation
            {Description = "The length of the data being written, in bytes. The length of the data being written may be zero bytes."};

    UINT64 Offset
        with Documentation
            {Description = "The offset, in bytes, of where to write the data in the destination file. If the write is being executed on a pipe, the Offset MUST be set to 0 by the client and MUST be ignored by the server."};

    SMB2Fileid FileId
        with Documentation {Description = "An SMB2Fileid, as specified in section ."};

    SMB2WriteRequestChannel Channel
        with Documentation
            {Description = "For the SMB 2.002 and 2.1 dialects, this field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt. For the SMB 3.x dialect family, this field MUST contain exactly one of the SMB2WriteRequestChannel values."};

    ULONG RemainingBytes
        with Documentation
            {Description = "The number of subsequent bytes the client intends to write to the file after this operation completes. This value is provided to facilitate write caching and is not binding on the server."};

    USHORT WriteChannelInfoOffset
        with Documentation
            {Description = "For the SMB 2.002 and 2.1 dialects, this field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt. For the SMB 3.x dialect family, it contains the offset, in bytes, from the beginning of the SMB2 header to the channel data as described by the Channel field of the request."};

    USHORT WriteChannelInfoLength
        with Documentation
            {Description = "For the SMB 2.002 and SMB 2.1 dialects, this field MUST NOT be used and MUST be reserved.The client MUST set this field to 0, and the server MUST ignore it on receipt. For the SMB 3.x dialect family, it contains the offset, in bytes, from the beginning of the SMB2 header to the channel data as described by the Channel field of the request."};

    SMB2WriteRequestFlags Flags where ValidationCheck((value == 0 || value is SMB2WriteRequestFlags), null, DiagnosisLevel.Error, "SMB2: the Flags in type SMB2WriteRequest must be set to zero, 0x00000001 or 0x00000002, not " + DecToHexFormat(value) + ".")
        with Documentation
            {Description = "A Flags field indicates how to process the operation. This field MUST be constructed using the following value:"};
    
    optional [|DataOffset > 112|] array<byte> DataPadding with BinaryEncoding{Length = DataOffset - 112 as uint};
    binary Buffer // WORKAROUND: Remove Length = Length aspect to surpport the partial packet
        with Documentation
            {Description = "A variable-length buffer that contains the data to write and the write channel information, as described by DataOffset, Length, WriteChannelInfoOffset, and WriteChannelInfoLength."};
}
with Documentation
       {Description = "The SMB2 WRITE Request packet is sent by the client to write data to the file or named pipe on the server. This request is composed of an SMB2 header, as specified in section , followed by this request structure:"};

pattern SMB2WriteRequestFlags = flags ULONG
{
    SMB2_WRITEFLAG_WRITE_THROUGH = 0x00000001
        with Documentation
           {Description = "The write data should be written to persistent storage before the response is sent regardless of how the file was opened.  This value is only supported for the SMB 2.1 dialect."},
    SMB2_WRITEFLAG_WRITE_UNBUFFERED = 0x00000002
        with Documentation
           {Description = "The server or underlying object store SHOULD NOT cache the write data at intermediate layers and SHOULD allow it to flow through to persistent storage. This bit is only valid for the SMB 3.02 dialect."}
	...
}with Documentation {EmbeddedType = true};

pattern SMB2WriteRequestChannel = flags ULONG
{
    SMB2_CHANNEL_NONE = 0x00000000
        with Documentation
            {Description = "No channel information is present in the request. The WriteChannelInfoOffset and WriteChannelInfoLength fields MUST be set to zero by the client and MUST be ignored by the server."},
    SMB2_CHANNEL_RDMA_V1 = 0x00000001
        with Documentation
            {Description = "One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures as specified in [MS-SMBD] section 2.2.3.1 are present in the channel information specified by WriteChannelInfoOffset and WriteChannelInfoLength fields."},
    SMB2_CHANNEL_RDMA_V1_INVALIDATE = 0x00000002
        with Documentation
            {Description = "This value is valid only for the SMB 3.02 dialect. One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures as specified in [MS-SMBD] section 2.2.3.1 are present in the channel information specified by the ReadChannelInfoOffset and ReadChannelInfoLength fields. The server is requested to perform remote invalidation when responding to the request as specified in [MS-SMBD] section 3.1.4.2."},
}with Documentation {EmbeddedType = true};

// 2.2.22   SMB2 WRITE Response
type SMB2WriteResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 17, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2WriteResponse", 17, value)
        with Documentation
            {Description = "The server MUST set this field to 17, the actual size of the response structure notwithstanding."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2WriteResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    ULONG Count with Documentation {Description = "The number of bytes written."};

    ULONG Remaining where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Remaining", "SMB2WriteResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    USHORT WriteChannelInfoOffset where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "WriteChannelInfoOffset", "SMB2WriteResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    USHORT WriteChannelInfoLength where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "WriteChannelInfoLength", "SMB2WriteResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 WRITE Response packet is sent in response to an SMB2 WRITE Request packet. This response is composed of an SMB2 header, as specified in section , followed by this response structure:"};

// 2.2.23.1   Oplock Break Notification
type SMB2OplockBreakNotification
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2OplockBreakNotification", 24, value)
        with Documentation
            {Description = "The server MUST set this to 24, indicating the size of the response structure, not including the header."};

    SMB2OplockBreakNotificationOplockLevel OplockLevel
        where ValidationCheck(InRange<SMB2OplockBreakNotificationOplockLevel>(value), null, DiagnosisLevel.Error, 
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "OplockLevel", COMMON_STR_TYPE, "SMB2OplockBreakNotification", COMMON_STR_MUST, "0x00, 0x01", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The server MUST set this to the maximum value of the OplockLevel that the server will accept for an acknowledgment from the client. Because SMB2_OPLOCK_LEVEL_BATCH is the highest oplock level, and it is being broken to a lower level, the server will never send a break from SMB2_OPLOCK_LEVEL_BATCH to SMB2_OPLOCK_LEVEL_BATCH. Thus this field MUST contain one of the following values.windows-based clients never use exclusive oplocks. Because there are no situations where it would require an exclusive oplock where it would not also require an SMB2_OPLOCK_LEVEL_BATCH, it always requests an SMB2_OPLOCK_LEVEL_BATCH."};

    UCHAR Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2OplockBreakNotification", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2OplockBreakNotification", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    SMB2Fileid FileId
        with Documentation {Description = "An SMB2Fileid, as specified in section ."};
}
with Documentation
       {Description = "The SMB2 Oplock Break Notification packet is sent by the server when the underlying object store indicates that an opportunistic lock(oplock) is being broken, representing a change in the oplock level. This response is composed of an SMB2 header, as specified in section , followed by this notification structure:"};

pattern SMB2OplockBreakNotificationOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00
        with Documentation {Description = "No oplock is available."},
    SMB2OplockLevelII = 0x01
        with Documentation {Description = "A level II oplock is available."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.23.2   Lease Break Notification
type SMB2LeaseBreakNotification
{
    USHORT StructureSize where ValidationCheckValue(value == 44, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LeaseBreakNotification", 44, value)
        with Documentation
            {Description = "The server MUST set this to 44, indicating the size of the response structure, not including the header."};

    USHORT NewEpoch
        with Documentation
            {Description = "A 16-bit unsigned integer indicating a lease state change by the server. This field is only valid for a server implementing the SMB 3.x dialect family. For the SMB 2.1 dialect, this field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    SMB2LeaseBreakNotificationFlags Flags
        with Documentation
            {Description = "The field MUST be constructed by using zero or more of the following values."};

    GUID LeaseKey
        with Documentation
            {Description = "A unique key which identifies the owner of the lease."};

    SMB2LeaseBreakNotificationCurrentLeaseState CurrentLeaseState
        with Documentation
            {Description = "The current lease state of the open. This field MUST be constructed using the following values."};

    SMB2LeaseBreakNotificationNewLeaseState NewLeaseState
        with Documentation
            {Description = "The new lease state for the open. This field MUST be constructed using the SMB2_LEASE_NONE or above values."};

    ULONG BreakReason where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "BreakReason", "SMB2LeaseBreakNotification", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    ULONG AccessMaskHint where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "AccessMaskHint", "SMB2LeaseBreakNotification", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    ULONG ShareMaskHint where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "ShareMaskHint", "SMB2LeaseBreakNotification", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 Lease Break Notification packet is sent by the server when the underlying object store indicates that a lease is being broken, representing a change in the lease state. This is only valid on the SMB 2.1 dialect. This response is composed of an SMB2 header, as specified in section , followed by this notification structure:"};

pattern SMB2LeaseBreakNotificationFlags = flags
{
    SMB2NotifyBreakLeaseFlagAckRequired = 0x01
        with Documentation
            {Description = "A Lease Break Acknowledgment is required."},
}with Documentation {EmbeddedType = true};
 
pattern SMB2LeaseBreakNotificationNewLeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x01
        with Documentation {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x02
        with Documentation {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x04
        with Documentation {Description = "A write caching lease is granted."},
    ...
}with Documentation {EmbeddedType = true};

pattern SMB2LeaseBreakNotificationCurrentLeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x01
        with Documentation {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x02
        with Documentation {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x04
        with Documentation {Description = "A write caching lease is granted."},
}with Documentation {EmbeddedType = true}; 

pattern DirectoryAccessMaskDirectoryAccessMask = flags ULONG
{
    FileListDirectory = 0x00000001
        with Documentation
            {Description = "This value indicates the right to enumerate the contents of the directory."},
    FileAddFile = 0x00000002
        with Documentation
            {Description = "This value indicates the right to create a file under the directory."},
    FileAddSubdirectory = 0x00000004
        with Documentation
            {Description = "This value indicates the right to add a sub-directory under the directory."},
    FileReadEa = 0x00000008
        with Documentation
            {Description = "This value indicates the right to read the extended attributes of the directory."},
    FileWriteEa = 0x00000010
        with Documentation
            {Description = "This value indicates the right to write or change the extended attributes of the directory."},
    FileTraverse = 0x00000020
        with Documentation
            {Description = "This value indicates the right to traverse this directory if the server enforces traversal checking."},
    FileDeleteChild = 0x00000040
        with Documentation
            {Description = "This value indicates the right to delete the files and directories within this directory."},
    FileReadAttributes = 0x00000080
        with Documentation
            {Description = "This value indicates the right to read the attributes of the directory."},
    FileWriteAttributes = 0x00000100
        with Documentation
            {Description = "This value indicates the right to change the attributes of the directory."},
    Delete = 0x00010000
        with Documentation
            {Description = "This value indicates the right to delete the directory."},
    ReadControl = 0x00020000
        with Documentation
            {Description = "This value indicates the right to read the security descriptor for the directory."},
    WriteDac = 0x00040000
        with Documentation
            {Description = "This value indicates the right to change the DACL in the security descriptor for the directory. For the DACL data structure, see ACL in [MS-DTYP]."},
    WriteOwner = 0x00080000
        with Documentation
            {Description = "This value indicates the right to change the owner in the security descriptor for the directory."},
    Synchronize = 0x00100000
        with Documentation
            {Description = "SMB2 clients set this flag to any value.windows sets this flag to the value passed in by the higher-level application. SMB2 servers SHOULDwindows_server_2008_r2 and windows_7 do not ignore the SyncHRONIZE bit, and pass it to the underlying object store. If the caller requests SyncHRONIZE in the DesiredAccess parameter, but the SyncHRONIZE access is not granted to the caller for the object being created or opened, the underlying object store fails the request and returns STATUS_ACCESS_DENIED. When SyncHRONIZE access is granted, the SyncHRONIZE bit is returned in MaximalAccess field of SMB2_CREATE_QUERY_MAXIMAL_ACCESS_RESPONSE with no other behavior. ignore this flag."},
    AccessSystemSecurity = 0x01000000
        with Documentation
            {Description = "This value indicates the right to read or change the SACL in the security descriptor for the directory. For the SACL data structure, see ACL in [MS-DTYP].windows fails the create request with STATUS_ACCESS_DENIED if the caller does not have the SeSecurityPrivilege, as specified in [MS-LSAD] section ."},
    MaximumAllowed = 0x02000000
        with Documentation
            {Description = "This value indicates that the client is requesting an open to the directory with the highest level of access the client has on this directory. If no access is granted for the client on this directory, the server MUST fail the open with STATUS_ACCESS_DENIED."},
    GenericAll = 0x10000000
        with Documentation
            {Description = "This value indicates a request for all the access flags that are listed above except MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY."},
    GenericExecute = 0x20000000
        with Documentation
            {Description = "This value indicates a request for the following access flags listed above: FILE_READ_ATTRIBUTES| FILE_TRAVERSE| SyncHRONIZE| READ_CONTROL."},
    GenericWrite = 0x40000000
        with Documentation
            {Description = "This value indicates a request for the following access flags listed above: FILE_ADD_FILE| FILE_ADD_SUBDIRECTORY| FILE_WRITE_ATTRIBUTES| FILE_WRITE_EA| SyncHRONIZE| READ_CONTROL."},
    GenericRead = 0x80000000
        with Documentation
            {Description = "This value indicates a request for the following access flags listed above: FILE_LIST_DIRECTORY| FILE_READ_ATTRIBUTES| FILE_READ_EA| SyncHRONIZE| READ_CONTROL."},
} with Documentation {EmbeddedType = true};


// 2.2.24.1   Oplock Break Acknowledgment
type SMB2OplockBreakAcknowledgment
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2OplockBreakAcknowledgment", 24, value)
        with Documentation
            {Description = "The client MUST set this to 24, indicating the size of the request structure, not including the header."};

    SMB2OplockBreakAcknowledgmentOplockLevel OplockLevel
        where ValidationCheck(InRange<SMB2OplockBreakAcknowledgmentOplockLevel>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "OplockLevel", COMMON_STR_TYPE, "SMB2OplockBreakAcknowledgment", COMMON_STR_MUST, "0x00, 0x01", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The resulting oplock level. This MUST be at least as permissive as the level that is specified by the server in its initial oplock break notification packet. For example, if the server specifies an SMB2_OPLOCK_LEVEL_II, the client can respond with an SMB2_OPLOCK_LEVEL_II or an SMB2_OPLOCK_LEVEL_NONE. Because SMB2_OPLOCK_LEVEL_BATCH is the highest oplock level, the server will never send a break from SMB2_OPLOCK_LEVEL_BATCH to SMB2_OPLOCK_LEVEL_BATCH. Thus this field MUST contain one of the following values.windows-based clients never use exclusive oplocks. There are no situations where an exclusive oplock would be used instead of using a SMB2_OPLOCK_LEVEL_BATCH."};

    UCHAR Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2OplockBreakAcknowledgment", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2OplockBreakAcknowledgment", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    SMB2Fileid FileId
        with Documentation {Description = "An SMB2Fileid, as specified in section ."};
}
with Documentation
       {Description = "The Oplock Break Acknowledgment packet is sent by the client in response to an SMB2 Oplock Break Notification packet sent by the server. The server responds to an oplock break acknowledgment with an SMB2 Oplock Break response. The client MUST NOT send an oplock break acknowledgment for an oplock break from level II to none. A break from level II MUST transition to none. Thus, the client does not send a request to the server because there is no question how the transition was made."};

pattern SMB2OplockBreakAcknowledgmentOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00
        with Documentation
            {Description = "The client has lowered its oplock level for this file to none."},
    SMB2OplockLevelII = 0x01
        with Documentation
            {Description = "The client has lowered its oplock level for this file to level II."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.24.2   Lease Break Acknowledgment
type SMB2LeaseBreakAcknowledgment
{
    USHORT StructureSize where ValidationCheckValue(value == 36, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LeaseBreakAcknowledgment", 36, value)
        with Documentation
            {Description = "The client MUST set this to 36, indicating the size of the request structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LeaseBreakAcknowledgment", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    UINT32 Flags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Flags", "SMB2LeaseBreakAcknowledgment", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    GUID LeaseKey
        with Documentation
            {Description = "A unique key which identifies the owner of the lease."};

    SMB2LeaseBreakAcknowledgmentLeaseState LeaseState
        with Documentation
            {Description = "The lease state in the Lease Break Acknowledgment message MUST be a subset of the lease state granted by the server via the preceding Lease Break Notification message.windows clients always set the LeaseState in the Lease Break Acknowledgment to be equal to the LeaseState in the Lease Break Notification from the server. This field MUST be constructed using the following values:"};

    ULONG64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2LeaseBreakAcknowledgment", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};
            
} with Documentation
       {Description = "The SMB2 Lease Break Acknowledgment packet is sent by the client in response to an SMB2 Lease Break Notification packet sent by the server. This request is valid only in the SMB 2.1 dialect. The server responds to a lease break acknowledgment with an SMB2 Lease Break Response."};


pattern SMB2LeaseBreakAcknowledgmentLeaseState = flags ULONG
{
   SMB2LeaseNone = 0x00
       with Documentation {Description = "No lease is granted."},
   SMB2LeaseReadCaching = 0x01
       with Documentation {Description = "A read caching lease is accepted."},
   SMB2LeaseHandleCaching = 0x02
       with Documentation {Description = "A handle caching lease is accepted."},
   SMB2LeaseWriteCaching = 0x04
       with Documentation {Description = "A write caching lease is accepted."},
   Reservered = 0xFFFFFFF0
} with Documentation {EmbeddedType = true};

// 2.2.25.1   Oplock Break Response
type SMB2OplockBreakResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2OplockBreakResponse", 24, value)
        with Documentation
            {Description = "The server MUST set this to 24, indicating the size of the response structure, not including the header."};

    SMB2OplockBreakResponseOplockLevel OplockLevel
        where ValidationCheck(InRange<SMB2OplockBreakResponseOplockLevel>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "OplockLevel", COMMON_STR_TYPE, "SMB2OplockBreakResponse", COMMON_STR_MUST, "0x00, 0x01", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The resulting oplock level. This MUST be the same as the level that is specified by the client in its oplock break acknowledgment packet.  This field MUST contain one of the following values."};

    UCHAR Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2OplockBreakResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2OplockBreakResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    SMB2Fileid FileId
        with Documentation {Description = "An SMB2Fileid, as specified in section ."};
}
with Documentation
       {Description = "The Oplock Break Response packet is sent by the server in response to an Oplock Break Acknowledgment from the client. This response is composed of an SMB2 header, as specified in section , followed by this response structure:"};

pattern SMB2OplockBreakResponseOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00
        with Documentation
            {Description = "The server has lowered oplock level for this file to none."},
    SMB2OplockLevelII = 0x01
        with Documentation
            {Description = "The server has lowered oplock level for this file to level II."},
    ...
} with Documentation {EmbeddedType = true};
 
// 2.2.25.2   Lease Break Response
type SMB2LeaseBreakResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 36, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LeaseBreakResponse", 36, value)
        with Documentation
            {Description = "The server MUST set this to 36, indicating the size of the response structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LeaseBreakResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    UINT32 Flags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Flags", "SMB2LeaseBreakResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};

    GUID LeaseKey
        with Documentation
            {Description = "A unique key which identifies the owner of the lease."};

    SMB2LeaseBreakResponseLeaseState LeaseState
        with Documentation
            {Description = "The requested lease state. This field MUST be constructed using the following values:"};

    ULONG64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2LeaseBreakResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 Lease Break Response packet is sent by the server in response to a Lease Break Acknowledgment from the client. This request is valid only in the SMB 2.1 dialect."};

pattern SMB2LeaseBreakResponseLeaseState = flags ULONG
{
    SMB2LeaseNone = 0x00
       with Documentation {Description = "No lease is granted."},
    SMB2LeaseReadCaching = 0x01
       with Documentation {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x02
       with Documentation {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x04
       with Documentation {Description = "A write caching lease is granted."},
} with Documentation {EmbeddedType = true};

 
// 2.2.26   SMB2 LOCK Request
type SMB2LockRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 48, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LockRequest", 48, value)
        with Documentation
            {Description = "The client MUST set this to 48, indicating the size of an SMB2 LOCK Request with a single SMB2_LOCK_ELEMENT structure. This value is set regardless of the number of locks that are sent."};

    USHORT LockCount where ValidationCheckGreaterThan(value > 0, null, true, ReferenceType.Type, "SMB2", "LockCount", "SMB2LockRequest", 0, value)
        with Documentation
            {Description = "MUST be set to the number of SMB2_LOCK_ELEMENT structures that are contained in the Locks[] array. The lock count MUST be greater than or equal to 1."};

    ULONG LockSequence
        with Documentation
            {Description = "In the SMB 2.002 dialect, this field is unused and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt. In all other dialects, this field indicates a value that identifies a lock or unlock request uniquely across all lock or unlock requests that are sent on the same file."};

    SMB2Fileid FileId
        with Documentation
            {Description = "An SMB2Fileid that identifies the file on which to perform the byte range locks or unlocks."};

    array<SMB2LockElement> Locks with BinaryEncoding{Length = LockCount}
        with Documentation
            {Description = "An array of LockCount(SMB2_LOCK_ELEMENT) structures that define the ranges to be locked or unlocked."};
}
with Documentation
       {Description = "The SMB2 LOCK Request packet is sent by the client to either lock or unlock portions of a file. Several different segments of the file can be affected with a single SMB2 LOCK Request packet, but they all MUST be within the same file."};

// 2.2.26.1   SMB2_LOCK_ELEMENT Structure
type SMB2LockElement
{
    UINT64 Offset
        with Documentation
            {Description = "The starting offset, in bytes, in the destination file from where the range being locked or unlocked starts."};

    UINT64 Length
        with Documentation
            {Description = "The length, in bytes, of the range being locked or unlocked."};

    SMB2LockElementFlags Flags
        with Documentation
            {Description = "The description of how the range is being locked or unlocked and how to process the operation. This field takes the following format:"};

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LockElement", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 LOCK_ELEMENT Structure packet is used by the SMB2 LOCK Request packet to indicate segments of files that should be locked or unlocked."};

// WORKAROUND: Bug#27596 - [DCR] Show the bits combination in the Details view for a flags pattern field
type SMB2LockElementFlags
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    bool SMB2LockflagFailImmediately with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    bool SMB2LockflagUnlock with BinaryEncoding{Width = 1};
    bool SMB2LockflagExclusiveLock with BinaryEncoding{Width = 1};
    bool SMB2LockflagSharedLock with BinaryEncoding{Width = 1};
    array<byte> Reserved3 with BinaryEncoding{Length = 3};
}

/*  pattern SMB2LockElementFlags =
 *  flags
 *  {
 *   SMB2LockflagSharedLock = 0x00000001
 *     with Documentation
 *            {Description = "The range MUST be locked shared, allowing other opens to read from or take a shared lock on the range. OtherAllopens MUST NOT be allowed to write within the range. Other locks can be requested and taken on this range."},
 *   SMB2LockflagExclusiveLock = 0x00000002
 *     with Documentation
 *            {Description = "The range MUST be locked exclusive, not allowing other opens to read, write, or lock within the range."},
 *   SMB2LockflagUnlock = 0x00000004
 *     with Documentation
 *            {Description = "The range MUST be unlocked from a previous lock taken on this range. The unlock range MUST be identical to the lock range. Sub-ranges cannot be unlocked."},
 *   SMB2LockflagFailImmediately = 0x00000010
 *     with Documentation
 *            {Description = "The lock operation MUST fail immediately if it conflicts with an existing lock, instead of waiting for the range to become available."}
 * with Documentation {EmbeddedType = true};
 */

// 2.2.27   SMB2 LOCK Response
type SMB2LockResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LockResponse", 4, value)
        with Documentation
            {Description = "The server MUST set this to 4, indicating the size of the response structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LockResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 LOCK Response packet is sent by a server in response to an SMB2 LOCK Request packet. This response is composed of an SMB2 header, as specified in section , followed by this request structure:"};

// 2.2.28   SMB2 ECHO Request
type SMB2EchoRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2EchoRequest", 4, value)
        with Documentation
            {Description = "The client MUST set this to 4, indicating the size of the request structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2EchoRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 ECHO Request packet is sent by a client to determine whether a server is processing requests. This request is composed of an SMB2 header, as specified in section , followed by this request structure:"};

// 2.2.29   SMB2 ECHO Response
type SMB2EchoResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2EchoResponse", 4, value)
        with Documentation
            {Description = "The server MUST set this to 4, indicating the size of the response structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2EchoResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this to 0, and the client MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 ECHO Response packet is sent by the server to confirm that an SMB2 ECHO Request(section ) was successfully processed. This response is composed of an SMB2 header, as specified in section , followed by the following response structure."};

// 2.2.30   SMB2 CANCEL Request
type SMB2CancelRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CancelRequest", 4, value)
        with Documentation
            {Description = "The client MUST set this field to 4, indicating the size of the request structure, not including the header."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CancelRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 CANCEL Request packet is sent by the client to cancel a previously sent message on the same SMB2 transport connection. The MessageId of the request to be canceled MUST be set in the SMB2 header of the request. This request is composed of an SMB2 header, as specified in section , followed by this request structure:"};

pattern SMB2CreateResponseOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00
        with Documentation {Description = "No oplock was granted."},
    SMB2OplockLevelII = 0x01
        with Documentation {Description = "A level II oplock was granted."},
    SMB2OplockLevelExclusive = 0x08
        with Documentation {Description = "An exclusive oplock was granted."},
    SMB2OplockLevelBatch = 0x09
        with Documentation {Description = "A batch oplock was granted."},
    OplockLevelLease = 0xFF
        with Documentation
            {Description = "A lease is requested. If set, the response packet MUST contain an SMB2_CREATE_RESPONSE_LEASE create context."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2CreateResponseCreateAction = enum ULONG
{
    FileSuperseded = 0x00000000
        with Documentation
            {Description = "An existing file was deleted and a new file was created in its place."},
    FileOpened = 0x00000001
        with Documentation {Description = "An existing file was opened."},
    FileCreated = 0x00000002
        with Documentation {Description = "A new file was created."},
    FileOverwritten = 0x00000003
        with Documentation {Description = "An existing file was overwritten."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.31   SMB2 IOCTL Request
type SMB2IoctlRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 57, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2IoctlRequest", 57, value)
        with Documentation
            {Description = "The client MUST set this field to 57, indicating the size of the request structure, not including the header. The client MUST set this field to this value regardless of how long Buffer[] actually is in the request being sent."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2IoctlRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt."};
    
    ULONG CtlCode with DisplayInfo{ToText = SMB2.CtlCodeToText},
        Documentation
            {Description = "The control code of the FSCTL/IOCTL method. The values are listed in subsequent sections, and in [MS-FSCC] section . The following values indicate SMB2-specific processing as specified in sections  and ."};

    SMB2Fileid FileId
        with Documentation
            {Description = "An SMB2_FILEID identifier of the file on which to perform the command."};

    ULONG InputOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the input data buffer. If no input data is required for the FSCTL/IOCTL command being issued, the client SHOULD set this value to 0.If no input data is required for the FSCTL/IOCTL command being issued, windows-based clients set this field to any value."};

    ULONG InputCount
        with Documentation {Description = "The size, in bytes, of the input data."};

    ULONG MaxInputResponse
        with Documentation
            {Description = "The maximum number of bytes that the server can return for the input data in the SMB2 IOCTL Response."};

    ULONG OutputOffset
        with Documentation
            {Description = "The client SHOULD set this to 0.windows clients set the OutputOffset field equal to the InputOffset field."};

    ULONG OutputCount where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB2", "OutputCount", "SMB2IoctlRequest", value)
        with Documentation {Description = "The client MUST set this to 0."};

    ULONG MaxOutputResponse
        with Documentation
            {Description = "The maximum number of bytes that the server can return for the output data in the SMB2 IOCTL Response."};

    SMB2IoctlRequestFlags Flags
        where ValidationCheck(InRange<SMB2IoctlRequestFlags>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "Flags", COMMON_STR_TYPE, "SMB2IoctlRequest", COMMON_STR_MUST, "0x00000000, 0x00000001", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "A Flags field indicating how to process the operation. This field MUST be constructed using one of the following values."};

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2IoctlRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt."};

    optional [|InputOffset > 120|] array<byte> Padding with BinaryEncoding{Length = InputOffset - 120 as uint};

    ([|InputCount == 0|] Empty
        | [|(CtlCode is SMB2IoctlCtlCode.FsctlSrvCopychunk || CtlCode is SMB2IoctlCtlCode.FsctlSrvCopychunkWrite)|] SrvCopychunkCopy
        | [|CtlCode is SMB2IoctlCtlCode.FsctlPipeWait|] FSCTLPipeWaitRequest
        | [|CtlCode is SMB2IoctlCtlCode.FsctlSrvReadHash|] SrvReadHashRequest
        | [|CtlCode is SMB2IoctlCtlCode.FsctlLmrRequestResiliency|] NetworkResiliencyRequest
        | [|CtlCode is SMB2IoctlCtlCode.FsctlSetReparsePoint|] FSCTLSetReparsePointRequest
        | [|CtlCode is SMB2IoctlCtlCode.FsctlLmrSetLinkTrackingInformation|] FSCTLLmrSetLinkTrackingInformationRequestForSmb2
        | [|CtlCode is SMB2IoctlCtlCode.FsctlGetRetrievalPointers|] FSCTLGetRetrievalPointersRequest
        | [|CtlCode is SMB2IoctlCtlCode.FsctlOffloadRead|] FSCTLOffloadReadRequest
        | [|CtlCode is SMB2IoctlCtlCode.FsctlOffloadWrite|] FSCTLOffloadWriteRequest
        | [|CtlCode is SMB2IoctlCtlCode.FsctlFileLevelTrim|] FSCTLFileLevelTrimRequest
        | [|CtlCode is SMB2IoctlCtlCode.FsctlValidateNegotiateInfo|] ValidateNegotiateInfoRequest
        
        | [|CtlCode is CtlCode.FSCTLDeleteReparsePoint|] FSCTLDeleteReparsePointRequest
        | [|CtlCode is CtlCode.FSCTLFindFilesBySID|] FSCTLFindFilesBySIDRequest
        | [|CtlCode is CtlCode.FSCTLGetCompression|] FSCTLGetCompressionReply
        | [|CtlCode is CtlCode.FSCTLIsPathnameValid|] FSCTLIsPathnameValidRequest
        | [|CtlCode is CtlCode.FSCTLQueryAllocatedRanges|] FSCTLQueryAllocatedRangesRequest
        | [|CtlCode is CtlCode.FSCTLQueryFileRegions|] FSCTLQueryFileRegionsRequest
        | [|CtlCode is CtlCode.FSCTLSetCompression|] FSCTLSetCompressionRequest
        | [|CtlCode is CtlCode.FSCTLSetDefectManagement|] FSCTLSetDefectManagementRequest
        | [|CtlCode is CtlCode.FSCTLSetEncryption|] FSCTLSetEncryptionRequest
        | [|CtlCode is CtlCode.FSCTLSetIntegrityInformation|] FSCTLSetIntegrityInformationRequest
        | [|CtlCode is CtlCode.FSCTLSetObjectID|] FSCTLSetObjectIdRequest
        | [|CtlCode is CtlCode.FSCTLSetObjectIDExtended|] FSCTLSetObjectIdExtendedRequest
        | [|CtlCode is CtlCode.FSCTLSetSparse|] FSCTLSetSparseRequest
        | [|CtlCode is CtlCode.FSCTLSetZeroData|] FSCTLSetZeroDataRequest
        | [|CtlCode is CtlCode.FSCTLSisCopyfile|] FSCTLSisCopyfileRequest
        
        | binary) Buffer // WORKAROUND: Remove Length = InputCount aspect to surpport the partial packet
        with Documentation
                {Description = "A variable-length buffer that contains the input and output data buffer for the request, as described by the InputOffset, InputCount, OutputOffset, and OutputCount. There is no minimum size restriction for this field as there can be FSCTLs with no input or output buffers. For FSCTL_SRV_COPYCHUNK or FSCTL_SRV_COPYCHUNK_WRITE, the format of this buffer is specified in SRV_COPYCHUNK_COPY. The Buffer format for FSCTL_DFS_GET_REFERRALS is specified in [MS-DFSC] section . The format of this buffer for all other FSCTLs is specified in the reference topic for the FSCTL being called."};
}
with Documentation
       {Description = "The SMB2 IOCTL Request packet is sent by a client to issue an implementation-specific file system control or device control(FSCTL/IOCTL) command across the network. For a list of IOCTL operations, see section  and [MS-FSCC] section . This request is composed of an SMB2 header, as specified in section , followed by this request structure."};

pattern SMB2IoctlCtlCode = enum ULONG
{
    FsctlDfsGetReferrals = 0x00060194,
    FsctlPipePeek = 0x0011400C,
    FsctlPipeWait = 0x00110018,
    FsctlPipeTransceive = 0x0011C017,
    FsctlSrvCopychunk = 0x001440F2,
    FsctlSrvEnumerateSnapshots = 0x00144064,
    FsctlSrvRequestResumeKey = 0x00140078,
    FsctlSrvReadHash = 0x001441bb,
    FsctlSrvCopychunkWrite = 0x001480F2,
    FsctlLmrRequestResiliency = 0x001401D4,
    FsctlQueryNetworkInterfaceInfo = 0x001401FC,
    FsctlSetReparsePoint = 0x000900A4,
    FsctlLmrSetLinkTrackingInformation = 0x001400EC,
    FsctlDfsGetReferralsEx = 0x000601B0,
    FsctlGetRetrievalPointers = 0x00090073,
    FsctlOffloadRead = 0x00094264,
    FsctlOffloadWrite = 0x00098268,
    FsctlFileLevelTrim = 0x00098208,
    FsctlValidateNegotiateInfo = 0x00140204,
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2IoctlRequestFlags = enum ULONG
{
    SMB20Ioctl = 0x00000000
        with Documentation
            {Description = "If Flags is set to this value, the request is an IOCTL request."},
    SMB20IoctlIsFsctl = 0x00000001
        with Documentation
            {Description = "If Flags is set to this value, the request is an FSCTL request."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.31.1   SRV_COPYCHUNK_COPY
type SrvCopychunkCopy
{
    array<byte> SourceKey
        with BinaryEncoding{Length = 24},
         Documentation
            {Description = "A key, obtained from the server in a SRV_REQUEST_RESUME_KEY Response , that represents the source file for the copy."};

    ULONG ChunkCount
        with Documentation
            {Description = "The number of chunks of data that are to be copied."};

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2IoctlRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. This field MUST be set to 0 by the client, and ignored by the server."};

    array<SrvCopyChunk> Chunks
        with BinaryEncoding{Length = ChunkCount},
             Documentation
                {Description = "An array of packets describing the ranges to be copied. This array MUST be of a length equal to ChunkCount * size of SRV_COPYCHUNK."};
}
with Documentation
       {Description = "The SRV_COPYCHUNK_COPY packet is sent in an SMB2 IOCTL Request by the client to initiate a server-side copy of data. It is set as the contents of the input data buffer. This packet consists of the following:"};

// 2.2.31.1.1   SRV_COPYCHUNK
type SrvCopyChunk
{
    UINT64 SourceOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the source file to the location from which the data will be copied."};

    UINT64 TargetOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the destination file to where the data will be copied."};

    ULONG Length
        with Documentation {Description = "The number of bytes of data to copy."};

    ULONG Reserved
        with Documentation
            {Description = "This field SHOULD be set to zero and MUST be ignored on receipt"};
}
with Documentation
       {Description = "The SRV_COPYCHUNK packet is sent in the Chunks array of a SRV_COPYCHUNK_COPY packet to describe an individual data range to copy. This packet consists of the following:"};

// 2.2.31.2   SRV_READ_HASH Request
type SrvReadHashRequest
{
    SrvReadHashHashType HashType
        where ValidationCheck(InRange<SrvReadHashHashType>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_VALUE, ["SMB2", "HashType", COMMON_STR_TYPE, "SrvReadHashRequest", COMMON_STR_MUST, "0x00000001", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The hash type of the request indicates what the hash is used for. This field MUST be set to the following value:"};

    SrvReadHashHashVersion HashVersion
        where ValidationCheck(InRange<SrvReadHashHashVersion>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "HashVersion", COMMON_STR_TYPE, "SrvReadHashRequest", COMMON_STR_MUST, "0x00000001, 0x00000002", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The version number of the algorithm used to create the Content Information. This field MUST be set to the following value:"};

    SrvReadHashHashRetrievalType HashRetrievalType
        where ValidationCheck(InRange<SrvReadHashHashRetrievalType>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "HashRetrievalType", COMMON_STR_TYPE, "SrvReadHashRequest", COMMON_STR_MUST, "0x00000001, 0x00000002", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "Indicates the nature of the Offset field.  This field MUST be set to the following value:"};

    ULONG Length
        with Documentation
            {Description = "If HashRetrievalType is SRV_HASH_RETRIEVE_HASH_BASED, this value is the maximum length, in bytes, of the hash data to be returned in the SRV_READ_HASH response to the client. If HashRetrievalType is SRV_HASH_RETRIEVE_FILE_BASED, this value is the maximum length, in bytes, of the file data for which the hash information is to be retrieved and returned in the SRV_READ_HASH response to the client."};

    UINT64 Offset
        with Documentation
            {Description = "This value is the offset of the data to be retrieved, in bytes, from the beginning of the Content Information File."};
}
with Documentation
       {Description = "The SRV_READ_HASH request is sent to the server by the client in an SMB2 IOCTL Request FSCTL_SRV_READ_HASH to retrieve data from the Content Information File associated with a specified file. The request is valid only for the SMB 2.1 dialect. It is set as the contents of the input data buffer. This packet consists of the following:"};

pattern SrvReadHashHashType = enum ULONG
{
    SrvHashTypePeerDist = 0x00000001
        with Documentation
            {Description = "Indicates the hash is requested for branch caching as described in [MS-PCCRC]."},
    ...
} with Documentation {EmbeddedType = true};

pattern SrvReadHashHashVersion = enum ULONG
{
    SrvHashVer1 = 0x00000001
        with Documentation {Description = "Branch cache version 1."},
    SrvHashVer2 = 0x00000002
        with Documentation {Description = "Branch cache version 2. This value is only applicable for the SMB 3.x dialect family."},
    ...
} with Documentation {EmbeddedType = true};

pattern SrvReadHashHashRetrievalType = enum ULONG
{
    SrvReadRetrieveHashBased = 0x00000001
        with Documentation
            {Description = "The Offset field in the SRV_READ_HASH request is relative to the beginning of the Content Information File."},
    SrvReadRetrieveFileBased = 0x00000002
        with Documentation
            {Description = "The Offset field in the SRV_READ_HASH request is relative to the beginning of the file indicated by the FileId field in the IOCTL request. This value is only applicable for the SMB 3.x dialect family."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.31.3   NETWORK_RESILIENCY_REQUEST Request
type NetworkResiliencyRequest
{
    ULONG Timeout
        with Documentation
            {Description = "The requested time the server should hold the file open after a disconnect before releasing it. This time is in milliseconds."};

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "NetworkResiliencyRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};
}
with Documentation
       {Description = "The NETWORK_RESILIENCY_REQUEST request packet is sent to the server by the client in an SMB2 IOCTL Request FSCTL_LMR_REQUEST_RESILIENCY to request resiliency for a specified open file. The request is valid only for the SMB 2.1 dialect. It is set as the contents of the input data buffer. This packet consists of the following:"};

// 2.2.31.4   VALIDATE_NEGOTIATE_INFO Request
type ValidateNegotiateInfoRequest
{
    SMB2NegotiateRequestCapabilities Capabilities
        with Documentation
            {Description = "The Capabilities of the client."};

    GUID GUID
        with Documentation
            {Description = "The ClientGuid of the client."};

    SMB2NegotiateRequestSecurityMode SecurityMode
        with Documentation
            {Description = "The SecurityMode of the client."};

    USHORT DialectCount
        with Documentation
            {Description = "The number of entries in the Dialects field."};

    array<SMB2NegotiateRequestDialects> Dialects with BinaryEncoding{Length = DialectCount as uint},
        Documentation
            {Description = "The list of SMB2 dialects supported by the client. These entries SHOULD contain only the 2-byte Dialects values defined in section 2.2.3."};
}
with Documentation
       {Description = "The VALIDATE_NEGOTIATE_INFO request packet is sent to the server by the client in an SMB2 IOCTL Request FSCTL_VALIDATE_NEGOTIATE_INFO to request validation of a previous SMB 2 NEGOTIATE. The request is valid for clients and servers which implement the SMB 3.x dialect family."};

       
// 2.2.32   SMB2 IOCTL Response
type SMB2IoctlResponse[uint? HashRetrievalType, uint? HashVersion]
{
    USHORT StructureSize where ValidationCheckValue(value == 49, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2IoctlResponse", 49, value)
        with Documentation
            {Description = "The server MUST set this field to 49, indicating the size of the response structure, not including the header. This value MUST be used regardless of how large Buffer[] is in the actual response."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2IoctlResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this field to 0, and the client MUST ignore it on receipt."};

    ULONG CtlCode with DisplayInfo{ToText = SMB2.CtlCodeToText},
        Documentation
            {Description = "The control code of the FSCTL/IOCTL method that was executed. SMB2-specific values are listed in section 2.2.31."};

    SMB2Fileid FileId where ValidationCheck((CtlCode != SMB2IoctlCtlCode.FsctlDfsGetReferrals && CtlCode != SMB2IoctlCtlCode.FsctlPipeWait) || (value.Persistent == InvalidFileId && value.Volatile == InvalidFileId), null, DiagnosisLevel.Error, "SMB2: The FileId field in type SMB2IoctlResponse must be set to 0xFFFFFFFFFFFFFFFF if the CtlCode field value is FsctlDFS_GET_REFERRALS or FsctlPIPE_WAIT.")
        with Documentation
            {Description = "An SMB2_FILEID identifier of the file on which the command was performed. If the CtlCode field value is FSCTL_DFS_GET_REFERRALS or FSCTL_PIPE_WAIT, this field MUST be set to { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF } by the server and MUST be ignored by the client."};

    ULONG InputOffset
        with Documentation
            {Description = "InputOffset SHOULD be set to the offset, in bytes, from the beginning of the SMB2 header to the Buffer[] field of the IOCTL response."};

    ULONG InputCount
        with Documentation
            {Description = "InputCount SHOULD<55> be set to zero in the IOCTL response. An exception for pass-through operations is discussed in section 3.3.5.15.8."};

    ULONG OutputOffset where ValidationCheck(value == 0 ||
                                             value == ((InputOffset + InputCount) % 8 != 0 ? ((InputOffset + InputCount) / 8 * 8 + 8) : InputCount + InputOffset),
                                null, "SMB2: The OutputOffset field in type SMB2IoctlResponse must be set to InputOffset + InputCount rounded up to a multiple of 8 if output data is returned. If no output data is returned for the FSCTL/IOCTL command that was issued, then this value should be set to zero.")
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the output data buffer. If output data is returned, the output offset MUST be set to InputOffset + InputCount rounded up to a multiple of 8. If no output data is returned for the FSCTL/IOCTL command that was issued, then this value SHOULD<56> be set to 0."};

    ULONG OutputCount
        with Documentation {Description = "The size, in bytes, of the output data."};

    ULONG Flags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Flags", "SMB2IoctlResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this field to 0, and the client MUST ignore it on receipt."};

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2IoctlResponse", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this field to 0, and the client MUST ignore it on receipt."};

    // Buffer part
    optional [|InputOffset > 112|] array<byte> InputBufferPadding with BinaryEncoding{Length = InputOffset - 112 as uint};
    binary InputBuffer with BinaryEncoding{Length = InputCount};
    optional [|OutputOffset > 112 && OutputOffset > InputOffset + InputCount|] array<byte> OutputBufferPadding with BinaryEncoding{Length = OutputOffset - InputOffset - InputCount as uint};
    
    ( [|OutputCount == 0|] Empty
        | [|CtlCode is SMB2IoctlCtlCode.FsctlPipePeek|] FSCTLPipePeekReply[OutputCount]
        | [|CtlCode is SMB2IoctlCtlCode.FsctlSrvCopychunk || CtlCode is SMB2IoctlCtlCode.FsctlSrvCopychunkWrite|] SrvCopychunkResponse
        | [|CtlCode is SMB2IoctlCtlCode.FsctlSrvEnumerateSnapshots|] SrvSnapshotArray
        | [|CtlCode is SMB2IoctlCtlCode.FsctlSrvRequestResumeKey|] SrvRequestResumeKeyResponse
        | [|CtlCode is SMB2IoctlCtlCode.FsctlQueryNetworkInterfaceInfo|] NetworkInterfaceInfoResponse
        | [|CtlCode is SMB2IoctlCtlCode.FsctlGetRetrievalPointers|] FSCTLGetRetrievalPointersReply
        | [|CtlCode is SMB2IoctlCtlCode.FsctlOffloadRead|] FSCTLOffloadReadOutput
        | [|CtlCode is SMB2IoctlCtlCode.FsctlOffloadWrite|] FSCTLOffloadWriteOutput
        | [|CtlCode is SMB2IoctlCtlCode.FsctlFileLevelTrim|] FileLevelTrimOutput
        | [|CtlCode is SMB2IoctlCtlCode.FsctlValidateNegotiateInfo|] ValidateNegotiateInfoResponse
        
        // The SRV_READ_HASH response is returned to the client by the server in an SMB2 IOCTL Response for the FSCTL_SRV_READ_HASH request.
        | [|CtlCode is SMB2IoctlCtlCode.FsctlSrvReadHash && HashRetrievalType == SrvReadHashHashRetrievalType.SrvReadRetrieveHashBased|] ResponseForSrvHashRetrieveHashBased[HashVersion]
        | [|CtlCode is SMB2IoctlCtlCode.FsctlSrvReadHash && HashRetrievalType == SrvReadHashHashRetrievalType.SrvReadRetrieveFileBased|] ResponseForSrvHashRetrieveFileBased[HashVersion]
        
        | [|CtlCode is CtlCode.FSCTLCreateOrGetObjectID|] FSCTLCreateOrGetObjectIDReply
        | [|CtlCode is CtlCode.FSCTLFilesystemGetStatistics|] FSCTLFilesystemGetStatisticsReply
        | [|CtlCode is CtlCode.FSCTLFindFilesBySID|] FSCTLFindFilesBySIDReply
        | [|CtlCode is CtlCode.FSCTLGetCompression|] FSCTLGetCompressionReply
        | [|CtlCode is CtlCode.FSCTLGetIntegrityInformation|] FSCTLGetIntegrityInformationReply
        | [|CtlCode is CtlCode.FSCTLGetNTFSVolumeData|] FSCTLGetNtfsVolumeDataReply
        | [|CtlCode is CtlCode.FSCTLGetObjectID|] FSCTLGetObjectIdReply
        | [|CtlCode is CtlCode.FSCTLGetReparsePoint|] FSCTLGetReparsePointReply
        | [|CtlCode is CtlCode.FSCTLQueryFatBPB|] FSCTLQueryFatBpbReply
        | [|CtlCode is CtlCode.FSCTLQueryAllocatedRanges|] FSCTLQueryAllocatedRangesReply
        | [|CtlCode is CtlCode.FSCTLQueryFileRegions|] FSCTLQueryFileRegionsReply
        | [|CtlCode is CtlCode.FSCTLQueryOnDiskVolumeInfo|] FSCTLQueryOnDiskVolumeInfoReply
        | [|CtlCode is CtlCode.FSCTLQuerySparingInfo|] FSCTLQuerySparingInfoReply
        | [|CtlCode is CtlCode.FSCTLReadFileUSNData|] USNRecord
        | [|CtlCode is CtlCode.FSCTLWriteUSNCloseRecord|] FSCTLWriteUSNCloseRecordReply
        
        | binary
        | any ) Buffer // WORKAROUND: Remove Length = OutputCount aspect to surpport the partial packet
        with Documentation
                {Description = "A variable-length buffer that contains the input and output data buffer for the response, as described by InputOffset, InputCount, OutputOffset, and OutputCount. For more details, refer to section 3.3.5.15."};
}
with Documentation
       {Description = "The SMB2 IOCTL Response packet is sent by the server to transmit the results of a client SMB2 IOCTL Request. This response consists of an SMB2 header, as specified in section , followed by this response structure:"};

// 2.2.32.1   SRV_COPYCHUNK_RESPONSE
type SrvCopychunkResponse
{
    ULONG ChunksWritten
        with Documentation
            {Description = "If the Status field in the SMB2 header of the response is not STATUS_INVALID_PARAMETER, as specified in [MS-ERREF] section , this value indicates the number of chunks that were successfully written. If the Status field in the SMB2 header of the response is STATUS_INVALID_PARAMETER, this value indicates the maximum number of chunks that the server will accept in a single request. This would allow the client to correctly reissue the request."};

    ULONG ChunkBytesWritten
        with Documentation
            {Description = "If the Status field in the SMB2 header of the response is not STATUS_INVALID_PARAMETER, as specified in [MS-ERREF] section , this value indicates the number of bytes written in the last chunk that did not successfully process(if a partial write occurred). If the Status field in the SMB2 header of the response is STATUS_INVALID_PARAMETER, this value indicates the maximum number of bytes the server will allow to be written in a single chunk."};

    ULONG TotalBytesWritten
        with Documentation
            {Description = "If the Status field in the SMB2 header of the response is not STATUS_INVALID_PARAMETER, as specified in [MS-ERREF] section , this value indicates the total number of bytes written in the server-side copy operation. If the Status field in the SMB2 header of the response is STATUS_INVALID_PARAMETER, this value indicates the maximum number of bytes the server will accept to copy in a single request."};
}
with Documentation
       {Description = "The SRV_COPYCHUNK_RESPONSE packet is sent in an SMB2 IOCTL Response by the server to return the results of a server-side copy operation. It is placed in the Buffer field of the SMB2 IOCTL Response packet. This packet consists of the following:"};

// 2.2.32.2   SRV_SNAPSHOT_ARRAY
type SrvSnapshotArray
{
    ULONG NumberOfSnapShots
        with Documentation
            {Description = "The number of previous versions associated with the volume that backs this file."};

    ULONG NumberOfSnapShotsReturned
        with Documentation
            {Description = "The number of previous version time stamps returned in the SnapShots[] array. If the output buffer could not accommodate the entire array, NumberOfSnapShotsReturned will be zero."};

    ULONG SnapShotArraySize
        with Documentation
            {Description = "The length, in bytes, of the SnapShots[] array. If the output buffer is too small to accommodate the entire array, SnapShotArraySize will be the amount of space that the array would have occupied."};

    optional [|NumberOfSnapShotsReturned > 0|] array<string> SnapShots with BinaryEncoding{Length = NumberOfSnapShotsReturned}
        with Documentation
            {Description = "An array of time stamps in GMT format, as specified by an GMT token, which are separated by UNICODE null characters and terminated by two UNICODE null characters. It will be empty if the output buffer could not accommodate the entire array."};
    optional [|NumberOfSnapShotsReturned > 0|] NullTerminator Terminator;
}
with Documentation
       {Description = "The SRV_SNAPSHOT_ARRAY packet is returned to the client by the server in an SMB2 IOCTL Response for the FSCTL_SRV_ENUMERATE_SNAPSHOTS request, as specified in section . This packet MUST contain all the revision time-stamps that are associated with the Tree Connect share in which the open resides, provided that the buffer size required is less than or equal to the maximum output buffer size received in the SMB2 IOCTL request. This SRV_SNAPSHOT_ARRAY is placed in the Buffer field in the SMB2 IOCTL Response,windows-based SMB2 server will place 2 extra bytes set to zero in the SRV_SNAPSHOT_ARRAY response, if NumberOfSnapShotsReturned is zero. and the OutputOffset and OutputCount fields MUST be updated to describe the buffer as specified in section . This packet consists of the following:"};

pattern NullTerminator = ushort where value == 0;

// 2.2.32.3   SRV_REQUEST_RESUME_KEY Response
type SrvRequestResumeKeyResponse
{
     array<byte> ResumeKey
        with BinaryEncoding{Length = 24},
         Documentation
            {Description = "A 24-byte resume key generated by the server that can be subsequently used by the client to uniquely identify the source file in an FsctlSRV_COPYCHUNK or FsctlSRV_COPYCHUNK_WRITE request. The resume key MUST be treated as a 24-byte opaque structure. The client that receives the 24-byte resume key MUST NOT attach any interpretation to this key and MUST treat it as an opaque value."};

    ULONG ContextLength where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB2", "ContextLength", "SrvRequestResumeKeyResponse", value)
        with Documentation
            {Description = "The length, in bytes, of the context information. This field is unused. The server MUST set this field to 0, and the client MUST ignore it on receipt."};

    ULONG Context
        with Documentation
            {Description = "The context extended information.windows-based servers windows_vista and windows_server_2008windows_vista, windows_server_2008, windows_7, and windows_server_7 always send 4 bytes of zero for the Context field."};
}
with Documentation
       {Description = "The SRV_REQUEST_RESUME_KEY packet is returned to the client by the server in an SMB2 IOCTL Response for the FsctlSRV_REQUEST_RESUME_KEY request. This SRV_REQUEST_RESUME_KEY is placed in the Buffer field in the SMB2 IOCTL Response, and the OutputOffset and OutputCount fields MUST be updated to describe the buffer as specified in section . This packet consists of the following:"};

// 2.2.32.4.1   HASH_HEADER
type HashHeader[uint? ReqHashVersion]
{
    HashHeaderHashType HashType
        with Documentation
            {Description = "The hash type of the request indicates what the hash is used for. This field MUST be constructed using the following value."};

    HashHeaderHashVersion HashVersion
        where ValidationCheck(InRange<HashHeaderHashVersion>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "HashVersion", COMMON_STR_TYPE, "HashHeader", COMMON_STR_MUST, "0x00000001, 0x00000002", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The version number of the algorithm that is used to create the Content Information algorithm. This field MUST be constructed using the following value."};

    FILETIME SourceFileChangeTime
        with Documentation
            {Description = "The last update time for the source file from which the Content Information is generated, in FILETIME format as specified in [MS-DTYP] section ."};

    UINT64 SourceFileSize
        with Documentation
            {Description = "The length, in bytes, of the source file from which the Content Information is generated."};

    ULONG HashBlobLength
        with Documentation
            {Description = "The length, in bytes, of the Content Information."};

    ULONG HashBlobOffset
        with Documentation
            {Description = "The offset of the Content Information, in bytes, from the beginning of the Content Information File."};

    USHORT Dirty
        with Documentation
            {Description = "A flag that indicates whether the Content Information File is currently being updated. A nonzero value indicates TRUE."};

    USHORT SourceFileNameLength
        with Documentation
            {Description = "The length, in bytes, of the source file full name."};

    string SourceFileName 
        with BinaryEncoding{Length = SourceFileNameLength / 2 as uint},
             Documentation
                {Description = "A variable-length buffer that contains the source file full name, with length indicated by SourceFileNameLength.windows–based SMB2 servers and clients do not check SourceFileName. It is ignored."};
}
with Documentation
       {Description = "All Content Information Files MUST start with a valid format HASH_HEADER as follows. The format is valid only for the SMB 2.1 dialect."};

pattern HashHeaderHashType = flags
{
    SrvHashTypePeerDist = 0x00000001
        with Documentation
            {Description = "Indicates that the hash is requested for branch caching as described in [MS-PCCRC]."},
}with Documentation {EmbeddedType = true};

pattern HashHeaderHashVersion = enum ULONG
{
    SrvHashVer1 = 0x00000001
        with Documentation {Description = "Branch cache version 1."},

    SrvHashVer2 = 0x00000002
        with Documentation {Description = "Branch cache version 2. This value is only applicable for servers that implement the SMB 3.x dialect family."},
    ...
} with Documentation {EmbeddedType = true}; 

type ContentInformationFile[ULONG BufferLength, uint? HashVersion]
{
    // Content Information File
    HashHeader[HashVersion] Header;
    // WORKAROUND: Remove this padding. Related bug#16407: TrailPadding/LeadPadding in BinaryEncoding aspect doesn't effect
    optional [|Header.HashBlobOffset > 36 + Header.SourceFileNameLength|] array<byte> Padding with BinaryEncoding{Length = Header.HashBlobOffset - 36 - Header.SourceFileNameLength as uint};
    optional ([|Header.HashVersion == HashHeaderHashVersion.SrvHashVer1|] ContentInformationVersion10
        | [|Header.HashVersion == HashHeaderHashVersion.SrvHashVer2|] ContentInformationVersion20) ContentInformation with BinaryEncoding{Length = ((SMB2DialectRevision == SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber) ? (BufferLength - Header.HashBlobOffset) : Header.HashBlobLength)}; 
}

// 2.2.32.4.2   Response for SRV_HASH_RETRIEVE_HASH_BASED
type ResponseForSrvHashRetrieveHashBased[uint? HashVersion]
{
    UINT64 Offset
        with Documentation 
            {Description = "The offset, in bytes, from the beginning of the Content Information File to the portion retrieved. This is equal to the Offset field in the SRV_READ_HASH request."};

    ULONG BufferLength
        with Documentation 
            {Description = "The length, in bytes, of the retrieved portion of the Content Information File."};

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "ResponseForSrvHashRetrieveHashBased", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this field to 0, and the client MUST ignore it on receipt."};

    ContentInformationFile[BufferLength, HashVersion] Buffer
        with Documentation
            {Description = "A variable-length buffer that contains the retrieved portion of the Content Information File, as specified in [MS-PCCRC] section 2.3."};
}
with Documentation
        {Description = "Some of the information in this section is subject to change because it applies to a preliminary implementation of the protocol or structure. For information about specific differences between versions, see the behavior notes that are provided in the Product Behavior appendix."};

// 2.2.32.4.3   Response for SRV_HASH_RETRIEVE_FILE_BASED
type ResponseForSrvHashRetrieveFileBased[uint? HashVersion]
{
    UINT64  FileDataOffset
        with Documentation
            {Description = "File data offset corresponding to the start of the hash data returned."};
    
    UINT64 FileDataLength
        with Documentation
            {Description = "The length, in bytes, starting from the FileDataOffset that is covered by the hash data returned."};
    
    ULONG BufferLength
        with Documentation
            {Description = "The length, in bytes, of the retrieved portion of the Content Information File."};
    
    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "ResponseForSrvHashRetrieveFileBased", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The server MUST set this field to zero, and the client MUST ignore it on receipt."};
    
    ContentInformationFile[BufferLength, HashVersion] Buffer
        with Documentation
            {Description = "A variable-length buffer that contains the retrieved portion of the Content Information File, as specified in [MS-PCCRC] section 2.4."};
}
with Documentation
        {Description = "This response is valid for servers that implement the SMB 3.x dialect family. If the HashRetrievalType in the request is SRV_HASH_RETRIEVE_FILE_BASED, the SRV_READ_HASH response MUST be formatted as follows"};

// 2.2.32.5   NETWORK_INTERFACE_INFO Response
type NetworkInterfaceInfoResponse
{
    ULONG Next
        with Documentation
            {Description = "The offset, in bytes, from the beginning of this structure to the beginning of a subsequent 8-byte aligned network interface. This field MUST be set to zero if there are no subsequent network interfaces."};
    
    ULONG IfIndex
        with Documentation
            {Description = "This field specifies the network interface index."};
    
    NetworkInterfaceInfoResponseCapability Capability
        with Documentation
            {Description = "This field specifies the capabilities of the network interface. This field MUST be constructed using zero or more of the following values"};
    
    ULONG Reserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "NetworkInterfaceInfoResponse", value)
        with Documentation
            {Description = "This field MUST be set to zero and the client MUST ignore it on receipt."};
    
    UINT64 LinkSpeed
        with Documentation
            {Description = "The field specifies the speed of the network interface in bits per second."};
    
    SockAddrStorage SockAddrStorage 
        with Documentation
            {Description = "The field describes socket address information as specified in section 2.2.32.5.1."};
    
    optional [|Next > 152|] array<byte> EntryPadding with BinaryEncoding{Length = Next - 152 as uint};
    optional [|Next != 0|] NetworkInterfaceInfoResponse NextEntry;
}

pattern NetworkInterfaceInfoResponseCapability = flags ULONG
{
    RssCapable = 0x00000001
        with Documentation
            {Description = "When set, specifies that the interface is RSS-capable."},
    
    RdmaCapable = 0x00000002
        with Documentation
            {Description = "When set, specifies that the interface is RDMA-capable."}
} with Documentation {EmbeddedType = true};

//2.2.32.5.1   SOCKADDR_STORAGE
type SockAddrStorage
{
    AddressFamily Family
        with Documentation
            {Description = "Address family of the socket. This field MUST contain one of the following values:"};
            
    ([|Family is AddressFamily.InterNetwork|] SockAddrIn
     | [|Family is AddressFamily.InterNetworkV6|] SockAddrIn6) Buffer
        with Documentation
            {Description = "A variable-length buffer that contains the socket address information. If the value of the field Family is 0x0002, this field MUST be interpreted as SOCKADDR_IN, specified in . Otherwise, if the value of the field Family is 0x0017, this field MUST be interpreted as SOCKADDR_IN6, specified in ."};
     
     binary Reserved
        with BinaryEncoding{Length = (128 - 2 - (Family == AddressFamily.InterNetwork ? 14: 26)) as uint},
            Documentation
                {Description = "The remaining bytes within the size of SOCKADDR_STORAGE structure (128 bytes) MUST NOT be used and MUST be reserved. The server SHOULD set this to zero, and the client MUST ignore it on receipt."};
}

pattern AddressFamily = enum USHORT
{
    InterNetwork = 0x0002
        with Documentation
            {Description = "When set, indicates an IPv4 address in the socket"},
            
    InterNetworkV6 = 0x0017
        with Documentation
            {Description = "When set, indicates an IPv6 address in the socket"},
} with Documentation {EmbeddedType = true};

//2.2.32.5.1.1   SOCKADDR_IN
type SockAddrIn
{
    USHORT Port where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "Port", "SockAddrIn", value)
        with Documentation {Description = "This field MUST NOT be used and MUST be reserved. The server SHOULD set this field to zero, and the client MUST ignore it on receipt."};

    IPv4Address IPv4Address        
        with Documentation {Description = "IPv4 address."};

    UINT64 Reserved where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "Reserved", "SockAddrIn", value)
        with Documentation {Description = "This field MUST NOT be used and MUST be reserved. The server SHOULD set this field to zero, and the client MUST ignore it on receipt."};
} with BinaryEncodingDefaults{Endian = Endian.Big},
    Documentation
        {Description = "This socket address information is a 14-byte structure formatted as follows. All fields in this structure are in network byte order."};

//2.2.32.5.1.2   SOCKADDR_IN6
type SockAddrIn6
{
    USHORT Port where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "Port", "SockAddrIn6", value)
        with Documentation {Description = "This field MUST NOT be used and MUST be reserved. The server SHOULD set this field to zero, and the client MUST ignore it on receipt."};
    
    ULONG FlowInfo where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "FlowInfo", "SockAddrIn6", value)
        with Documentation {Description = "The server SHOULD set this field to zero, and the client MUST ignore it on receipt."};

    IPv6Address IPv6Address
        with Documentation {Description = "IPv6 address."};
            
    ULONG ScopeId where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "ScopeId", "SockAddrIn6", value)
        with Documentation {Description = "The server SHOULD set this field to zero, and the client MUST ignore it on receipt."};
} with BinaryEncodingDefaults{Endian = Endian.Big},
    Documentation
        {Description = "This socket address information is a 26-byte structure formatted as follows. All fields in this structure are in network byte order."};        
        
// 2.2.32.6   VALIDATE_NEGOTIATE_INFO Response
type ValidateNegotiateInfoResponse
{
    SMB2NegotiateResponseCapabilities Capability
        with Documentation
            {Description = "The Capabilities of the server."};
    
    GUID GUID
        with Documentation
            {Description = "The ServerGuid of the server."};
    
    SMB2NegotiateResponseSecurityMode SecurityMode
        with Documentation
            {Description = "The SecurityMode of the server."};
    
    SMB2NegotiateResponseDialectRevision Dialect
        with Documentation
            {Description = "The SMB2 dialect in use by the server on the connection."};
}

// 2.2.33   SMB2 QUERY_DIRECTORY Request
type SMB2QueryDirectoryRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 33, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2QueryDirectoryRequest", 33, value)
        with Documentation
            {Description = "The client MUST set this field to 33, indicating the size of the request structure, not including the header. The client MUST set this field to this value regardless of how long Buffer[] actually is in the request being sent."};

    SMB2QueryDirectoryRequestFileInformationClass FileInformationClass
        where ValidationCheck(InRange<SMB2QueryDirectoryRequestFileInformationClass>(value), null, DiagnosisLevel.Error,
            () => Format(COMMON_STR_CHECK_ENUM_VALUE, ["SMB2", "FileInformationClass", COMMON_STR_TYPE, "SMB2QueryDirectoryRequest", COMMON_STR_MUST, "0x01, 0x02, 0x26, 0x03, 0x25, 0x0C", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The file information class describing the format that data MUST be returned in. Possible values are as specified in [MS-FSCC] section . This field MUST contain one of the following values:"};

    SMB2QueryDirectoryRequestFlags Flags
        with Documentation
            {Description = "Flags indicating how the query directory operation MUST be processed. This field MUST be a logical OR of the following values, or zero if none are selected:"};

    ULONG FileIndex where ValidationCheck(((Flags & SMB2QueryDirectoryRequestFlags.SMB2IndexSpecified) > 0 && value !=0)
        || ((Flags & SMB2QueryDirectoryRequestFlags.SMB2IndexSpecified) == 0 && value ==0), null, DiagnosisLevel.Error, "SMB2: For the FileIndex in type SMB2QueryDirectoryRequest, if SMB2_INDEX_SPECIFIED is set in Flags, this value must be supplied. Otherwise, it must be set to zero and the server must ignore it.")
        with Documentation
            {Description = "The byte offset within the directory, indicating the position at which to resume the enumeration. If SMB2_INDEX_SPECIFIED is set in Flags, this value MUST be supplied, and should be based on the FileIndex value received in a previous enumeration response. Otherwise, it MUST be set to zero and the server MUST ignore it."};

    SMB2Fileid FileId
        with Documentation
            {Description = "An SMB2Fileid identifier of the directory on which to perform the enumeration. This is returned from an SMB2 Create Request to open a directory on the server."};

    USHORT FileNameOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the search pattern to be used for the enumeration. This field MUST be 0 if no search pattern is provided."};

    USHORT FileNameLength where ValidationCheck((FileNameOffset == 0 && value == 0) || (FileNameOffset != 0 && value != 0), null, DiagnosisLevel.Error, 
        () => "SMB2: The FileNameLength in type SMB2QueryDirectoryRequest must be zero, not " + Utility.DecToHexFormat(value) + ".")
        with Documentation
            {Description = "The length, in bytes, of the search pattern. This field MUST be 0 if no search pattern is provided."};

    ULONG OutputBufferLength
        with Documentation
            {Description = "The maximum number of bytes the server is allowed to return in the SMB2 QUERY_DIRECTORY Response."};
    
    // WORKAROUND: Remove this padding. Related bug#16407: TrailPadding/LeadPadding in BinaryEncoding aspect doesn't effect
    optional [|FileNameOffset > 9|] array<byte> Padding with BinaryEncoding{Length = FileNameOffset - 96 as uint};
    string Buffer with BinaryEncoding{Length = FileNameLength / 2 as uint}, //LeadPadding = (FileNameOffset - 96) * 8 as uint},
         Documentation
            {Description = "A variable-length buffer containing the Unicode search pattern for the request, as described by the FileNameOffset and FileNameLength fields. The format, including wildcards and other conventions for this pattern, is specified in [MS-CIFS] section .SMB2 wildcard characters are based on windows wildcard characters, as described in [MS-FSA] section 3.1.4.4, Algorithm for Determining if a FileName Is in an Expression. For more information on wildcard behavior in windows, see [FSBO] section 7."};
}
with Documentation
       {Description = "The SMB2 QUERY_DIRECTORY Request packet is sent by the client to obtain a directory enumeration on a directory open. This request consists of an SMB2 header, as specified in section , followed by this request structure:"};

pattern SMB2QueryDirectoryRequestFileInformationClass = enum BYTE
{
    FileDirectoryInformation = 0x01
        with Documentation
            {Description = "Basic information about a file or directory. Basic information is defined as the file's name, time stamp, size and attributes. File attributes are as specified in [MS-FSCC] section ."},
    FileFullDirectoryInformation = 0x02
        with Documentation
            {Description = "Full information about a file or directory. Full information is defined as all the basic information plus extended attribute size."},
    FileIdFullDirectoryInformation = 0x26
        with Documentation
            {Description = "Full information plus volume file ID about a file or directory. A volume file ID is defined as a number assigned by the underlying object store that uniquely identifies a file within a volume."},
    FileBothDirectoryInformation = 0x03
        with Documentation
            {Description = "Basic information plus extended attribute size and short name about a file or directory."},
    FileIdBothDirectoryInformation = 0x25
        with Documentation
            {Description = "FileBothDirectoryInformation plus volume file ID about a file or directory."},
    FileNamesInformation = 0x0C
        with Documentation
            {Description = "Detailed information on the names of files and directories in a directory."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2QueryDirectoryRequestFlags = flags BYTE
{
   SMB2RestartScans = 0x01
       with Documentation
          {Description = "The server MUST restart the enumeration from the beginning, but the search pattern is not changed."},
   SMB2ReturnSingleEntry = 0x02
       with Documentation
          {Description = "The server MUST only return the first entry of the search results."},
   SMB2IndexSpecified = 0x04
       with Documentation
          {Description = "The server SHOULDwindows-based servers do not support resuming an enumeration at a specified FileIndex. The server will ignore this flag. return entries beginning at the byte number specified by FileIndex."},
   SMB2Reopen = 0x10
       with Documentation
          {Description = "The server MUST restart the enumeration from the beginning, and the search pattern MUST be changed to the provided value. This often involves silently closing and reopening the directory on the server side."},
} with Documentation {EmbeddedType = true};


// 2.2.34   SMB2 QUERY_DIRECTORY Response
type SMB2QueryDirectoryResponse[optional byte QueryInfoClass]
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2QueryDirectoryResponse", 9, value)
        with Documentation
            {Description = "The server MUST set this field to 9, indicating the size of the request structure, not including the header. The server MUST set this field to this value regardless of how long Buffer[] actually is in the request."};

    USHORT OutputBufferOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the directory enumeration data being returned."};

    ULONG OutputBufferLength
        with Documentation
            {Description = "The length, in bytes, of the directory enumeration being returned."};

    optional [|OutputBufferOffset > 72|] array<byte> Padding with BinaryEncoding{Length = OutputBufferOffset - 72 as uint};

    ([|OutputBufferLength > 0 && QueryInfoClass != nothing && (QueryInfoClass as byte) is SMB2QueryDirectoryRequestFileInformationClass|] SMB20InfoFileBuffer[QueryInfoClass as byte]
        |binary) Buffer // WORKAROUND: Remove Length = OutputBufferLength aspect to surpport the partial packet
        where ValidationCheck(!(QueryInfoClass is nothing), null, DiagnosisLevel.Error, "SMB2: Failed to decode the Buffer field in type SMB2QueryDirectoryResponse in detail because the corresponding request message is missing.")
        with Documentation
                {Description = "A variable-length buffer containing the directory enumeration being returned in the response, as described by the OutputBufferOffset and OutputBufferLength. The format of this content is as specified in [MS-FSCC] section , within the topic for the specific file information class referenced in the SMB2 QUERY_DIRECTORY Request."};
}
with Documentation
       {Description = "The SMB2 QUERY_DIRECTORY Response packet is sent by a server in response to an SMB2 QUERY_DIRECTORY Request. This response consists of an SMB2 header, as specified in section , followed by this response structure:"};

// 2.2.35   SMB2 CHANGE_NOTIFY Request
type SMB2ChangeNotifyRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 32, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2WriteResponse", 32, value)
        with Documentation
            {Description = "The client MUST set this field to 32, indicating the size of the request structure, not including the header."};

    SMB2ChangeNotifyRequestFlags Flags
        with Documentation
            {Description = "Flags indicating how the operation MUST be processed. This field MUST be either zero or the following value"};

    ULONG OutputBufferLength
        with Documentation
            {Description = "The maximum number of bytes the server is allowed to return in the SMB2 CHANGE_NOTIFY Response."};

    SMB2Fileid FileId
        with Documentation
            {Description = "An SMB2Fileid identifier of the directory to monitor for changes."};

    SMB2ChangeNotifyRequestCompletionFilter CompletionFilter
        with Documentation
            {Description = "Specifies the types of changes to monitor. It is valid to choose multiple trigger conditions. In this case, if any condition is met, the client is notified of the change and the CHANGE_NOTIFY operation is completed. This field MUST be constructed using the following values:"};

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2ChangeNotifyRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt."};
}
with Documentation
       {Description = "The SMB2 CHANGE_NOTIFY Request packet is sent by the client to request change notifications on a directory. This request consists of an SMB2 header, as specified in section , followed by this request structure:"};

pattern SMB2ChangeNotifyRequestFlags = flags USHORT
{
    SMB2WatchTree = 0x0001
        with Documentation
               {Description = "The request MUST monitor changes on any file or directory contained beneath the directory specified by FileId."},
}with Documentation {EmbeddedType = true};


pattern SMB2ChangeNotifyRequestCompletionFilter =  flags ULONG
{
    FileNotifyChangeFileName = 0x00000001
        with Documentation
            {Description = "The client is notified if a file-name changes."},
    FileNotifyChangeDirName = 0x00000002
        with Documentation
            {Description = "The client is notified if a directory name changes."},
    FileNotifyChangeAttributes = 0x00000004
        with Documentation
            {Description = "The client is notified if a file's attributes change. Possible file attribute values are specified in [MS-FSCC]."},
    FileNotifyChangeSize = 0x00000008
        with Documentation
            {Description = "The client is notified if a file's size changes."},
    FileNotifyChangeLastWrite = 0x00000010
        with Documentation
            {Description = "The client is notified if the last write time of a file changes."},
    FileNotifyChangeLastAccess = 0x00000020
        with Documentation
            {Description = "The client is notified if the last access time of a file changes."},
    FileNotifyChangeCreation = 0x00000040
        with Documentation
            {Description = "The client is notified if the creation time of a file changes."},
    FileNotifyChangeEa = 0x00000080
        with Documentation
            {Description = "The client is notified if a file's extended attributes(EAs) change."},
    FileNotifyChangeSecurity = 0x00000100
        with Documentation
            {Description = "The client is notified of a file's access control list(ACL) settings change."},
    FileNotifyChangeStreamName = 0x00000200
        with Documentation
            {Description = "The client is notified if a named stream is added to a file."},
    FileNotifyChangeStreamSize = 0x00000400
        with Documentation
            {Description = "The client is notified if the size of a named stream is changed."},
    FileNotifyChangeStreamWrite = 0x00000800
        with Documentation
            {Description = "The client is notified if a named stream is modified."},
} with Documentation {EmbeddedType = true};


// 2.2.36   SMB2 CHANGE_NOTIFY Response
type SMB2ChangeNotifyResponse
{
    USHORT StructureSize where ValidationCheck(value == 9, null, DiagnosisLevel.Error, 
        () => "SMB2: The StructureSize in type SMB2ChangeNotifyResponse must be set to 9, not " + Utility.DecToHexFormat(value) + ".")
        with Documentation
            {Description = "The server MUST set this field to 9, indicating the size of the request structure, not including the header. The server MUST set the field to this value regardless of how long Buffer[] actually is in the request being sent."};

    USHORT OutputBufferOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the change information being returned."};

    ULONG OutputBufferLength
        with Documentation
            {Description = "The length, in bytes, of the change information being returned."};
    
    optional [|OutputBufferOffset > 72|] array<byte> BufferPadding with BinaryEncoding{Length = OutputBufferOffset - 72 as uint};

    optional [|OutputBufferLength > 0|] array<FileNotifyInformation> Buffer //BinaryEncoding{Length = OutputBufferLength},
        where ValidationCheck(GetLastOffset() == 0, null, DiagnosisLevel.Error, "SMB2: The NextEntryOffset field in the last entry of FileNotifyInformation array must be zero, not " + (GetLastOffset() as string) + ".")
        with Documentation
            {Description = "A variable-length buffer containing the change information being returned in the response, as described by the OutputBufferOffset and OutputBufferLength fields. This field is an array of FILE_NOTIFY_INFORMATION."};
    
    uint GetLastOffset()
    {
        if (Buffer != nothing)
        {
            var buffer = Buffer as array<FileNotifyInformation>;
            if (buffer.Count > 0)
            {
                return buffer[buffer.Count - 1].NextEntryOffset;
            }
        }
        return 0;
    }
}
with Documentation
       {Description = "The SMB2 CHANGE_NOTIFY Response packet is sent by the server to transmit the results of a client's SMB2 CHANGE_NOTIFY Request. The server MUST send this packet only if a change occurs and MUST NOT send this packet otherwise. An SMB2 CHANGE_NOTIFY Request will result in, at most, one response from the server. A server may choose to aggregate multiple changes into the same change notify response. The server MUST include at least one FILE_NOTIFY_INFORMATION structure if it detects a change. This response consists of an SMB2 header, as specified in section , followed by this response structure:"};

// 2.2.37   SMB2 QUERY_INFO Request
type SMB2QueryInfoRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 41, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2QueryInfoRequest", 41, value)
        with Documentation
            {Description = "The client MUST set this field to 41, indicating the size of the request structure, not including the header. The client MUST set this field to this value regardless of how long Buffer[] actually is in the request being sent."};

    BYTE InfoType
        where ValidationCheckEnumValue(InRange<SMB2QueryInfoRequestInfoType>(value), null, true, ReferenceType.Type, "SMB2", "InfoType", "SMB2QueryInfoRequest", "0x01, 0x02, 0x03, 0x04", value)
        with Documentation
            {Description = "The type of information queried. This field MUST contain one of the following values:"};

    ([|InfoType is SMB2QueryInfoRequestInfoType.SMB20InfoFile|] FileInformationClasses
       | [|InfoType is SMB2QueryInfoRequestInfoType.SMB20InfoFilesystem|] FileSystemInformationClasses
       | BYTE) FileInfoClass where ValidationCheck(InfoType != SMB2QueryInfoRequestInfoType.SMB20InfoSecurity && InfoType != SMB2QueryInfoRequestInfoType.SMB20InfoQuota || value == 0, null, DiagnosisLevel.Error, 
       () => "SMB2: SMB2QueryInfoRequest.FileInfoClass, for security queries, this field must be set to zero. For quota queries, this field should be set to zero, not " + Utility.DecToHexFormat(value) + ".")
        with Documentation
            {Description = "For file information queries, this field MUST contain one of the following FILE_INFORMATION_CLASS values, as specified in section  and in [MS-FSCC] section :"};

    ULONG OutputBufferLength
        where ValidationCheck((FileInfoClass != FileInformationClasses.FileFullEaInformation) || OutputBufferLength == 0, null, "SMB2: The OutputBufferLength field in type SMB2QueryInfoRequest must be set to zero for a FileFullEaInformation query.")
        with Documentation
            {Description = "The maximum number of bytes of information the server can send in the response."};

    USHORT InputBufferOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the input buffer. For quota requests, the input buffer MUST contain an SMB2_QUERY_QUOTA_INFO, as specified in section . For FileFullEaInformation requests, the input buffer MUST contain the user supplied EA list with zero or more FILE_GET_EA_INFORMATION structures, specified in?[MS-FSCC] section . For other information queries, this field SHOULDwindows clients set this value to the offset from the start of the SMB2 header to the beginning of the Buffer field. be set to 0."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2QueryInfoRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt."};

    ULONG InputBufferLength where ValidationCheck(InfoType is SMB2QueryInfoRequestInfoType.SMB20InfoQuota || FileInfoClass is FileInformationClasses.FileFullEaInformation || value == 0, null, DiagnosisLevel.Error, 
        () => "SMB2: The InputBufferLength in type SMB2QueryInfoRequest, for FileFullEaInformation requests, this must be set to the length of the user-supplied EA list specified in [MS-FSCC]. For other information queries, this field must be set to zero, not " + Utility.DecToHexFormat(value) + ".")
        with Documentation
            {Description = "The length of the input buffer. For quota requests, this MUST be the length of the contained SMB2_QUERY_QUOTA_INFO embedded in the request. For FileFullEaInformation requests, this MUST be set to the length of the user supplied EA list specified in [MS-FSCC] section . For other information queries, this field MUST be set to 0."};

    ([|InfoType is SMB2QueryInfoRequestInfoType.SMB20InfoSecurity|] SMB2QueryInfoRequestAdditionalInformation
     | [|FileInfoClass is FileInformationClasses.FileFullEaInformation|] ULONG
     | ZeroUint) AdditionalInformation
        with Documentation
            {Description = "Provides additional information to the server."};

    // Future Reference: Add ValidationCheck after bug 27596 is fixed
    SMB2QueryInfoRequestFlags Flags// where ValidationCheck(FileInfoClass == FileInformationClasses.FileFullEaInformation || value == 0, null, "SMB2: For the Flags int type SMB2QueryInfoRequest, if the query is not a FileFullEaInformation query, this field must be set to zero, not " + Utility.DecToHexFormat(value) + ".")
        with Documentation
            {Description = "The flags MUST be set to a combination of zero or more of these bit values for a FileFullEaInformation query."};

    SMB2Fileid FileId
        with Documentation
            {Description = "An SMB2Fileid identifier of the file or named pipe on which to perform the query. Queries for underlying object store or quota information are directed to the volume on which the file resides."};

    optional [|InputBufferOffset > 104|] array<byte> BufferPadding with  BinaryEncoding{Length = InputBufferOffset - 104 as uint};
    
    ([|InputBufferLength > 0 && InfoType is SMB2QueryInfoRequestInfoType.SMB20InfoQuota|] SMB2QueryQuotaInfo
        | [|InputBufferLength > 0 && FileInfoClass is FileInformationClasses.FileFullEaInformation|] FileGetEaInformationList
        /* note<64> Windows clients send a 1-byte buffer of 0 when InputBufferLength is set to 0.
         * So the length of Buffer is not simply equal to InputBufferLength when InputBufferLength is set to 0.
         */
        | binary) Buffer // WORKAROUND: Remove Length = InputBufferLength aspect to surpport the partial packet
         with Documentation
                {Description = "A variable-length buffer containing the input buffer for the request, as described by the InputBufferOffset and InputBufferLength fields.Windows clients send a 1-byte buffer of 0 when InputBufferLength is set to 0."};
}
with Documentation
       {Description = "The SMB2 QUERY_INFO Request packet is sent by a client to request information on a file, named pipe, or underlying volume. This request consists of an SMB2 header, as specified in section , followed by this request structure:"};

pattern SMB2QueryInfoRequestInfoType = enum BYTE
{
    SMB20InfoFile = 0x01
        with Documentation {Description = "The file information is requested."},
    SMB20InfoFilesystem = 0x02
        with Documentation
            {Description = "The underlying object store information is requested."},
    SMB20InfoSecurity = 0x03
        with Documentation {Description = "The security information is requested."},
    SMB20InfoQuota = 0x04
        with Documentation
            {Description = "The underlying object store quota information is requested."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2QueryInfoRequestFlags = flags ULONG
{
    SLRestartScan = 0x00000001
        with Documentation
            {Description = "Restart the scan for EAs from the beginning."},
    SLReturnSingleEntry = 0x00000002
        with Documentation
            {Description = "Return a single EA entry in the response buffer."},
    SLIndexSpecified = 0x00000004
        with Documentation {Description = "The caller has specified an EA index."},
} with Documentation {EmbeddedType = true};

pattern SMB2QueryInfoRequestAdditionalInformation = flags ULONG
{
    OwnerSecurityInformation = 0x00000001
        with Documentation
            {Description = "The client is querying the owner from the security descriptor of the file or named pipe."},
    GroupSecurityInformation = 0x00000002
        with Documentation
            {Description = "The client is querying the group from the security descriptor of the file or named pipe."},
    DaclSecurityInformation = 0x00000004
        with Documentation
            {Description = "The client is querying the discretionary access control list from the security descriptor of the file or named pipe."},
    SaclSecurityInformation = 0x00000008
        with Documentation
            {Description = "The client is querying the system access control list from the security descriptor of the file or named pipe."},
    LabelSecurityInformation = 0x00000010
        with Documentation
            {Description = "The client is querying the integrity label from the security descriptor of the file or named pipe."}
} with Documentation {EmbeddedType = true};

// 2.2.37.1   SMB2_QUERY_QUOTA_INFO
type SMB2QueryQuotaInfo
{
    BOOLEAN ReturnSingle
        with Documentation
            {Description = "A BOOLEAN value, where zero represents FALSE and nonzero represents TRUE.windows clients set this field to 1 for TRUE. If the ReturnSingle field is TRUE, the server MUST return a single value. Otherwise, the server SHOULD return the maximum number of entries that will fit in the maximum output size that is indicated in the request."};

    BOOLEAN RestartScan
        with Documentation
            {Description = "A BOOLEAN value, where zero represents FALSE and nonzero represents TRUE.windows clients set this field to 1 for TRUE. If RestartScan is TRUE, the quota information MUST be read from the beginning. Otherwise, the quota information MUST be continued from the previous enumeration that was executed on this open."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2QueryQuotaInfo", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt."};

    ULONG SidListLength
        with Documentation
            {Description = "The length, in bytes, of the SidBuffer when sent in format 1 as defined in the SidBuffer field or zero in all other cases."};

    ULONG StartSidLength
        with Documentation
            {Description = "The length, in bytes, of the SID, as specified in [MS-DTYP] section , when sent in format 2 as defined in the SidBuffer field, or zero in all other cases."};

    ULONG StartSidOffset
        with Documentation
            {Description = "The offset, in bytes, from the start of the SidBuffer field to the SID when sent in format 2 as defined in the SidBuffer field, or zero in all other cases."};

    optional [|StartSidOffset > 0|] array<byte> Padding with BinaryEncoding{Length = StartSidOffset};
    ([|SidListLength > 0|] FileGetQuotaInformationList
     | [|StartSidLength > 0|] SID
     | Empty) SidBuffer
        with Documentation
            {Description = "If this field is empty, then SidListLength, StartSidLength and StartSidOffset MUST each be set to zero. If the field is not empty, then it MUST contain either one of the following two formats:"};
}
with Documentation
       {Description = "The SMB2_QUERY_QUOTA_INFO packet specifies the quota information to return."};

// 2.2.38   SMB2 QUERY_INFO Response
type SMB2QueryInfoResponse[optional byte QueryInfoType, optional byte QueryInfoClass]
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2QueryInfoResponse", 9, value)
        with Documentation
            {Description = "The server MUST set this field to 9, indicating the size of the request structure, not including the header. The server MUST set this field to this value regardless of how long Buffer[] actually is in the request being sent."};

    USHORT OutputBufferOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the information being returned."};

    ULONG OutputBufferLength
        with Documentation
            {Description = "The length, in bytes, of the information being returned."};

    optional [|OutputBufferOffset > 72|] array<byte> BufferPadding with BinaryEncoding{Length = OutputBufferOffset - 72 as uint};

    ([|OutputBufferLength == 0|] Empty
        | [|QueryInfoType is nothing || QueryInfoClass is nothing|] binary
        | [|QueryInfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFile|] SMB20InfoFileBuffer[QueryInfoClass as byte]
        | [|QueryInfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFilesystem|] SMB20InfoFilesystemBuffer[QueryInfoClass as byte]
        | [|QueryInfoType == SMB2QueryInfoRequestInfoType.SMB20InfoSecurity|] SECURITY_DESCRIPTOR_NonRpc
        | [|QueryInfoType == SMB2QueryInfoRequestInfoType.SMB20InfoQuota|] FileQuotaInformationList) Buffer
        // WORKAROUND: Remove Length = OutputBufferLength aspect to surpport the partial packet
        // Can't use ReportInsufficientData in where clause
        where ValidationCheck(!(Buffer is binary), null, DiagnosisLevel.Error, "SMB2: Failed to decode the Buffer field in type SMB2QueryInfoResponse in detail because the corresponding request message is missing.")
        with Documentation
                {Description = "A variable-length buffer that contains the information that is returned in the response, as described by the OutputBufferOffset and OutputBufferLength fields. Buffer format depends on InfoType and AdditionalInformation, as follows."};
}
with Documentation
       {Description = "The SMB2 QUERY_INFO Response packet is sent by the server in response to an SMB2 QUERY_INFO Request packet. This response consists of an SMB2 header, as specified in section , followed by this response structure."};

// Comment off the list type temperally for UI freeze issue.
type SMB20InfoFileBuffer[byte AdditionalInformation]
{
    ([|AdditionalInformation is FileInformationClasses.FileDirectoryInformation|] FileDirectoryInformationList
    | [|AdditionalInformation is FileInformationClasses.FileFullDirectoryInformation|] FileFullDirectoryInformationList
    | [|AdditionalInformation is FileInformationClasses.FileBothDirectoryInformation|] FileBothDirectoryInformationList
    | [|AdditionalInformation is FileInformationClasses.FileBasicInformation|] FileBasicInformation
    | [|AdditionalInformation is FileInformationClasses.FileStandardInformation|] FileStandardInformation
    | [|AdditionalInformation is FileInformationClasses.FileInternalInformation|] FileInternalInformation
    | [|AdditionalInformation is FileInformationClasses.FileEaInformation|] FileEaInformation
    | [|AdditionalInformation is FileInformationClasses.FileAccessInformation|] FileAccessInformation
    | [|AdditionalInformation is FileInformationClasses.FileNameInformation|] FileNameInformation
    | [|AdditionalInformation is FileInformationClasses.FileRenameInformation|] FileRenameInformationForSMB2
    | [|AdditionalInformation is FileInformationClasses.FileLinkInformation|] FileLinkInformationForSMB2
    | [|AdditionalInformation is FileInformationClasses.FileNamesInformation|] FileNamesInformationList
    | [|AdditionalInformation is FileInformationClasses.FileDispositionInformation|] FileDispositionInformation
    | [|AdditionalInformation is FileInformationClasses.FilePositionInformation|] FilePositionInformation
    | [|AdditionalInformation is FileInformationClasses.FileFullEaInformation|] FileFullEaInformation
    | [|AdditionalInformation is FileInformationClasses.FileModeInformation|] FileModeInformation
    | [|AdditionalInformation is FileInformationClasses.FileAlignmentInformation|] FileAlignmentInformation
    | [|AdditionalInformation is FileInformationClasses.FileAllInformation|] FileAllInformation
    | [|AdditionalInformation is FileInformationClasses.FileAllocationInformation|] FileAllocationInformation
    | [|AdditionalInformation is FileInformationClasses.FileEndOfFileInformation|] FileEndOfFileInformation
    | [|AdditionalInformation is FileInformationClasses.FileAlternateNameInformation|] FileAlternateNameInformation
    | [|AdditionalInformation is FileInformationClasses.FileStreamInformation|] FileStreamInformationList
    | [|AdditionalInformation is FileInformationClasses.FilePipeInformation|] FilePipeInformation
    | [|AdditionalInformation is FileInformationClasses.FilePipeLocalInformation|] FilePipeLocalInformation
    | [|AdditionalInformation is FileInformationClasses.FilePipeRemoteInformation|] FilePipeRemoteInformation
    | [|AdditionalInformation is FileInformationClasses.FileMailslotQueryInformation|] FileMailslotQueryInformation
    | [|AdditionalInformation is FileInformationClasses.FileMailslotSetInformation|] FileMailslotSetInformation
    | [|AdditionalInformation is FileInformationClasses.FileCompressionInformation|] FileCompressionInformation
    | [|AdditionalInformation is FileInformationClasses.FileObjectIdInformation|] FileObjectIdInformationType
    | [|AdditionalInformation is FileInformationClasses.FileQuotaInformation|] FileQuotaInformationList
    | [|AdditionalInformation is FileInformationClasses.FileReparsePointInformation|] FileReparsePointInformation
    | [|AdditionalInformation is FileInformationClasses.FileNetworkOpenInformation|] FileNetworkOpenInformation
    | [|AdditionalInformation is FileInformationClasses.FileAttributeTagInformation|] FileAttributeTagInformation
    | [|AdditionalInformation is FileInformationClasses.FileIdBothDirectoryInformation|] FileIdBothDirectoryInformationList
    | [|AdditionalInformation is FileInformationClasses.FileIdFullDirectoryInformation|] FileIdFullDirectoryInformationList
    | [|AdditionalInformation is FileInformationClasses.FileValidDataLengthInformation|] FileValidDataLengthInformation
    | [|AdditionalInformation is FileInformationClasses.FileShortNameInformation|] FileShortNameInformation
    | [|AdditionalInformation is FileInformationClasses.FileSfioReserveInformation|] FileSfioReserveInformation
    | [|AdditionalInformation is FileInformationClasses.FileHardLinkInformation|] FileHardLinkInformation
    | [|AdditionalInformation is FileInformationClasses.FileIdGlobalTxDirectoryInformation|] FileIdGlobalTxDirectoryInformationList
    | [|AdditionalInformation is FileInformationClasses.FileStandardLinkInformation|] FileStandardLinkInformation) SMB20InfoFile;
}

pattern FileObjectIdInformationType = FileObjectIdInformationType2 | FileObjectIdInformationType1;

type SMB20InfoFilesystemBuffer[byte AdditionalInformation]
{
    ([|AdditionalInformation is FileSystemInformationClasses.FileFsVolumeInformation|] FileFsVolumeInformation
    | [|AdditionalInformation is FileSystemInformationClasses.FileFsLabelInformation|] FileFsLabelInformation
    | [|AdditionalInformation is FileSystemInformationClasses.FileFsSizeInformation|] FileFsSizeInformation
    | [|AdditionalInformation is FileSystemInformationClasses.FileFsDeviceInformation|] FileFsDeviceInformation
    | [|AdditionalInformation is FileSystemInformationClasses.FileFsAttributeInformation|] FileFsAttributeInformation
    | [|AdditionalInformation is FileSystemInformationClasses.FileFsControlInformation|] FileFsControlInformation
    | [|AdditionalInformation is FileSystemInformationClasses.FileFsFullSizeInformation|] FileFsFullSizeInformation
    | [|AdditionalInformation is FileSystemInformationClasses.FileFsObjectIdInformation|] FileFsObjectIdInformation
    | [|AdditionalInformation is FileSystemInformationClasses.FileFsDriverPathInformation|] FileFsDriverPathInformation
    | [|AdditionalInformation is FileSystemInformationClasses.FileFsSectorSizeInformation|] FileFsSectorSizeInformation) SMB20InfoFilesystem;
}

// 2.2.39   SMB2 SET_INFO Request
type SMB2SetInfoRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 33, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2SetInfoRequest", 33, value)
        with Documentation
            {Description = "The client MUST set this field to 33, indicating the size of the request structure, not including the header. The client MUST set this field to this value regardless of how long Buffer[] actually is in the request being sent."};

    BYTE InfoType
        where ValidationCheckEnumValue(InRange<SMB2SetInfoRequestInfoType>(value), null, false, ReferenceType.Type, "SMB2", "InfoType", "SMB2SetInfoRequest","0x01, 0x02, 0x03, 0x04", value)
        with Documentation
            {Description = "The type of information being set. The valid values are as follows."};

    BYTE FileInfoClass where ValidationCheck((InfoType is SMB2SetInfoRequestInfoType.SMB20InfoFile && value in {FileInformationClasses.FileAllocationInformation,
                                                                                                                FileInformationClasses.FileBasicInformation,
                                                                                                                FileInformationClasses.FileDispositionInformation,
                                                                                                                FileInformationClasses.FileEndOfFileInformation,
                                                                                                                FileInformationClasses.FileFullEaInformation,
                                                                                                                FileInformationClasses.FileLinkInformation,
                                                                                                                FileInformationClasses.FileModeInformation,
                                                                                                                FileInformationClasses.FilePipeInformation,
                                                                                                                FileInformationClasses.FilePositionInformation,
                                                                                                                FileInformationClasses.FileRenameInformation,
                                                                                                                FileInformationClasses.FileShortNameInformation,
                                                                                                                FileInformationClasses.FileValidDataLengthInformation})
                                            || (InfoType is SMB2SetInfoRequestInfoType.SMB20InfoFilesystem && value in {FileSystemInformationClasses.FileFsControlInformation,
                                                                                                                      FileSystemInformationClasses.FileFsObjectIdInformation})
                                            || (InfoType in [SMB2SetInfoRequestInfoType.SMB20InfoQuota, SMB2SetInfoRequestInfoType.SMB20InfoSecurity] && value == 0),
                                null, "SMB2: The FileInfoClass field in type SMB2SetInfoRequest is an undefined value. Please refer to SMB2 SET_INFO Request in Technical Document MS-SMB2.")
        with Documentation
            {Description = "For setting file information, this field MUST contain one of the following FILE_INFORMATION_CLASS values, as specified in section  and [MS-FSCC] section :"};

    ULONG BufferLength
        with Documentation
            {Description = "The length, in bytes, of the information to be set."};

    USHORT BufferOffset
        with Documentation
            {Description = "The offset, in bytes, from the beginning of the SMB2 header to the information to be set."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2SetInfoRequest", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this field to 0, and the server MUST ignore it on receipt."};

    ([|InfoType is SMB2SetInfoRequestInfoType.SMB20InfoSecurity|] SMB2SetInfoRequestAdditionalInformation
     | ZeroUint) AdditionalInformation
        with Documentation
            {Description = "Provides additional information to the server."};

    SMB2Fileid FileId
        with Documentation
            {Description = "An SMB2Fileid identifier of the file or named pipe on which to perform the set. Set operations for underlying object store and quota information are directed to the volume on which the file resides."};

    optional [|BufferOffset > 96|] array<byte> BufferPadding with BinaryEncoding{Length = BufferOffset - 96 as uint};
    
    ([|BufferLength == 0|] Empty
     | [|InfoType is SMB2SetInfoRequestInfoType.SMB20InfoFile|] SMB20InfoFileBuffer[FileInfoClass]
     | [|InfoType is SMB2SetInfoRequestInfoType.SMB20InfoFilesystem|] SMB20InfoFilesystemBuffer[FileInfoClass]
     | [|InfoType is SMB2SetInfoRequestInfoType.SMB20InfoSecurity|] SECURITY_DESCRIPTOR_NonRpc
     | [|InfoType is SMB2SetInfoRequestInfoType.SMB20InfoQuota|] FileQuotaInformationList
     | binary) Buffer // WORKAROUND: Remove Length = BufferLength aspect to surpport the partial packet
        with Documentation
             {Description = "A variable-length buffer that contains the information being set for the request, as described by the BufferOffset and BufferLength fields. Buffer format depends on InfoType and the AdditionalInformation, as follows."};
}
with Documentation
       {Description = "The SMB2 SET_INFO Request packet is sent by a client to set information on a file or underlying object store. This request consists of an SMB2 header, as specified in section , followed by this request structure."};

pattern SMB2SetInfoRequestInfoType = enum BYTE
{
    SMB20InfoFile = 0x01
        with Documentation {Description = "The file information is being set."},
    SMB20InfoFilesystem = 0x02
        with Documentation
            {Description = "The underlying object store information is being set."},
    SMB20InfoSecurity = 0x03
        with Documentation {Description = "The security information is being set."},
    SMB20InfoQuota = 0x04
        with Documentation
            {Description = "The underlying object store quota information is being set."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2SetInfoRequestAdditionalInformation = flags
{
    OwnerSecurityInformation = 0x00000001
        with Documentation
            {Description = "The client is setting the owner in the security descriptor of the file or named pipe."},
    GroupSecurityInformation = 0x00000002
        with Documentation
            {Description = "The client is setting the group in the security descriptor of the file or named pipe."},
    DaclSecurityInformation = 0x00000004
        with Documentation
            {Description = "The client is setting the discretionary access control list in the security descriptor of the file or named pipe."},
    SaclSecurityInformation = 0x00000008
        with Documentation
            {Description = "The client is setting the system access control list in the security descriptor of the file or named pipe."},
    LabelSecurityInformation = 0x00000010
        with Documentation
           {Description = "The client is setting the integrity label in the security descriptor of the file or named pipe."}
}with Documentation {EmbeddedType = true};

// 2.2.40   SMB2 SET_INFO Response 
type SMB2SetInfoResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 2, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2SetInfoResponse", 2, value)
        with Documentation
            {Description = "The server MUST set this field to 2, indicating the size of the request structure, not including the header."};
}
with Documentation
       {Description = "The SMB2 SET_INFO Response packet is sent by the server in response to an SMB2 SET_INFO Request to notify the client that its request has been successfully processed. This response consists of an SMB2 header, as specified in section , followed by this response structure:"};

// 2.2.41   SMB2 TRANSFORM_HEADER
type SMB2TransformHeader[ushort EncryptAlgorithm]
{
    ULONG ProtocolId where ValidationCheckValue(value == 0xFD534D42, null, true, ReferenceType.Type, "SMB2", "ProtocolId", "SMB2TransformHeader", "(in network order) 0xFD, 'S', 'M', and 'B'", value)
        with BinaryEncoding {Endian = Endian.Big},
            Documentation
                {Description = "The protocol identifier. The value MUST be (in network order) 0xFE, 'S', 'M', and 'B'."};

    binary Signature with BinaryEncoding{Length = 16},
        Documentation
            {Description = "The 16-byte signature of the encrypted message generated by using Session.EncryptionKey."};
    
    ([|EncryptAlgorithm is SMB2TransformHeaderEncryptionAlgorithm.SMB2EncryptionAes128Ccm|] SMB2EncryptionAES128Nonce
        | binary) Nonce with BinaryEncoding{Length = 16},
            Documentation
                {Description = "An implementation-specific value assigned for every encrypted message. This MUST NOT be reused for all encrypted messages within a session."};
    
    ULONG OriginalMessageSize
        with Documentation
            {Description = "The size, in bytes, of the SMB2 message."};

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TransformHeader", value)
        with Documentation
            {Description = "This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it on receipt."};

    SMB2TransformHeaderEncryptionAlgorithm EncryptionAlgorithm
        where ValidationCheck(InRange<SMB2TransformHeaderEncryptionAlgorithm>(value), null, DiagnosisLevel.Error, 
            () => Format(COMMON_STR_CHECK_VALUE, ["SMB2", "EncryptionAlgorithm", COMMON_STR_TYPE, "SMB2TransformHeader", COMMON_STR_MUST, "0x00000001", Utility.DecToHexFormat(value)]))
        with Documentation
            {Description = "The algorithm used for encrypting the SMB2 message. This field MUST be set to one of the following values."};

    UINT64 SessionId
        with Documentation
            {Description = "Uniquely identifies the established session for the command."};
}
with Documentation
        {Description = "The SMB2 Transform Header is used by the client or server when sending the encrypted messages. This header is only valid for the SMB 3.x dialect family."};

type SMB2EncryptionAES128Nonce
{
    binary AES128_Nonce with BinaryEncoding{Length = 11},
        Documentation
            {Description = "An implementation-specific value assigned for every encrypted message. This MUST NOT be reused for all encrypted messages within a session."};

    binary Reserved with BinaryEncoding{Length = 5},
            Documentation {Description = "The sender SHOULD set this field to 0, and the receiver MUST ignore it on receipt."};
}
        
pattern SMB2TransformHeaderEncryptionAlgorithm = enum USHORT
{
    SMB2EncryptionAes128Ccm = 0x00000001
        with Documentation
            {Description ="The message is encrypted by using the AES128 algorithm."},
    ...
} with Documentation {EmbeddedType = true};

// -------------------------------------------
// Helper function
 
// Get the binary value of ProtocolId from NBTSS.SessionService message
binary GetProtocolIdBin(NBTSS.SessionService m)
{
    switch (m.Trailer)
    {
        case p: SessionMessagePacket =>
            if (p.UserData.Count > 4)
            {
                return p.UserData.Segment(0,4);
            }
    }
    return $[];
}

// Get the binary value of ProtocolId from NBTSS.SessionService message
binary GetProtocolIdBin(SMBOverTCP.TransportPacket m)
{
    if (m.SMBMessage.Count > 4)
    {
        return m.SMBMessage.Segment(0, 4);
    }
    return $[];
}

// Judge an error response message according to section 3.3.4.4 Sending an Error Response
bool IsErrorResponse(ushort commmand, uint status, ushort size, bool asyncCommand)
{
    //An error code other than one of the following indicates a failure:
    if ((commmand == SMB2PacketHeaderCommand.SMB2SessionSetup && status == 0xC0000016) // STATUS_MORE_PROCESSING_REQUIRED in an SMB2 SESSION_SETUP Response
        || ((commmand == SMB2PacketHeaderCommand.SMB2QueryInfo || commmand is SMB2PacketHeaderCommand.SMB2Read) && status == 0x80000005) // STATUS_BUFFER_OVERFLOW in an SMB2 QUERY_INFO Response/SMB2 READ Response
        || (commmand == SMB2PacketHeaderCommand.SMB2ChangeNotify && status == 0x0000010C) // STATUS_NOTIFY_ENUM_DIR in an SMB2 CHANGE_NOTIFY Response
        || (commmand == SMB2PacketHeaderCommand.SMB2Ioctl && status != 0 && size == 49)) // Any status other than STATUS_SUCCESS in a FSCTL_SRV_COPYCHUNK or FSCTL_SRV_COPYCHUNK_WRITE Response
    {
        return false;
    }
    else
    {
        return ((status & 0xC0000000) == 0xC0000000) // Error code
            || (asyncCommand && (status == 0x0103)) // Interim Response for an Asynchronous Operation
            || (status in {0x8000002D, 0x80000014}); // STATUS_STOPPED_ON_SYMLINK, STATUS_EA_LIST_INCONSISTENT
    }
}

// List of ignored error code for ErrorCodeIf check
array<uint> IgnoredErrorCode = [0xC0000016, // STATUS_MORE_PROCESSING_REQUIRED
                                0xC000019C];  // STATUS_FS_DRIVER_REQUIRED

// Defined for DisplayInfo.
string StatusToText(SMB2PacketHeader header)
{
    if (GetStatus(header) == nothing)
    {
        return "";
    }
    uint status = GetStatus(header) as uint;
    return status == 0 ? "Success": NtStatusValuesToText(status); 
}

// Defined for get Status
optional NTSTATUS GetStatus(SMB2PacketHeader header)
{
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).Status;
    }
    else if (header is SMB2PacketHeaderAsync)
    {
        return (header as SMB2PacketHeaderAsync).Status;
    }
    return nothing;
}

NTSTATUS AddTwoOptionalNTStatus(optional NTSTATUS a, optional NTSTATUS b)
{
    if (a == nothing)
    {
        return b as NTSTATUS;
    }
    else if (b == nothing)
    {
        return a as NTSTATUS;
    }
    else
    {
        return (a as NTSTATUS) + (b as NTSTATUS);
    }
}

UINT64 AddTwoOptionalUint64(optional UINT64 a, optional UINT64 b)
{
    if (a == nothing)
    {
        return b as UINT64;
    }
    else if (b == nothing)
    {
        return a as UINT64;
    }
    else
    {
        return (a as UINT64) + (b as UINT64);
    }
}

const map<byte, string> InfoTypeMap = {
        0x01 -> "File",
        0x02 -> "FileSystem",
        0x03 -> "Security",
        0x04 -> "Quota",
    };

string InfoTypeToText (byte infoType)
{
    if (infoType in InfoTypeMap)
    {
        return InfoTypeMap[infoType];
    }
    else
    {
        return "Unknown(" + (infoType as string) + ")";
    }
}

string FileInfoClassToText(byte infoType, byte infoClass)
{
    if (infoType == 1) //SMB20InfoFile
    {
        return FileInformationClassesToText(infoClass);
    }
    else if (infoType == 2) //SMB20InfoFile
    {
        return FileSystemInformationClassesToText(infoClass);
    }
    else
    {
        return infoClass as string;
    }
}

const map<uint, string> CtlCodeMap = {
        0x00060194 -> "FSCTL_DFS_GET_REFERRALS",
        0x0011400C -> "FSCTL_PIPE_PEEK",
        0x00110018 -> "FSCTL_PIPE_WAIT",
        0x0011C017 -> "FSCTL_PIPE_TRANSCEIVE",
        0x001440F2 -> "FSCTL_SRV_COPYCHUNK",
        0x00144064 -> "FSCTL_SRV_ENUMERATE_SNAPSHOTS",
        0x00140078 -> "FSCTL_SRV_REQUEST_RESUME_KEY",
        0x001441BB -> "FSCTL_SRV_READ_HASH",
        0x001480F2 -> "FSCTL_SRV_COPYCHUNK_WRITE",
        0x001401D4 -> "FSCTL_LMR_REQUEST_RESILIENCY",
        0x001401FC -> "FSCTL_QUERY_NETWORK_INTERFACE_INFO",
        0x000900A4 -> "FSCTL_SET_REPARSE_POINT",
        0x001400EC -> "FSCTL_LMR_SET_LINK_TRACKING_INFORMATION",
        0x000601B0 -> "FSCTL_DFS_GET_REFERRALS_EX",
        0x00090073 -> "FSCTL_GET_RETRIEVAL_POINTERS",
        0x00094264 -> "FSCTL_OFFLOAD_READ",
        0x00098268 -> "FSCTL_OFFLOAD_WRITE",
        0x00098208 -> "FSCTL_FILE_LEVEL_TRIM",
        0x00140204 -> "FSCTL_VALIDATE_NEGOTIATE_INFO",
    };

string CtlCodeToText(any ctlCode)
{
    uint code = ctlCode as uint;
    if (code in CtlCodeMap)
    {
        return CtlCodeMap[code];
    }
    else
    {
        return FSCC.CtlCodeToText(code);
    }
}

string DialectRevisionToText(any input)
{
    ushort revision = input as ushort;
    switch (revision)
    {
        case 0x0202 =>
            return "SMB 2.002";
        case 0x0210 =>
            return "SMB 2.1";
        case 0x02FF =>
            return Utility.DecToHexFormat(revision);
        case 0x0300 =>
            return "SMB 3.0";
        case 0x0302 =>
            return "SMB 3.02";
        default =>
            return "Unknown(" + DecToHexFormat(revision) + ")";
    }
}
string SMB2LeaseBreakNotificationNewLeaseStateToText(SMB2LeaseBreakNotificationNewLeaseState input)
{
    string summary = "";
    if ((input & SMB2LeaseBreakNotificationNewLeaseState.SMB2LeaseReadCaching) > 0)
    {
        summary += "R";
    }
    if ((input & SMB2LeaseBreakNotificationNewLeaseState.SMB2LeaseHandleCaching) > 0)
    {
        summary += "H";
    }
    if ((input & SMB2LeaseBreakNotificationNewLeaseState.SMB2LeaseWriteCaching) > 0)
    {
        summary += "W";
    }
    return summary;
}
string SMB2LeaseBreakNotificationCurrentLeaseStateToText(SMB2LeaseBreakNotificationCurrentLeaseState input)
{
    string summary = "";
    if ((input & SMB2.SMB2LeaseBreakNotificationCurrentLeaseState.SMB2LeaseReadCaching) > 0)
    {
        summary += "R";
    }
    if ((input & SMB2.SMB2LeaseBreakNotificationCurrentLeaseState.SMB2LeaseHandleCaching) > 0)
    {
        summary += "H";
    }
    if ((input & SMB2.SMB2LeaseBreakNotificationCurrentLeaseState.SMB2LeaseWriteCaching) > 0)
    {
        summary += "W";
    }
    return summary;
}
string SMB2LeaseBreakAcknowledgmentLeaseStateToText(SMB2LeaseBreakAcknowledgmentLeaseState input)
{
    string summary = "";
    if ((input & SMB2.SMB2LeaseBreakAcknowledgmentLeaseState.SMB2LeaseNone) > 0)
    {
        summary += "None";
    }
    if ((input & SMB2.SMB2LeaseBreakAcknowledgmentLeaseState.SMB2LeaseReadCaching) > 0)
    {
        summary += "R";
    }
    if ((input & SMB2.SMB2LeaseBreakAcknowledgmentLeaseState.SMB2LeaseHandleCaching) > 0)
    {
        summary += "H";
    }
    if ((input & SMB2.SMB2LeaseBreakAcknowledgmentLeaseState.SMB2LeaseWriteCaching) > 0)
    {
        summary += "W";
    }
    return summary;
}
string SMB2LeaseBreakResponseLeaseStateToText(SMB2LeaseBreakResponseLeaseState input)
{
    string summary = "";
    if ((input & SMB2.SMB2LeaseBreakResponseLeaseState.SMB2LeaseNone) > 0)
    {
        summary += "None";
    }
    if ((input & SMB2.SMB2LeaseBreakResponseLeaseState.SMB2LeaseReadCaching) > 0)
    {
        summary += "R";
    }
    if ((input & SMB2.SMB2LeaseBreakResponseLeaseState.SMB2LeaseHandleCaching) > 0)
    {
        summary += "H";
    }
    if ((input & SMB2.SMB2LeaseBreakResponseLeaseState.SMB2LeaseWriteCaching) > 0)
    {
        summary += "W";
    }
    return summary;
}

string SMB2LeaseStateToText(ULONG leaseState)
{
    if(leaseState == 0)
    {
        return "None";
    }
    string summary = "";
    if ((leaseState & 0x01) > 0) summary += "R";
    if ((leaseState & 0x02) > 0) summary += "H";
    if ((leaseState & 0x04) > 0) summary += "W";
    
    return summary;
}

// Defined for grouping the traffic by using the SMB FileName.
string get FileName(this ReqFileMessage msg)
{
    if (msg#SMBFileName is nothing)
    {
        return "";
    }
    return msg#SMBFileName as string;
}

string get FileName(this ResFileMessage msg)
{
    if (msg#SMBFileName is nothing)
    {
        return "";
    }
    return msg#SMBFileName as string;
}

string get FileNameReference(this ReqFileMessage msg)
{
    string fileName = msg.FileName;
    int index = fileName.LastIndexOf("@");
    if (index < 0)
    {
        return fileName;
    }
    else
    {
        return fileName.Segment(0, index);
    }
}

string get FileNameReference(this ResFileMessage msg)
{
    string fileName = msg.FileName;
    int index = fileName.LastIndexOf("@");
    if (index < 0)
    {
        return fileName;
    }
    else
    {
        return fileName.Segment(0, index);
    }
}

string GetFileNameOrFID((ReqFileMessage | ResFileMessage) msg)
{
    if (msg is ReqFileMessage)
    {
        if ((msg as ReqFileMessage)#SMBFileName != nothing)
        {
            if (((msg as ReqFileMessage)#SMBFileName as string).IndexOf("0x") == 0) //Assume the real file name doesn't begin with "0x"
            {
                return ", FileID: " + ((msg as ReqFileMessage)#SMBFileName as string);
            }
            else
            {
                return ", FileName: " + ((msg as ReqFileMessage)#SMBFileName as string);
            }
        }
        else return "";
    }
    else if(msg is ResFileMessage)
    {
        if ((msg as ResFileMessage)#SMBFileName != nothing)
        {
            if (((msg as ResFileMessage)#SMBFileName as string).IndexOf("0x") == 0)//Assume the real file name doesn't begin with "0x"
            {
                return ", FileID: " + ((msg as ResFileMessage)#SMBFileName as string);
            }
            else
            {
                return ", FileName: " + ((msg as ResFileMessage)#SMBFileName as string);
            }
        }
        else
        {
            return "";
        }
    }
    else return "";
}

// Get the MessageId for the reponse message
ulong GetCommand(SMB2PacketHeader header)
{
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).Command;
    }
    else
    {
        return (header as SMB2PacketHeaderAsync).Command;
    }
}

// Get the MessageId for the reponse message
ulong GetMessageId(SMB2PacketHeader header)
{
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).MessageId;
    }
    else
    {
        return (header as SMB2PacketHeaderAsync).MessageId;
    }
}

// Get the ASyncId if SMB2PacketHeaderReq is SMB2PacketHeaderAsync, else return 0.
ulong GetAsyncId(SMB2PacketHeaderReq header)
{
    if (header is SMB2PacketHeaderAsync)
    {
        return (header as SMB2PacketHeaderAsync).AsyncId;
    }
    return 0;
}

// Get the TreeId for the reponse message
uint GetTreeId(SMB2PacketHeader header)
{
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).TreeId;
    }
    return 0;
}

// Get the SessionId for the reponse message
ulong GetSessionId(SMB2PacketHeader header)
{
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).SessionId;
    }
    else
    {
        return (header as SMB2PacketHeaderAsync).SessionId;
    }
}

// Get the Credit for the reponse message
ushort get CreditResponse(this ResMessage msg)
{
    var header = msg.Header;
    if (header is SMB2PacketHeaderSync)
    {
        return (header as SMB2PacketHeaderSync).Credit;
    }
    else
    {
        return (header as SMB2PacketHeaderAsync).Credit;
    }
}

ulong GetSMBFileId(ReqFileMessage msg)
{
    return (msg#FileId == nothing) ? InvalidFileId : msg#FileId as ulong;
}

ulong GetSMBFileId(ResFileMessage msg)
{
    return (msg#FileId == nothing) ? InvalidFileId : msg#FileId as ulong;
}

/* Indentify whether it's named pipe or not by the share type in current tree connection.
 * If the treeconnection message is missing in the trace, considering that it's named pipe data when the file name doesnt't have "." included.
 */
bool CheckIsNamedPipe(optional bool isNamedPipe, string fileName)
{
    // Missing the share type in the conversation
    if (isNamedPipe == nothing)
    {
        // For named pipe, it won't have "." included.
        return !(fileName.LastIndexOf(".") > fileName.LastIndexOf("\\"));
    }
    return isNamedPipe as bool;
}

//Get the EncryptionAlgorithm field from SMB2TransformMessage message
ushort GetEncryptAlgorithmFromSMB2TransformMessage(binary SMBMessage)
{
    return (SMBMessage[42] + ((SMBMessage[43] as ushort) << 8)) as ushort;
}

// -------------------------------------------ADM Variables For Sequence Validation---------------------------------------
// 3.3.1.10   Per Open
type ServerOpen
{
    // Future Reference: implement this type for future use(eg. SMB2 CREATE sequence validation)
}

// 3.3.1.13   Per Request
type ServerRequest
{
    ulong MessageId;
    ulong AsyncId;
    ulong CancelRequestId;
    ServerOpen Open;
    bool  IsEncrypted;
}

// 3.3.1.8   Per Session
type ServerSession
{
    // Future Reference: implement this type for future use(eg. SMB2 Session setup sequence validation)
}

// 3.3.1.7   Per Transport Connection
type ServerConnection
{
    set<ulong> CommandSequenceWindow;
    map<ulong, ServerRequest>RequestList;
    SMB2NegotiateRequestCapabilities ClientCapabilities;
    ushort NegotiateDialect;
    map<ulong, any message> AsyncCommandList;
    string Dialect;
    bool ShouldSign;
    string ClientName;
    uint MaxTransactSize;
    bool SupportsMultiCredit;
    string TransportName;
    array<ServerSession> SessionTable; 
    GUID ClientGuid;
    SMB2NegotiateRequestCapabilities ServerCapabilities;
    SMB2NegotiateRequestSecurityMode ServerSecurityMode;
    SMB2NegotiateRequestSecurityMode ClientSecurityMode;
    
    // Not a SMB2 Server ADM variable, added for sequece validation. Used to store previous request for future squence validation.
    //any message preRequest;
    // Not a SMB2 Server ADM variable, added for sequece validation. Used to enable/disable sequence validation.
    bool validationEnabled;
    // Not a SMB2 Server ADM variable, added for sequece validation. Used to store all the unanswered request.
    map<ulong, any message> PendingRequestList;
    ServerConnection()
    {
        CommandSequenceWindow = {0};
        RequestList = {};
        ClientCapabilities = 0;
        NegotiateDialect = 0xFFFF;
        AsyncCommandList = {};
        Dialect = "Unknown";
        SupportsMultiCredit = false;
        ServerCapabilities = 0;
        ServerSecurityMode = 0;
        ClientSecurityMode = 0;
        PendingRequestList = {};
        validationEnabled = false;
    }
}

// this type is used to hold all the ADM variables
type ServerGlobal
{
    // ADM variable in 3.3.1.7   Per Transport Connection
    // Future Reference: deal with multiple connections.
    ServerConnection connectionList;
    
    // Future Reference: implements other global ADM variables.
    
    ServerGlobal()
    {
        connectionList = new ServerConnection();
    }
    
    // Check if a pending request exists in the server.global.connectionList.PendingRequestList for this response
    bool ExistRequest(SMB2.ResMessage response)
    {
        return (response.MessageId in connectionList.PendingRequestList);
    }
    
    // Return the related pending request of a response according to MessageId
    any GetRequest(ResMessage response)
    {
        return connectionList.PendingRequestList[response.MessageId];
    }
    
    // Remove a request according to the MessageId of the response
    void RemoveRequest(ResMessage response)
    {
        connectionList.PendingRequestList.Remove(response.MessageId);
    }
}
