protocol Ethernet with 
BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "Ethernet",
    ShortName = "Ethernet",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 2108"},
            new Reference{Name = "RFC 1042"},
            new Reference{Name = "RFC 2464"},
            new Reference{Name = "IEEE Std 802.3", Version = "2008 Edition", Link = "http://standards.ieee.org/about/get/802/802.3.html"},
            new Reference{Name = "IEEE Std 802.1Q", Version = "2005 Edition", Link = "http://standards.ieee.org/getieee802/download/802.1Q-2005.pdf"},
            new Reference{Name = "IEEE Std 802.1D", Version = "2004 Edition", Link = "http://standards.ieee.org/getieee802/download/802.1D-2004.pdf"},
            new Reference{Name = "IEEE Std 802.1AD", Version = "2005 Edition", Link = "http://standards.ieee.org/getieee802/download/802.1ad-2005.pdf"},
        ],
    RevisionSummary = 
        [
            new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "09/02/2011"}
        ]
};

using Standard;
using Utility;
using IANA;

endpoint Node[binary LocalAddress] accepts Frame;

message Frame[bool IsTruncated]
{
    MacAddress DestinationAddress with Visualization{AliasName = "Address"};
    MacAddress SourceAddress with Visualization{AliasName = "Address"};
    optional (IEEE8021QMetaData | IEEE8021ADMetaData) MetaData;
    (Type | Length) LengthOrType 
        where ValidationCheckValid(CheckType(value), this, false, ReferenceType.Message, "Ethernet", "LengthOrType", "Frame", "IEEE Ethernet Type") 
        with DisplayInfo{ToText = LengthOrTypeToText};
    binary MacClientData 
        where ValidationCheck(IsTruncated || CheckLength(value, LengthOrType), 
        this, DiagnosisLevel.Warning,
        (LengthOrType >= MinMacClientDataLength) ? "Ethernet: The LengthOrType in message Frame is not equal to the length of MacClientData." : "Ethernet: The LengthOrType in message Frame is less than 46 and MacClientData is not padded to 46 bytes."); 
    
    override string ToString()
    {
        string summary = "";
        summary += this#IsTruncated != nothing && (this#IsTruncated as bool) ? "Truncated, " : "";
        summary += (LengthOrType is Type ? "Type: " : "Length: ") + LengthOrTypeToText(LengthOrType); 
        return summary;
    }
    
    static string LengthOrTypeToText(any data)
    {
        (Type | Length) lengthOrType = data as (Type | Length);
        if (lengthOrType is Length)
        {
            return (data as string);
        }
        else if (lengthOrType in EtherTypesMap)
        {
            return EtherTypesMap[lengthOrType];
        }
        else 
        {
            string result = GetContinuousEthertype(lengthOrType as ushort);
            if (result != null)
            {
                return result;
            }
            else
            {
                return (data as string);
            }
        }
    }
}

MacAddress get Source(this Ethernet.Frame frame)
{
    return frame.SourceAddress;
}

MacAddress get Destination(this Ethernet.Frame frame)
{
    return frame.DestinationAddress;
}

string get Network(this Ethernet.Frame frame)
{
    return "Ethernet: " + (frame.SourceAddress.Octets > frame.DestinationAddress.Octets
        ? frame.DestinationAddress.ToString() + " - " + frame.SourceAddress.ToString()
        : frame.SourceAddress.ToString() + " - " + frame.DestinationAddress.ToString());
}

bool CheckType((Type | Length) lengthOrType)
{
    if (lengthOrType is Length)
    {
        return true;
    }
    else if (lengthOrType in EtherTypesMap)
    {
        return true;
    }
    else if (GetContinuousEthertype(lengthOrType as ushort) != null)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool CheckLength(binary macClientData, (Type | Length) lengthOrType)
{
    if (lengthOrType is Length && lengthOrType > 0)
    {
        // The length of data portion is at least 46 bytes in ethernet, if actual data is less than 46 bytes, add pads in end
        if (lengthOrType >= MinMacClientDataLength)
        {
            return (macClientData.Count() == lengthOrType);
        }
        else
        {
            return (macClientData.Count() == MinMacClientDataLength);
        }
    }
    else
    {
        return true;
    }
}


pattern Type = ushort where value >= 0x0600;    // 1536
pattern Length = ushort where value <= 0x05DC;  // 1500

const ushort MinMacClientDataLength = 46;


type IEEE8021QMetaData
{
    (ushort where value == 0x8100) TPID;
    VlanTagTCI TCI;
}

type IEEE8021ADMetaData 
{   
    (IEEE8021QServiceVlanTag where value.TPID == 0x88A8) STAG;
    (IEEE8021QCustomerVlanTag where value.TPID == 0x8100) CTAG;
};

type IEEE8021QServiceVlanTag
{
    ushort TPID;
    ServiceVlanTagTCI TCI;
}

type IEEE8021QCustomerVlanTag
{
    ushort TPID;
    VlanTagTCI TCI;
}

type ServiceVlanTagTCI
{
    byte PCP with BinaryEncoding{Width = 3};
    bool DEI with BinaryEncoding{Width = 1};
    ushort VID with BinaryEncoding{Width = 12};
}

type VlanTagTCI
{
    byte PCP with BinaryEncoding{Width = 3};
    bool CFI with BinaryEncoding{Width = 1};
    ushort VID with BinaryEncoding{Width = 12};   
}
