protocol WebProxy with 
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
        ],
    RevisionSummary =    
        [
            new Revision{Class = RevisionClass.Major, Version = "1.0.0", Date = "09/02/2011"}
        ]
};

using Etw;
using EtwEvent;
using HTTP;
using Utility;

const guid EtwProviderIdWebProxy = {6EF4653A-71F9-4AD3-B093-61C38C9C299F};

endpoint Server[uint KeySessionId]
    accepts Message issues Message
{
    // Indicate if response to HEAD method.
    bool isHeadMethod = false;
    
    string host = "";
    
    process this accepts fm:Message
    {
        binary buffer = fm.Payload;
        stream s = buffer;
        
        var requestHeader = RequestHeader(s);
        if (requestHeader == nothing)
        {
            ThrowDecodingException("WebProxy", "HTTP Request Header");
        }
        var header = requestHeader as RequestHeaderType;
        header.Uri = ParseUri(header.Uri.Host as string);
        header.Headers = ParseHeaderFields(header.Headers); 
        
        if (header.Method.ToUpper() == "HEAD")
        {
            isHeadMethod = true;
        }
        
        bool parseSuccess = false;
        optional MessageBodyType body = BodyDecoder(s, header.Headers, true, out parseSuccess);
        
        if (!parseSuccess)
        {
            ThrowDecodingException("WebProxy", "HTTP Request Body");
            return;
        }
        HttpContract.Request request = new HttpContract.Request
        {
            Method = header.Method, 
            Uri = header.Uri, 
            Version = header.Version, 
            Headers = header.Headers, 
            ChunkedMessageBody = IsChunkedBody(header.Headers) ? body : nothing, 
            Payload = body.Reassemble(),
        };
        request.SourceData = fm.Payload;
        
        request#IsRequestOverWebProxy = true;
        host = request.HTTPHost;
        request#DestinationStr = host;
        
        dispatch (endpoint HTTP.SetOriginsServer[this]) accepts request;
    }

    process this issues fm:Message
    {
        binary buffer = fm.Payload;
        stream s = buffer;
        
        var responseHeader = ResponseHeader(s);
        if (responseHeader == nothing)
        {
            ThrowDecodingException("WebProxy", "HTTP Response Header");
            return;
        }
        var header = responseHeader as ResponseHeaderType;
        header.Headers = ParseHeaderFields(header.Headers); 
        
        optional MessageBodyType body = nothing;
        bool parseSuccess = false;
        if (!isHeadMethod)
        {
            parseSuccess = false;
            body = BodyDecoder(s, header.Headers, true, out parseSuccess);
            if (!parseSuccess)
            {
                ThrowDecodingException("WebProxy", "HTTP Response Body");
                return;
            }
        }
        else
        {
            parseSuccess = true;
            body = nothing;
            isHeadMethod = false;
        }

        HttpContract.Response response = new HttpContract.Response
        {
            Version = header.Version, 
            StatusCode = header.StatusCode, 
            ReasonPhrase = header.ReasonPhrase, 
            Headers = header.Headers, 
            ChunkedMessageBody = IsChunkedBody(header.Headers) ? body : nothing,
            Payload = body.Reassemble(),
        };
        response.SourceData = fm.Payload;
        
        response#IsResponseOverWebProxy = true;
        response#SourceStr = host;
        // Reset host after asingn it to Source;
        host = "";

        if (response.StatusCode == 100)
        {
            // Future Reference: Check 100 continue could be handled smoothly in HTTP.
            // response#IsResponseWith100Continue = true;
            // If 100(continue) response, recover buffer for final response.
            host = response#SourceStr as string;
        }
               
        dispatch (endpoint HTTP.SetOriginsServer[this]) issues response;
    }
}

client endpoint Client connected to Server;

autostart actor WebProxyOverEtwEvent(EtwEvent.Node etw)
{
    map<uint, string> host = {};
    
    process etw accepts m:EtwProviderMsg
        where m.EventRecord.Header.ProviderId == EtwProviderIdWebProxy
    {
        switch (m.Payload)
        {
            case fm:WebProxy.Message from BinaryDecoder<WebProxy.Message> =>
                stream s = fm.Payload;
                if (fm.IsRequest == 1)
                {
                    var requestHeaderOptional = RequestHeader(s);
                    if (requestHeaderOptional != nothing)
                    {
                        var requestHeader = requestHeaderOptional as RequestHeaderType;
                        if ("Host" in requestHeader.Headers)
                        {
                            host[fm.SessionId] = requestHeader.Headers["Host"] as string;
                            fm.DestinationAddress = host[fm.SessionId];
                            fm.SourceAddress = "Local";
                        }
                    }

                    dispatch (endpoint Server[fm.SessionId]) accepts fm;
                }
                else
                {
                    if (fm.SessionId in host)
                    {
                        fm.SourceAddress = host[fm.SessionId];
                        fm.DestinationAddress = "Local";
                        host = host.Remove(fm.SessionId);
                    }

                    dispatch (endpoint Server[fm.SessionId]) issues fm;
                }
        }
    }
}

message Message
{
    uint SessionId;
    ulong TimeStamp;
    uint IsRequest;
    string SourceAddress with Encoding{Ignore = true} with Visualization{AliasName = "Address"};
    string DestinationAddress with Encoding{Ignore = true} with Visualization{AliasName = "Address"};
    uint PayloadLength;
    binary Payload with MimeDescription{Format = "text/plain"};
}

string get Source(this WebProxy.Message msg)
{
    return msg.SourceAddress;
}

string get Destination(this WebProxy.Message msg)
{
    return msg.DestinationAddress;
}

string get Network(this WebProxy.Message msg)
{
    return "WebProxy: " + (msg.SourceAddress == "Local"
        ? msg.SourceAddress + " - " + msg.DestinationAddress
        : msg.DestinationAddress + " - " + msg.SourceAddress);
}
