module DTYP with
Documentation
{
    ProtocolName = "Windows Data Types",
    ShortName = "DTYP",
    DocumentName = "MS-DTYP",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-DTYP", Version = "25.1", Date = "01/31/2013", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="381842", Date="10/14/2015"}
        ]
};

using Standard;
using Technologies.IDL;
using Utility;
using Diagnostics;

// below 'wchar_t' has been defined in Technologies.IDL
//pattern wchar_t = ushort
    //with Documentation
    //{Description = "A 16-bit, UTF-16 (as specified in [RFC2781]) encoded UNICODE character for use with the Microsoft Interface Definition Language (MIDL) compiler."};

typedef ADCONNECTION_HANDLE = VOID with IDL{IndirectionLevel = 1};

typedef BOOL = int 
    with Documentation
    {Description = "A BOOL is a 32-bit field that is set to 1 to indicate TRUE, or 0 to indicate FALSE."};
typedef PBOOL = int with IDL{IndirectionLevel = 1};
typedef LPBOOL = int with IDL{IndirectionLevel = 1};

typedef BYTE = byte // For might be used by NonRpc, use byte instead.
    with Documentation
    {Description = "A BYTE is an 8-bit unsigned value that corresponds to a single octet in a network protocol."};
typedef PBYTE = byte with IDL{IndirectionLevel = 1}; // For might be used by NonRpc, use byte instead.
typedef LPBYTE = byte with IDL{IndirectionLevel = 1}; // For might be used by NonRpc, use byte instead.

typedef BOOLEAN = BYTE
    with Documentation
    {Description = "A BOOLEAN is an 8-bit field that is set to 1 to indicate TRUE, or 0 to indicate FALSE."};
typedef PBOOLEAN = bool with IDL{IndirectionLevel = 1};

typedef WCHAR = wchar_t with Documentation{Description = "A WCHAR is a 16-bit UNICODE character."};
typedef PWCHAR = wchar_t with IDL{IndirectionLevel = 1};

typedef BSTR = WCHAR with IDL{IndirectionLevel = 1},
    Documentation
    {Description = "A BSTR is a pointer to a null-terminated character string in which the string length is stored with the string. Because the length is stored with the string, BSTR variables can contain embedded null characters. For example:"};

typedef CHAR = byte // For might be used by NonRpc, use byte instead.
    with Documentation
    {Description = "A CHAR is an 8-bit block of data that typically contains an ANSI character. For information on the char keyword, see [C706] section 4.2.9.3."};
typedef PCHAR = byte with IDL{IndirectionLevel = 1};  // For might be used by NonRpc, use byte instead.

typedef DOUBLE = double
    with Documentation
    {Description = "A DOUBLE is an 8-byte, double-precision, floating-point number that represents a double-precision, 64-bit [IEEE754] value with the approximate range: +/–5.0 x 10-324 through +/–1.7 x 10308."};

typedef DWORD = uint
    with Documentation
    {Description = "A DWORD is a 32-bit unsigned integer (range: 0 through 4294967295 decimal). Because a DWORD is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};
typedef PDWORD = uint with IDL{IndirectionLevel = 1};
typedef LPDWORD = uint with IDL{IndirectionLevel = 1};

typedef DWORD32 = uint
    with Documentation{Description = "A DWORD32 is a 32-bit unsigned integer."};

typedef DWORD64 = ulong
    with Documentation{Description = "A DWORD64 is a 64-bit unsigned integer."};
typedef PDWORD64 = ulong with IDL{IndirectionLevel = 1};

typedef ULONGLONG = ulong
    with Documentation
    {Description = "A ULONGLONG is a 64-bit unsigned integer (range: 0 through 18446744073709551615 decimal). Because a ULONGLONG is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};

typedef DWORDLONG = ULONGLONG
    with Documentation
    {Description = "A DWORDLONG is a 64-bit unsigned integer (range: 0 through 18446744073709551615 decimal)."};
typedef PDWORDLONG = ULONGLONG with IDL{IndirectionLevel = 1};

// below 'error_status_t' has been defined in Technologies.IDL
//pattern error_status_t = uint;

typedef FLOAT = float
    with Documentation
    {Description = "A float is a base type that is specified the IEEE Format section of [C706-Ch14TransSyntaxNDR]."};

typedef UCHAR = byte // For might be used by NonRpc, use byte instead.
    with Documentation
    {Description = "A UCHAR is an 8-bit integer with the range: 0 through 255 decimal. Because a UCHAR is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};

typedef PUCHAR = byte with IDL{IndirectionLevel = 1}; // For might be used by NonRpc, use byte instead.

typedef SHORT = short
    with Documentation
    {Description = "A SHORT is a 16-bit signed integer(range: –32768 through 32767 decimal). The first bit (Most Significant Bit (MSB)) is the signing bit."};

typedef HANDLE = VOID with IDL{IndirectionLevel = 1}, Documentation {Description = "A HANDLE to an object"};

typedef HCALL = DWORD
    with Documentation
    {Description = "An HCALL is a 32-bit unsigned integer used to store a handle to a call."};

typedef INT = int
    with Documentation
    {Description = "An INT is a 32-bit signed integer (range: –2147483648 through 2147483647 decimal)."};
typedef LPINT = int with IDL{IndirectionLevel = 1};

typedef INT8 = sbyte
    with Documentation
    {Description = "An INT8 is an 8-bit signed integer (range: –128 through 127 decimal). The first bit (Most Significant Bit (MSB)) is the signing bit."};

typedef INT16 = short
    with Documentation
    {Description = "An INT16 is a 16-bit signed integer (range: –32768 through 32767 decimal). The first bit (Most Significant Bit (MSB)) is the signing bit."};

typedef INT32 = int
    with Documentation
    {Description = "An INT32 is a 32-bit signed integer (range: –2147483648 through 2147483647 decimal). The first bit (Most Significant Bit (MSB)) is the signing bit."};

typedef INT64 = long
    with Documentation
    {Description = "An INT64 is a 64-bit signed integer (range: –9223372036854775808 through 9223372036854775807 decimal). The first bit (Most Significant Bit (MSB)) is the signing bit."};

typedef LDAP_UDP_HANDLE = VOID with IDL{IndirectionLevel = 1};

typedef LMCSTR = wchar_t with IDL{IndirectionLevel = 1},
    Documentation
    {Description = "A LMCSTR is a 32-bit pointer to a constant null-terminated string of 16-bit UNICODE characters."};

typedef LMSTR = WCHAR with IDL{IndirectionLevel = 1},
    Documentation
    {Description = "A LMSTR is a 32-bit pointer to a null-terminated string of 16-bit UNICODE characters."};

typedef LONG = int
    with Documentation
    {Description = "A LONG is a 32-bit signed integer, in twos-complement format (range: –2147483648 through 2147483647 decimal). The first bit (Most Significant Bit (MSB)) is the signing bit."};
typedef PLONG = int with IDL{IndirectionLevel = 1};
typedef LPLONG = int with IDL{IndirectionLevel = 1};

typedef LONGLONG = long
    with Documentation
    {Description = "A LONGLONG is a 64-bit signed integer (range: –9223372036854775808 through 9223372036854775807 decimal)."};

typedef HRESULT = LONG
    with Documentation
    {Description = "An HRESULT is a 32-bit value that is used to describe an error or warning and contains the following fields:"};

typedef LONG_PTR = __int3264;

typedef ULONG_PTR = __uint3264;

typedef LONG32 = int with Documentation{Description = "A LONG32 is a 32-bit signed integer."};

typedef LONG64 = long with Documentation{Description = "A LONG64 is a 64-bit signed integer."};
typedef PLONG64 = long with IDL{IndirectionLevel = 1};

typedef LPCSTR = byte with IDL{IndirectionLevel = 1}, // For might be used by NonRpc, use byte instead.
    Documentation
    {Description = "An LPCSTR is a 32-bit pointer to a constant null-terminated string of 8-bit windows (ANSI) characters."};

typedef LPCWSTR = wchar_t with IDL{IndirectionLevel = 1},
    Documentation
    {Description = "An LPCWSTR is a 32-bit pointer to a constant string of 16-bit UNICODE characters, which MAY be null-terminated."};

typedef PSTR = byte with IDL{IndirectionLevel = 1}, // For might be used by NonRpc, use byte instead.
    Documentation
    {Description = "A 32-bit pointer to a string of 8-bit characters, which MAY be null-terminated."};
typedef LPSTR = byte with IDL{IndirectionLevel = 1}, // For might be used by NonRpc, use byte instead.
    Documentation {Description = "A 32-bit pointer to a string of 8-bit characters, which MAY be null-terminated."};

typedef LPWSTR = wchar_t with IDL{IndirectionLevel = 1},
    Documentation
    {Description = "A 32-bit pointer to a string of 16-bit Unicode characters, which MAY be null-terminated."};
typedef PWSTR = wchar_t with IDL{IndirectionLevel = 2};

typedef NET_API_STATUS = DWORD;

// NTSTATUS is int in DOC, but it may be a mistake
// WORKAROUND: Bug 41303 [RPC TDGen] long type should be defined as int in OPN and translated to long during OPN->IDL
typedef NTSTATUS = uint
    with Documentation
    {Description = "NTSTATUS values are used to communicate system information. They are of four types: success values, information values, warnings, and error values, as specified in [MS-ERREF]."};

typedef PCONTEXT_HANDLE = ContextHandle with IDL{IndirectionLevel = 1};

typedef PPCONTEXT_HANDLE = PCONTEXT_HANDLE with IDL{IndirectionLevel = 1, PointerType = PointerKind.RefPtr};

typedef QWORD = ulong
    with Documentation{Description = "A QWORD is a 64-bit unsigned integer."};

typedef RPC_BINDING_HANDLE = VOID with IDL{IndirectionLevel = 1};

typedef STRING = UCHAR with IDL{IndirectionLevel = 1},
    Documentation
    {Description = "Unless otherwise noted, a STRING is a UCHAR buffer that represents a null-terminated string of 8-bit characters."};

typedef UINT = uint
    with Documentation
    {Description = "A UINT is a 32-bit unsigned integer (range: 0 through 4294967295 decimal). Because a UINT is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};
    
typedef UINT8 = byte
    with Documentation
    {Description = "A UINT8 is an 8-bit unsigned integer (range: 0 through 255 decimal). Because a UINT8 is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};
    
typedef UINT16 = ushort
    with Documentation
    {Description = "A UINT16 is a 16-bit unsigned integer (range: 0 through 65535 decimal). Because a UINT16 is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};
    
typedef UINT32 = uint
    with Documentation
    {Description = "A UINT32 is a 32-bit unsigned integer (range: 0 through 4294967295 decimal). Because a UINT32 is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};
    
typedef UINT64 = ulong
    with Documentation
    {Description = "A UINT64 is a 64-bit unsigned integer (range: 0 through 18446744073709551615 decimal). Because a UINT64 is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};
    
typedef ULONG = uint
    with Documentation
    {Description = "A ULONG is a 32-bit unsigned integer (range: 0 through 4294967295 decimal). Because a ULONG is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};
typedef PULONG = uint with IDL{IndirectionLevel = 1};

typedef DWORD_PTR = ULONG_PTR
    with Documentation
    {Description = "A DWORD_PTR is an unsigned long type used for pointer precision. It is used when casting a pointer to an unsigned long type to perform pointer arithmetic. DWORD_PTR is also commonly used for general 32-bit parameters that have been extended to 64 bits in 64-bit windows. For more information, see ULONG_PTR."};

typedef SIZE_T = ULONG_PTR
    with Documentation
    {Description = "SIZE_T is a ULONG_PTR representing the maximum number of bytes to which a pointer can point."};

typedef ULONG32 = uint with Documentation{Description = "A ULONG32 is an unsigned LONG32."};

typedef ULONG64 = ulong
    with Documentation
    {Description = "A ULONG64 is a 64-bit unsigned integer (range: 0 through 18446744073709551615 decimal). Because a ULONG64 is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};

typedef UNICODE = wchar_t with Documentation{Description = "A single UNICODE character."};

typedef USHORT = ushort
    with Documentation
    {Description = "A USHORT is a 16-bit unsigned integer (range: 0 through 65535 decimal). Because a USHORT is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};

typedef VOID = Void with Documentation{Description = "VOID is an alias for void."};
typedef PVOID = VOID with IDL{IndirectionLevel = 1};
typedef LPVOID = VOID with IDL{IndirectionLevel = 1};

typedef WORD = ushort
    with Documentation
    {Description = "A WORD is a 16-bit unsigned integer (range: 0 through 65535 decimal). Because a WORD is unsigned, its first bit (Most Significant Bit (MSB)) is not reserved for signing."};
typedef PWORD = ushort with IDL{IndirectionLevel = 1};
typedef LPWORD = ushort with IDL{IndirectionLevel = 1};

/*********************************************************** MS-DTYP 2.3 Common Data Structures ***********************************************************/
type EVENT_DESCRIPTOR
{
    USHORT Id;
    UCHAR Version;
    UCHAR Channel;
    UCHAR Level;
    UCHAR Opcode;
    USHORT Task;
    ULONGLONG Keyword;
}
typedef PEVENT_DESCRIPTOR = EVENT_DESCRIPTOR with IDL{IndirectionLevel = 1};

type EVENT_HEADER
{
    USHORT           Size;
    USHORT           HeaderType;
    USHORT           Flags;
    USHORT           EventProperty;
    ULONG            ThreadId;
    ULONG            ProcessId;
    LARGE_INTEGER    TimeStamp;
    GUID             ProviderId;
    EVENT_DESCRIPTOR EventDescriptor;
    ULONG64          ProcessorTime;
    GUID             ActivityId;
}
typedef PEVENT_HEADER = EVENT_HEADER with IDL{IndirectionLevel = 1};

/*
 * The FILETIME structure is a 64-bit value that represents the number of 100-nanosecond intervals 
 * that have elapsed since January 1, 1601, Coordinated Universal Time (UTC).
 */
type FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
    
    override string ToString()
    {
        ulong intervals = ((dwHighDateTime as ulong) << 32) + dwLowDateTime; // 100-nanosecond intervals since January 1, 1601, UTC
        return CreateDateTime(1601, 1, 1).AddMilliseconds((intervals / 10000) as double).ToLocalTime().ToString("MM/dd/yyyy HH:mm:ss.fffffff K");
    }

    string ToUtcString()
    {
        ulong intervals = ((dwHighDateTime as ulong) << 32) + dwLowDateTime; // 100-nanosecond intervals since January 1, 1601, UTC
        return CreateDateTime(1601, 1, 1).AddMilliseconds((intervals / 10000) as double).ToUniversalTime().ToString("MM/dd/yyyy HH:mm:ss.fffffff K");
    }
}
typedef PFILETIME = FILETIME with IDL{IndirectionLevel = 1};
typedef LPFILETIME = FILETIME with IDL{IndirectionLevel = 1};

typedef GUID = guid;
typedef UUID = GUID;
typedef PGUID = GUID with IDL{IndirectionLevel = 1};

type LARGE_INTEGER
{
    long QuadPart with DisplayInfo{ToText = LargeInteger2Hex};

    override string ToString()
    {
        return "QuadPart =" + " 0x" + ConvertDecToHex(QuadPart as ulong);
    }
    
    static string LargeInteger2Hex(any anyV)
    {
        long v = anyV as long;
        return (v as string) + " (0x" + ConvertDecToHex(v as ulong) + ")";
    }

    static string ConvertDecToHex(ulong dec)
    {
        // for 0 ~ 15, using 0~F instead of 00~0F
        if (dec < 16)
        {
            return DecMapHex(dec % 16 as uint);
        }
        string hex;
        while (dec / 16 >= 16)
        {
            hex = DecMapHex(dec % 16 as uint) + hex;
            dec = dec / 16;
        }
        return DecMapHex(dec / 16 as uint) + DecMapHex(dec % 16 as uint) + hex;
    }

    static string DecMapHex(uint val)
    {
        if (val >= 16)
        {
            return null;
        }
        else
        {
            if (val < 10)
            {
                return val as string;
            }
            else if (val == 10)
            {
                return "A";
            }
            else if (val == 11)
            {
                return "B";
            }
            else if (val == 12)
            {
                return "C";
            }
            else if (val == 13)
            {
                return "D";
            }
            else if (val == 14)
            {   
                return "E";
            }
            else
            { 
                return "F";
            }
        }
    }
}
typedef PLARGE_INTEGER = LARGE_INTEGER with IDL{IndirectionLevel = 1};

typedef LCID = DWORD;

type LUID
{
    DWORD LowPart;
    LONG HighPart;
    
    override string ToString()
    {
        return HighPart.ToString() + "-" + LowPart.ToString();
    }
}
typedef PLUID = LUID with IDL{IndirectionLevel = 1};

type MULTI_SZ
{
    wchar_t Value with IDL{IndirectionLevel = 1};
    DWORD Nchar;
}

type RPC_UNICODE_STRING
{
    ushort Length;
    ushort MaximumLength;
    // The same behavior with NetMon. In NetMon, if no element, Buffer will not display.
    optional string Buffer with IDL{IndirectionLevel = 1, Length_is = [Length / 2], Size_is =[MaximumLength / 2]},
        Encoding
        {
            Decoder = BinaryDecoder<string>,
            SourceConverter = ConvertArrayWCHAR2Binary,
            SourcePattern = TypeOf<array<WCHAR>>()
        },
        BinaryEncoding{Endian = Endian.Little, TextEncoding = TextEncoding.Unicode};
    
    override string ToString()
    {
        if (Buffer == nothing)
        {
            return "";
        }
        return Buffer as string;
    }
    
    optional binary ConvertArrayWCHAR2Binary(array<WCHAR> arrayWCHAR)
    {
        array<byte> result = [];
        foreach (WCHAR c in arrayWCHAR)
        {
            result += [c as byte, (c >> 8) as byte];
        }
        return result as binary;
    }
}
typedef PRPC_UNICODE_STRING = RPC_UNICODE_STRING with IDL{IndirectionLevel = 1};

type SERVER_INFO_100
{
    DWORD SV100PlatformID;
    string SV100Name with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
}
typedef PSERVER_INFO_100 = SERVER_INFO_100 with IDL{IndirectionLevel = 1};
typedef LPSERVER_INFO_100 = SERVER_INFO_100 with IDL{IndirectionLevel = 1};

type SERVER_INFO_101
{
    DWORD SV101PlatformID;
    string SV101Name with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    DWORD SV101VersionMajor;
    DWORD SV101VersionMinor;
    DWORD SV101VersionType;
    string SV101Comment with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
}
typedef PSERVER_INFO_101 = SERVER_INFO_101 with IDL{IndirectionLevel = 1};
typedef LPSERVER_INFO_101 = SERVER_INFO_101 with IDL{IndirectionLevel = 1};

type SYSTEMTIME
{
    WORD Wyear;
    WORD Wmonth;
    WORD WdayOfWeek;
    WORD Wday;
    WORD Whour;
    WORD Wminute;
    WORD Wsecond;
    WORD Wmilliseconds;

    override string ToString()
    {
        return Format("{0:D2}/{1:D2}/{2:D4} {3:D2}:{4:D2}:{5:D2}.{6:D3}",
            [Wday, Wmonth, Wyear, Whour, Wminute, Wsecond, Wmilliseconds]);
    }
}
typedef PSYSTEMTIME = SYSTEMTIME with IDL{IndirectionLevel = 1};

type UINT128
{
    UINT64 Lower;
    UINT64 Upper;
}
typedef PUINT128 = UINT128 with IDL{IndirectionLevel = 1};

type ULARGE_INTEGER
{
    ulong QuadPart;
}
typedef PULARGE_INTEGER = ULARGE_INTEGER with IDL{IndirectionLevel = 1};

type RPC_SID_IDENTIFIER_AUTHORITY
{
    array<byte> Value with IDL{Dimensions = [6]}, DisplayInfo{ToText = x => EnumToString(x, "DTYP.SidIdentifierAuthorityValue")};
}

pattern ACCESS_MASK = DWORD;

typedef PACCESS_MASK = ACCESS_MASK with IDL{IndirectionLevel = 1};

type OBJECT_TYPE_LIST
{
    WORD Level;
    ACCESS_MASK Remaining;
    GUID ObjectType with IDL{IndirectionLevel = 1};
}
typedef POBJECT_TYPE_LIST = OBJECT_TYPE_LIST with IDL{IndirectionLevel = 1};

type ACE_HEADER
{
    AceHeaderAceType AceType where ValidationCheckEnumValueTooManyItems(InRange<AceHeaderAceType>(value), null, true, ReferenceType.Type,
        "DTYP", "AceType", "ACE_HEADER", "Ace Type", "[MS-DTYP]")
        with Encoding{Decoder = PatternDecoder<AceHeaderAceType>, SourcePattern = TypeOf<UCHAR>()};
    AceHeaderAceFlags AceFlags
        where ValidationCheckCombinationValueTooManyItems(InRange<AceHeaderAceFlags>(value), null, true, ReferenceType.Type,
                "DTYP", "AceFlags", "ACE_HEADER", "Ace Flags", "[MS-DTYP]") 
        with Encoding{Decoder = PatternDecoder<AceHeaderAceFlags>, SourcePattern = TypeOf<UCHAR>()};
    USHORT AceSize
        with Documentation
        {Description = "An unsigned 16-bit integer that specifies the size, in bytes, of the ACE. The AceSize field can be greater than the sum of the individual fields. In cases where the AceSize field encompasses additional data for the callback ACEs types, that data is implementation-specific. Otherwise, this additional data is not interpreted and MUST be ignored."};
} with Documentation{Description = "The ACE_HEADER structure defines the type and size of an access control entry (ACE)."};
typedef PACE_HEADER = ACE_HEADER with IDL{IndirectionLevel = 1};

type SYSTEM_MANDATORY_LABEL_ACE
{
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
}
typedef PSYSTEM_MANDATORY_LABEL_ACE = SYSTEM_MANDATORY_LABEL_ACE with IDL{IndirectionLevel = 1};

type TOKEN_MANDATORY_POLICY
{
    DWORD Policy;
}
typedef PTOKEN_MANDATORY_POLICY = TOKEN_MANDATORY_POLICY with IDL{IndirectionLevel = 1};

type MANDATORY_INFORMATION
{
    ACCESS_MASK AllowedAccess;
    BOOLEAN WriteAllowed;
    BOOLEAN ReadAllowed;
    BOOLEAN ExecuteAllowed;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
}
typedef PMANDATORY_INFORMATION = MANDATORY_INFORMATION with IDL{IndirectionLevel = 1};

pattern CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_ValueType = enum ushort
{
    CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64 = 0x0001
        with Documentation
        {Description = "Values member refers to an array of offsets to LONG64 value(s)."},
    CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 = 0x0002
        with Documentation
        {Description = "Values member refers to an array of offsets to ULONG64 value(s)."},
    CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING = 0x0003
        with Documentation
        {Description = "Values member refers to an array of offsets to Unicode character string value(s)."},
    CLAIM_SECURITY_ATTRIBUTE_TYPE_SID = 0x0005
        with Documentation
        {Description = "The Values member refers to an array of offsets to CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_RELATIVE value(s) where the OctetString value is a SID string."},
    CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN = 0x0006
        with Documentation
        {Description = "The Values member refers to an array of offsets to ULONG64 values where each element indicates a Boolean value. The value 1 indicates TRUE, and the value 0 indicates FALSE."},
    CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING = 0x0010
        with Documentation
        {Description = "Values member contains an array of CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_RELATIVE value(s) as specified in section ."},
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1
{
    DWORD Name
        with Documentation
        {Description = "A DWORD value indicating an offset from the beginning of the CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 structure to a string of Unicode characters containing the name of the claim security attribute. The string MUST be at least 4 bytes in length."};

    WORD ValueType where ValidationCheck(InRange<CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_ValueType>(value), null, "DTYP: The ValueType in type CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 is an undefined value. Please refer to CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 in the Technical Document MS-DTYP.")
        with Documentation
        {Description = "A union tag value indicating the type of information referred to by the Values member. The Values member MUST be an array of offsets from the beginning of the ClaimSecurityAttribute_RELATIVE_V1 structure to the specified ValueType. ValueType MUST be one of the following values:"};

    WORD Reserved where ValidationCheck(value == 0, null, DiagnosisLevel.Error, "DTYP: The Reserved in type CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 must be set to zero.")
        with Documentation
        {Description = "Reserved. This member MUST be set to zero when sent and MUST be ignored when received."};

    ClaimSecurityAttributeRelativeV1Flags Flags
        with Documentation
        {Description = "MUST be zero or a combination of one or more of the following values:"};

    DWORD ValueCount
        with Documentation
        {Description = "The number of values contained in the Values member."};
    
    array<DWORD> Values
        with BinaryEncoding{Length = ValueCount},
        Documentation {Description = "An array of offsets from the beginning of the CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 structure. Each offset indicates the location of a claim security attribute value of type specified in the ValueType member."};
    
    optional [|Name > 20|] array<byte> NamePadding with BinaryEncoding{Length = Name - 20};
    string ClaimSecurityAttributeName;
    
    ([|ValueType == 0x0001|] array<LONG64> |
        [|ValueType == 0x0002|] array<ULONG64> |
        [|ValueType == 0x0003|] array<ClaimSecurityAttributeUnicodeString> |
        [|ValueType == 0x0005|] array<CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_RELATIVE> |
        [|ValueType == 0x0006|] array<ULONG64> |
        [|ValueType == 0x0010|] array<CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_RELATIVE>) ClaimSecurityAttributeValues
        with BinaryEncoding{Length = ValueCount},
        Documentation {Description = "An array of offsets from the beginning of the CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 structure. Each offset indicates the location of a claim security attribute value of type specified in the ValueType member."};
    
    ushort Length()
    {
        if (ValueCount > 0)
        {
            int lastIndex = ValueCount - 1 as int;
            var lastOffset = Values[lastIndex];
            int lastValueLength = 0;
            switch (ValueType)
            {
                case 0x0001 =>
                    lastValueLength = 8;
                case 0x0002 =>
                    lastValueLength = 8;
                case 0x0003 =>
                    var attributes = ClaimSecurityAttributeValues as array<ClaimSecurityAttributeUnicodeString>;
                    lastValueLength = (attributes[lastIndex].UnicodeString.Count + 1) * 2;
                case 0x0005 =>
                    var attributes = ClaimSecurityAttributeValues as array<CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_RELATIVE>;
                    lastValueLength = attributes[lastIndex].Length + 4 as int;
                case 0x0006 =>
                    lastValueLength = 8;
                case 0x0010 =>
                    var attributes = ClaimSecurityAttributeValues as array<CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_RELATIVE>;
                    lastValueLength = attributes[lastIndex].Length + 4 as int;
            }
            return lastOffset + lastValueLength as ushort;
        }
        return Name + (ClaimSecurityAttributeName.Count + 1) * 2 as ushort;
    }
} with Documentation
    {Description = "The CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 structure defines a resource attribute that is defined in contiguous memory for persistence within a serialized Security Descriptor."}
, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

typedef SECURITY_INFORMATION = DWORD
    with Documentation
    {Description = "An unsigned 32-bit integer specifies portions of a SECURITY_DESCRIPTOR by means of bit flags. Individual bit values (combinable with the bitwise OR operation) are as shown in the following table."};
typedef PSECURITY_INFORMATION = SECURITY_INFORMATION with IDL{IndirectionLevel = 1};

type RPC_SID
{   
    byte Revision where ValidationCheck(value == 1, null, DiagnosisLevel.Error, "DTYP: The Revision in type RPC_SID must be set to 0x01, not " + value.ToString() + ".")
        with Documentation // According to mapping rule, it should be char, but byte is also ok, use byte instead, suggest changing mapping rule, for DTYP might be used for NonRpc.
        {Description = "An 8-bit unsigned integer that specifies the revision level of the RPC_SID structure. This value MUST be set to 0x01."};
    byte SubAuthorityCount where ValidationCheck(value <= 15, null, DiagnosisLevel.Error, "DTYP: The SubAuthorityCount in type RPC_SID must be equal to or less than 15.")
        with Documentation // According to mapping rule, it should be char, but byte is also ok, use byte instead, suggest changing mapping rule, for DTYP might be used for NonRpc.
        {Description = "An 8-bit unsigned integer that specifies the number of elements in the SubAuthority array. The maximum number of elements allowed is 15."};
    RPC_SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    array<uint> SubAuthority with IDL{Size_is = [SubAuthorityCount], Dimensions = [null]};
}
typedef PRPC_SID = RPC_SID with IDL{IndirectionLevel = 1};
typedef PSID = RPC_SID with IDL{IndirectionLevel = 1};

type ACL
{
    // According to mapping rule, it should be char, but byte is also ok, use byte instead, suggest changing mapping rule, for DTYP might be used for NonRpc
    byte AclRevision where ValidationCheck(InRange<AclAclRevision>(value), null, "DTYP: The AclRevision in type ACL is an undefined value. Please refer to ACL in the Technical Document MS-DTYP.") 
        with Documentation
        {Description = "An unsigned 8-bit value that specifies the revision of the ACL structure. This field MUST be set to one of the following values."};
    byte Sbz1 where ValidationCheck(value == 0, null, "DTYP: The Sbz1 in type ACL is reserved and must be set to zero.") // According to mapping rule, it should be char, but byte is also ok, use byte instead, suggest changing mapping rule, for DTYP might be used for NonRpc
        with Documentation
        {Description = "An unsigned 8-bit value. This field is reserved and must be set to zero."};
    ushort AclSize
        with Documentation
        {Description = "An unsigned 16-bit integer that specifies the size of the complete ACL, including all ACEs, in bytes."};
    ushort AceCount
        with Documentation
        {Description = "An unsigned 16-bit integer that specifies the count of the number of ACE records in the ACL."};
    ushort Sbz2 where ValidationCheck(value == 0, null, "DTYP: The Sbz2 in type ACL is reserved and must be set to zero.")
        with Documentation
        {Description = "An unsigned 16-bit integer. This field is reserved and must be set to zero."};
} with Documentation{Description = "The access control list (ACL), is used to specify a list of individual access control entries (ACEs)."};
typedef PACL = ACL with IDL{IndirectionLevel = 1};

type SECURITY_DESCRIPTOR
{
    UCHAR Revision where ValidationCheck(value == 0x01, null, DiagnosisLevel.Error, "DTYP: The Revision in type SECURITY_DESCRIPTOR must be set to 0x01, not " + value.ToString() + ".")
        with Documentation
        {Description = "An unsigned 8-bit value that specifies the revision of the SECURITY_DESCRIPTOR structure. This field MUST be set to one."};
    UCHAR Sbz1;
    USHORT Control;
    PSID Owner;
    PSID Group;
    PACL Sacl;
    PACL Dacl;
}
typedef PSECURITY_DESCRIPTOR = SECURITY_DESCRIPTOR with IDL{IndirectionLevel = 1};

// ------------------------------------------------------------- below Not included in DTYP.idl ----------------------------------------------------------

static string BOOL2String(any v)
{
    assert (v is BOOL);
    int i = v as BOOL;
    if (i == 1)
    {
        return "true";
    }
    else if (i == 0)
    {
        return "false";
    }
    else
    {
        return "";
    }
}

pattern AccessMaskFlags = flags DWORD
{
    GenericRead                         = 0x80000000,
    GenericWrite                        = 0x40000000,
    GenericExecute                      = 0x20000000,
    GenericAll                          = 0x10000000,
    Reserved1                           = 0x0C000000,
    MaximumAllowed                      = 0x02000000,
    AccessSystemSecurity                = 0x01000000,
    Reserved2                           = 0x00E00000,
    Synchronize                         = 0x00100000,
    WriteOwner                          = 0x00080000,
    WriteDacl                           = 0x00040000,
    ReadControl                         = 0x00020000,
    Delete                              = 0x00010000,
    ...
} with IDL{DoNotGenerate = true}, Documentation{Ignore = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern SystemMandatoryLabelAceMaskFlags = flags DWORD
{
    GenericRead                         = 0x80000000,
    GenericWrite                        = 0x40000000,
    GenericExecute                      = 0x20000000,
    GenericAll                          = 0x10000000,
    Reserved1                           = 0x0C000000,
    MaximumAllowed                      = 0x02000000,
    AccessSystemSecurity                = 0x01000000,
    Reserved2                           = 0x00E00000,
    Synchronize                         = 0x00100000,
    WriteOwner                          = 0x00080000,
    WriteDacl                           = 0x00040000,
    ReadControl                         = 0x00020000,
    Delete                              = 0x00010000,
    SYSTEM_MANDATORY_LABEL_NO_WRITE_UP  = 0x00000001,
    SYSTEM_MANDATORY_LABEL_NO_READ_UP   = 0x00000002,
    SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP = 0x00000004,
    ...
} with IDL{DoNotGenerate = true}, Documentation{Ignore = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type SID_IDENTIFIER_AUTHORITY
{
    array<byte> Value with BinaryEncoding{Length = 6}, DisplayInfo{ToText = x => EnumToString(x, "DTYP.SidIdentifierAuthorityValue")}, Documentation
            {Description = "Six element arrays of 8-bit unsigned integers that specify the top-level authority of a SID, RPC_SID, and LSAPR_SID_INFORMATION."};
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern SidIdentifierAuthorityValue = enum binary
{
    NullSidAuthority = $[000000000000] 
        with Documentation 
        {Description = "Specifies the NULL SID authority. It defines only the NULL well-known-SID: S-1-0-0."},
    WorldSidAuthority = $[000000000001] 
        with Documentation 
        {Description = "Specifies the World SID authority. It only defines the Everyone well-known-SID: S-1-1-0."},
    LocalSidAuthority = $[000000000002] 
        with Documentation 
        {Description = "Specifies the Local SID authority. It defines only the Local well-known-SID: S-1-2-0."},
    CreatorSidAuthority = $[000000000003] 
        with Documentation 
        {Description = "Specifies the Creator SID authority. It defines the Creator Owner, Creator Group, and Creator Owner Server well-known-SIDs: S-1-3-0, S-1-3-1, and S-1-3-2. These SIDs are used as placeholders in an access control list (ACL) and are replaced by the user, group, and machine SIDs of the security principal."},
    NonUniqueAuthority = $[000000000004] 
        with Documentation{Description = "Not used."},
    NtAuthority = $[000000000005]
        with Documentation
        {Description = "Specifies the windows_nt security subsystem SID authority. It defines all other SIDs in the forest."},
    SecurityMandatoryLabelAuthority = $[000000000010]
        with Documentation
        {Description = "Specifies the Mandatory label authority. It defines the integrity level SIDs."},
    SecurityAppPackageAuthority = $[00000000000F]
        with Documentation
        {Description = "Specifies the application package authority. It defines application capability SIDs."},
        ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type SID
{
    byte Revision where value == 0x01 // where ValidationCheck(value == 1, null, DiagnosisLevel.Error, "DTYP: The Revision in type SID must be set to 0x01, not " + value.ToString() + ".")
        with Documentation
        {Description = "An 8-bit unsigned integer that specifies the revision level of the SID structure. This value MUST be set to 0x01."};
        
    byte SubAuthorityCount where ValidationCheck(value <= 15, null, DiagnosisLevel.Error, "DTYP: The SubAuthorityCount in type SID must be equal to or less than 15.")
        with Documentation
        {Description = "An 8-bit unsigned integer that specifies the number of elements in the SubAuthority array. The maximum number of elements allowed is 15."};
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority
        with Documentation
        {Description = "A SID_IDENTIFIER_AUTHORITY structure that contains information, which indicates the authority under which the SID was created. It describes the entity that created the SID and manages the account."};
    array<uint> SubAuthority with BinaryEncoding{Length = SubAuthorityCount}, IDL{Dimensions = [null]},
        Documentation
        {Description = "A variable length array of unsigned 32-bit integers that uniquely identifies a principal relative to the IdentifierAuthority. Its length is determined by SubAuthorityCount."};
    override string ToString()
    {
        string result = "S-";
        result += (Revision as string);
        if ((IdentifierAuthority.Value as binary).Segment(0, 5) == $[0000000000])
        {
            result += ("-" + (IdentifierAuthority.Value[5] as string));
        }
        else
        {
            result += ("-255");
        }
        for (int i = 0; i < SubAuthority.Count; i++)
        {
            result += ("-" + (SubAuthority[i] as string));
        }
        return (result + GetDescriptionStringForSID(result));
    }
    
    ushort Length()
    {
        return SubAuthorityCount * 4 + 8 as ushort;
    }
} with Documentation
    {Description = "The SID structure defines a security identifier (SID), which is a variable-length byte array that uniquely identifies a security principal. Each security principal has a unique SID that is issued by a security agent. The agent can be a windows local system or domain. The agent generates the SID when the security principal is created. The RPC marshaled version of the SID structure is defined in section ."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

string GetDescriptionStringForSID(string sidString)
{
    switch (sidString)
    {
        case "S-1-0-0"            => return " Null -- No Security principal.";
        case "S-1-1-0"            => return " Everyone -- A group that includes all users.";
        case "S-1-2-0"            => return " Local -- A group that includes all users that have logged on locally.";
        case "S-1-2-1"            => return " ConsoleLogon -- A group that includes users that are logged on to the physical console.Supported in windows_7.";
        case "S-1-3-0"            => return " CreatorOwner -- A placeholder in an inheritable access control entry (ACE). When the ACE is inherited, the system replaces this SID with the SID for the object's creator.";
        case "S-1-3-1"            => return " CreatorGroup -- A placeholder in an inheritable ACE. When the ACE is inherited, the system replaces this SID with the SID for the primary group of the object's creator.";
        case "S-1-3-2"            => return " OwnerServer -- A placeholder in an inheritable ACE. When the ACE is inherited, the system replaces this SID with the SID for the object's owner server.";
        case "S-1-3-3"            => return " GroupServer -- A placeholder in an inheritable ACE. When the ACE is inherited, the system replaces this SID with the SID for the object's group server.";
        case "S-1-3-4"            => return " OwnerRights -- A group that represents the current owner of the object. When an ACE carrying this SID is applied to an object, the system ignores the implicit READ_CONTROL and WRITE_DAC permissions for the object owner.";
        case "S-1-5"              => return " NtAuthority -- A SID containing only the SECURITY_NT_AUTHORITY identifier authority.";
        case "S-1-5-1"            => return " Dialup -- A group that includes all users who have logged on through a dial-up connection.";
        case "S-1-5-2"            => return " Network -- A group that includes all users that have logged on through a network connection.";
        case "S-1-5-3"            => return " Batch -- A group that includes all users that have logged on through a batch queue facility.";
        case "S-1-5-4"            => return " Interactive -- A group that includes all users that have logged on interactively.";
        // "S-1-5-5-x-y" in default case
        case "S-1-5-6"            => return " Service -- A group that includes all security principals that have logged on as a service.";
        case "S-1-5-7"            => return " Anonymous -- A group that represents an anonymous logon.";
        case "S-1-5-8"            => return " Proxy -- Identifies a SECURITY_NT_AUTHORITY Proxy.";
        case "S-1-5-9"            => return " EnterpriseDomainControllers -- A group that includes all domain controllers in a forest that uses an Active Directory directory service.";
        case "S-1-5-10"           => return " PrincipalSelf -- A placeholder in an inheritable ACE on an account object or group object in Active Directory. When the ACE is inherited, the system replaces this SID with the SID for the security principal who holds the account.";
        case "S-1-5-11"           => return " AuthenticatedUsers -- A group that includes all users whose identities were authenticated when they logged on.";
        case "S-1-5-12"           => return " RestrictedCode -- A group that is used to control access by untrusted code.";
        case "S-1-5-13"           => return " TerminalServerUser -- A group that includes all users that have logged on to a Terminal Services server.";
        case "S-1-5-14"           => return " RemoteInteractiveLogon -- A group that includes all users that have logged on through a terminal services logon.";
        case "S-1-5-15"           => return " ThisOrganization -- A group that includes all users from the same organization. If this SID is present, then the OTHER_ORGANIZATION SID MUST NOT be present.Supported in windows_server_2003 and windows_server_2008. The DC will add this SID: When the user is a member of the forest.When the user is not a member of the forest and the TRUST_ATTRIBUTE_CROSS_ORGANIZATION bit of the Trust Attribute ([MS-ADTS] section ) of the trusted domain object is not set.";
        case "S-1-5-17"           => return " Iusr -- An account that is used by the default IIS user.";
        case "S-1-5-18"           => return " LocalSystem -- An account that is used by the operating system.";
        case "S-1-5-19"           => return " LocalService -- Local service account.";
        case "S-1-5-20"           => return " NetworkService -- Network Service account.";
        // "S-1-5-21-<root domain>-498" in default case
        case "S-1-5-21-0-0-0-496" => return " CompoundedAuthentication -- Device identity is included in the Kerberos service ticket. If a forest boundary was crossed, then claims transformation occurred.";
        case "S-1-5-21-0-0-0-497" => return " ClaimsValid -- Claims were queried for in the account's domain, and if a forest boundary was crossed, then claims transformation occurred.";
        // "S-1-5-21-<domain>-500" in default case
        // "S-1-5-21-<domain>-501" in default case
        // "S-1-5-21-<domain>-512" in default case
        // "S-1-5-21-<domain>-513" in default case
        // "S-1-5-21-<domain>-514" in default case
        // "S-1-5-21-<domain>-515" in default case
        // "S-1-5-21-<domain>-516" in default case
        // "S-1-5-21-<domain>-517" in default case
        // "S-1-5-21-<root-domain>-518" in default case
        // "S-1-5-21-<root-domain>-519" in default case
        // "S-1-5-21-<domain>-520" in default case
        // "S-1-5-21-<domain>-521" in default case
        // "S-1-5-21-<domain>-522" in default case
        // "S-1-5-<domain>-553" in default case
        case "S-1-5-32-544"       => return " BuiltinAdministrators -- A built-in group. After the initial installation of the operating system, the only member of the group is the Administrator account. When a computer joins a domain, the Domain Administrators group is added to the Administrators group. When a server becomes a domain controller, the Enterprise Administrators group also is added to the Administrators group.";
        case "S-1-5-32-545"       => return " BuiltinUsers -- A built-in group. After the initial installation of the operating system, the only member is the Authenticated Users group. When a computer joins a domain, the Domain Users group is added to the Users group on the computer.";
        case "S-1-5-32-546"       => return " BuiltinGuests -- A built-in group. The Guests group allows users to log on with limited privileges to a computer's built-in Guest account.";
        case "S-1-5-32-547"       => return " PowerUsers -- A built-in group. Power users can perform the following actions.";
        case "S-1-5-32-548"       => return " AccountOperators -- A built-in group that exists only on domain controllers. Account Operators have permission to create, modify, and delete accounts for users, groups, and computers in all containers and organizational units of Active Directory except the Built-in container and the Domain Controllers OU. Account Operators do not have permission to modify the Administrators and Domain Administrators groups, nor do they have permission to modify the accounts for members of those groups.";
        case "S-1-5-32-549"       => return " ServerOperators -- A built-in group that exists only on domain controllers. Server Operators can perform the following actions.";
        case "S-1-5-32-550"       => return " PrinterOperators -- A built-in group that exists only on domain controllers. Print Operators can manage printers and document queues.";
        case "S-1-5-32-551"       => return " BackupOperators -- A built-in group. Backup Operators can back up and restore all files on a computer, regardless of the permissions that protect those files.";
        case "S-1-5-32-552"       => return " Replicator -- A built-in group that is used by the File Replication service on domain controllers.";
        case "S-1-5-32-554"       => return " AliasPrew2kcompacc -- A backward compatibility group which allows read access on all users and groups in the domain. Added in windows_2000.";
        case "S-1-5-32-555"       => return " RemoteDesktop -- An alias. Members in this group are granted the right to logon remotely.";
        case "S-1-5-32-556"       => return " NetworkConfigurationOps -- An alias. Members in this group can have some administrative privileges to manage configuration of networking features.";
        case "S-1-5-32-557"       => return " IncomingForestTrustBuilders -- An alias. Members of this group can create incoming, one-way trusts to this forest.";
        case "S-1-5-32-558"       => return " PerfmonUsers -- An alias. Members of this group have remote access to monitor this computer.";
        case "S-1-5-32-559"       => return " PerflogUsers -- An alias. Members of this group have remote access to schedule logging of performance counters on this computer.";
        case "S-1-5-32-560"       => return " WindowsAuthorizationAccessGroup -- An alias. Members of this group have access to the computed tokenGroupsGlobalAndUniversal attribute on User objects.";
        case "S-1-5-32-561"       => return " TerminalServerLicenseServers -- An alias. A group for Terminal Server License Servers.";
        case "S-1-5-32-562"       => return " DistributedComUsers -- An alias. A group for COM to provide computer-wide access controls that govern access to all call, activation, or launch requests on the computer.";
        case "S-1-5-32-568"       => return " IisIusrs -- A built-in group account for IIS users.";
        case "S-1-5-32-569"       => return " CryptographicOperators -- A built-in group account for cryptographic operators.";
        case "S-1-5-32-573"       => return " EventLogReaders -- A built-in local group.  Members of this group can read event logs from the local machine.";
        case "S-1-5-32-574"       => return " CertificateServiceDcomAccess -- A built-in local group. Members of this group are allowed to connect to Certification Authorities in the enterprise.";
        case "S-1-5-32-575"       => return " RdsRemoteAccessServers -- A group that allows members use of Remote Application Services resources.";
        case "S-1-5-32-576"       => return " RdsEndpointServers -- A group that enables member servers to run virtual machines and host sessions.";
        case "S-1-5-32-577"       => return " RdsManagementServers -- A group that allows members to access WMI resources over management protocols (such as WS-Management via the Windows Remote Management service).";
        case "S-1-5-32-578"       => return " HyperVAdmins -- A group that gives members access to all administrative features of Hyper-V.";
        case "S-1-5-32-579"       => return " AccessControlAssistanceOps -- A local group that allows members to remotely query authorization attributes and permissions for resources on the local computer.";
        case "S-1-5-32-580"       => return " RemoteManagementUsers -- Members of this group can access Windows Management Instrumentation (WMI) resources over management protocols (such as WS-Management [DMTF-DSP0226]). This applies only to WMI namespaces that grant access to the user.";
        case "S-1-5-33"           => return " WriteRestrictedCode -- This SID allows objects to have an ACL that lets any service process with a write-restricted token write to the object.";
        case "S-1-5-64-10"        => return " NtlmAuthentication -- A SID that is used when the NTLM authentication package authenticated the client.";
        case "S-1-5-64-14"        => return " SchannelAuthentication -- A SID that is used when the SChannel authentication package authenticated the client.";
        case "S-1-5-64-21"        => return " DigestAuthentication -- A SID that is used when the Digest authentication package authenticated the client.";
        case "S-1-5-65-1"         => return " ThisOrganizationCertificate -- A SID that indicates that the client's Kerberos service ticket's PAC contained a NTLM_SUPPLEMENTAL_CREDENTIAL structure (as specified in [MS-PAC] section 2.6.4). If the OTHER_ORGANIZATION SID is present, then this SID MUST NOT be present.";
        case "S-1-5-80"           => return " NTService -- NT Service Account prefix.";
        case "S-1-5-84-0-0-0-0-0" => return " UserModeDrivers -- Identifies a user-mode driver process.";
        case "S-1-5-1000"         => return " OtherOrganization -- A group that includes all users and computers from another organization. If this SID is present, then THIS_ORGANIZATION SID MUST NOT be present.  Supported in windows_server_2003 and windows_server_2008. When the TRUST_ATTRIBUTE_CROSS_ORGANIZATION bit of the Trust Attribute ([MS-ADTS] section ) of the trusted domain object is set:If the forest boundary is crossed, DCs will add this SID.If receiving requests to authenticate to resources in their domain, DCs will check the computer object to ensure that this SID is allowed.";
        case "S-1-15-2-1"         => return " AllAppPackages -- All applications running in an app package context.";
        case "S-1-16-0"           => return " MLUntrusted -- Untrusted integrity level.";
        case "S-1-16-4096"        => return " MLLow -- Low integrity level.";
        case "S-1-16-8192"        => return " MLMedium -- Medium integrity level.";
        case "S-1-16-8448"        => return " MLMediumPlus -- Medium plus integrity level.";
        case "S-1-16-12288"       => return " MLHigh -- High integrity level.";
        case "S-1-16-16384"       => return " MLSystem -- System integrity level.";
        case "S-1-16-20480"       => return " MLProtectedProcess -- Protected process integrity level.";
        case "S-1-18-1"           => return " AuthenticationAuthorityAssertedIdentity -- A SID that means the client's identity is asserted by an authentication authority based on proof of possession of client credentials.";
        case "S-1-18-2"           => return " ServiceAssertedIdentity -- A SID that means the client's identity is asserted by a service.";
        default                           =>
            if (sidString.IndexOf("S-1-5-5-") == 0)
            {
                return " LogonID -- A logon session. The X and Y values for these SIDs are different for each logon session, and will be recycled when the operating system is rebooted.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "498")
            {
                return " EnterpriseReadonlyDomainControllers -- A universal group containing all read-only domain controllers in a forest.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "500")
            {
                return "Administrator -- A user account for the system administrator. By default, it is the only user account that is given full control over the system.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "501")
            {
                return "Guest -- A user account for people who do not have individual accounts. This user account does not require a password. By default, the Guest account is disabled.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "512")
            {
                return "DomainAdmins -- A global group whose members are authorized to administer the domain. By default, the DOMAIN_ADMINS group is a member of the Administrators group on all computers that have joined a domain, including the domain controllers. DOMAIN_ADMINS is the default owner of any object that is created by any member of the group.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "513")
            {
                return " DomainUsers -- A global group that includes all user accounts in a domain.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "514")
            {
                return " DomainGuests -- A global group that has only one member, the domain's built-in Guest account.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "515")
            {
                return " DomainComputers -- A global group that includes all clients and servers that have joined the domain.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "516")
            {
                return " DomainDomainControllers -- A global group that includes all domain controllers in the domain.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "517")
            {
                return " CertPublishers -- A global group that includes all computers that are running an enterprise certification authority. Cert Publishers are authorized to publish certificates for User objects in Active Directory.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "518")
            {
                return " SchemaAdministrators -- A universal group in a native-mode domain, or a global group in a mixed-mode domain. The group is authorized to make schema changes in Active Directory.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "519")
            {
                return " EnterpriseAdmins -- A universal group in a native-mode domain, or a global group in a mixed-mode domain. The group is authorized to make forest-wide changes in Active Directory, such as adding child domains.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "520")
            {
                return " GroupPolicyCreatorOwners -- A global group that is authorized to create new Group Policy Objects in Active Directory.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "521")
            {
                return " ReadonlyDomainControllers -- A global group that includes all read-only domain controllers.";
            }
            else if (sidString.IndexOf("S-1-5-21-") == 0 && sidString.Segment(sidString.Count - 3) == "522")
            {
                return " CloneableControllers -- A global group that includes all domain controllers in the domain that may be cloned.";
            }
            else if (sidString.IndexOf("S-1-5-") == 0 && sidString.Segment(sidString.Count - 3) == "553")
            {
                return " RasServers -- A domain local group. Servers in this group have Read Account Restrictions and Read Logon Information access to User objects in the Active Directory domain local group.";
            }
            else
            {
                return " Unknown SID";
            }
    }
}

const string Null = "S-1-0-0"
    with Documentation{Description = "No Security principal."};
const string Everyone = "S-1-1-0"
    with Documentation{Description = "A group that includes all users."};
const string Local = "S-1-2-0"
    with Documentation
    {Description = "A group that includes all users that have logged on locally."};
const string ConsoleLogon = "S-1-2-1"
    with Documentation
    {Description = "A group that includes users that are logged on to the physical console.Supported in windows_7."};
const string CreatorOwner = "S-1-3-0"
    with Documentation
    {Description = "A placeholder in an inheritable access control entry (ACE). When the ACE is inherited, the system replaces this SID with the SID for the object's creator."};
const string CreatorGroup = "S-1-3-1"
    with Documentation
    {Description = "A placeholder in an inheritable ACE. When the ACE is inherited, the system replaces this SID with the SID for the primary group of the object's creator."};
const string OwnerServer = "S-1-3-2"
    with Documentation
    {Description = "A placeholder in an inheritable ACE. When the ACE is inherited, the system replaces this SID with the SID for the object's owner server."};
const string GroupServer = "S-1-3-3"
    with Documentation
    {Description = "A placeholder in an inheritable ACE. When the ACE is inherited, the system replaces this SID with the SID for the object's group server."};
const string OwnerRights = "S-1-3-4"
    with Documentation
    {Description = "A group that represents the current owner of the object. When an ACE carrying this SID is applied to an object, the system ignores the implicit READ_CONTROL and WRITE_DAC permissions for the object owner."};
const string NtAuthority = "S-1-5"
    with Documentation
    {Description = "A SID containing only the SECURITY_NT_AUTHORITY identifier authority."};
const string Dialup = "S-1-5-1"
    with Documentation
    {Description = "A group that includes all users who have logged on through a dial-up connection."};
const string Network = "S-1-5-2"
    with Documentation
    {Description = "A group that includes all users that have logged on through a network connection."};
const string Batch = "S-1-5-3"
    with Documentation
    {Description = "A group that includes all users that have logged on through a batch queue facility."};
const string Interactive = "S-1-5-4"
    with Documentation
    {Description = "A group that includes all users that have logged on interactively."};
const string LogonID = "S-1-5-5-x-y"
    with Documentation
    {Description = "A logon session. The X and Y values for these SIDs are different for each logon session, and will be recycled when the operating system is rebooted."};
const string Service = "S-1-5-6"
    with Documentation
    {Description = "A group that includes all security principals that have logged on as a service."};
const string Anonymous = "S-1-5-7"
    with Documentation
    {Description = "A group that represents an anonymous logon."};
const string Proxy = "S-1-5-8"
    with Documentation
    {Description = "Identifies a SECURITY_NT_AUTHORITY Proxy."};
const string EnterpriseDomainControllers = "S-1-5-9"
    with Documentation
    {Description = "A group that includes all domain controllers in a forest that uses an Active Directory directory service."};
const string PrincipalSelf = "S-1-5-10"
    with Documentation
    {Description = "A placeholder in an inheritable ACE on an account object or group object in Active Directory. When the ACE is inherited, the system replaces this SID with the SID for the security principal who holds the account."};
const string AuthenticatedUsers = "S-1-5-11"
    with Documentation
    {Description = "A group that includes all users whose identities were authenticated when they logged on."};
const string RestrictedCode = "S-1-5-12"
    with Documentation
    {Description = "A group that is used to control access by untrusted code."};
const string TerminalServerUser = "S-1-5-13"
    with Documentation
    {Description = "A group that includes all users that have logged on to a Terminal Services server."};
const string RemoteInteractiveLogon = "S-1-5-14"
    with Documentation
    {Description = "A group that includes all users that have logged on through a terminal services logon."};
const string ThisOrganization = "S-1-5-15"
    with Documentation
    {Description = "A group that includes all users from the same organization. If this SID is present, then the OTHER_ORGANIZATION SID MUST NOT be present.Supported in windows_server_2003 and windows_server_2008. The DC will add this SID: When the user is a member of the forest.When the user is not a member of the forest and the TRUST_ATTRIBUTE_CROSS_ORGANIZATION bit of the Trust Attribute ([MS-ADTS] section ) of the trusted domain object is not set."};
const string Iusr = "S-1-5-17"
    with Documentation
    {Description = "An account that is used by the default IIS user."};
const string LocalSystem = "S-1-5-18"
    with Documentation
    {Description = "An account that is used by the operating system."};
const string LocalService = "S-1-5-19"
    with Documentation{Description = "Local service account."};
const string NetworkService = "S-1-5-20"
    with Documentation{Description = "Network Service account."};
const string EnterpriseReadonlyDomainControllers = "S-1-5-21-<root domain>-498"
    with Documentation
    {Description = "A universal group containing all read-only domain controllers in a forest."};
const string CompoundedAuthentication = "S-1-5-21-0-0-0-496"
    with Documentation
    {Description = "Device identity is included in the Kerberos service ticket. If a forest boundary was crossed, then claims transformation occurred."};
const string ClaimsValid = "S-1-5-21-0-0-0-497"
    with Documentation
    {Description = "Claims were queried for in the account's domain, and if a forest boundary was crossed, then claims transformation occurred."};
const string Administrator = "S-1-5-21-<machine>-500"
    with Documentation
    {Description = "A user account for the system administrator. By default, it is the only user account that is given full control over the system."};
const string Guest = "S-1-5-21-<machine>-501"
    with Documentation
    {Description = "A user account for people who do not have individual accounts. This user account does not require a password. By default, the Guest account is disabled."};
const string DomainAdmins = "S-1-5-21-<domain>-512"
    with Documentation
    {Description = "A global group that includes all user accounts in a domain."};
const string DomainUsers = "S-1-5-21-<domain>-513"
    with Documentation
    {Description = "A global group that includes all user accounts in a domain."};
const string DomainGuests = "S-1-5-21-<domain>-514"
    with Documentation
    {Description = "A global group that has only one member, the domain's built-in Guest account."};
const string DomainComputers = "S-1-5-21-<domain>-515"
    with Documentation
    {Description = "A global group that includes all clients and servers that have joined the domain."};
const string DomainDomainControllers = "S-1-5-21-<domain>-516"
    with Documentation
    {Description = "A global group that includes all domain controllers in the domain."};
const string CertPublishers = "S-1-5-21-<domain>-517"
    with Documentation
    {Description = "A global group that includes all computers that are running an enterprise certification authority. Cert Publishers are authorized to publish certificates for User objects in Active Directory."};
const string SchemaAdministrators = "S-1-5-21-<root-domain>-518"
    with Documentation
    {Description = "A universal group in a native-mode domain, or a global group in a mixed-mode domain. The group is authorized to make schema changes in Active Directory."};
const string EnterpriseAdmins = "S-1-5-21-<root-domain>-519"
    with Documentation
    {Description = "A universal group in a native-mode domain, or a global group in a mixed-mode domain. The group is authorized to make forest-wide changes in Active Directory, such as adding child domains."};
const string GroupPolicyCreatorOwners = "S-1-5-21-<domain>-520"
    with Documentation
    {Description = "A global group that is authorized to create new Group Policy Objects in Active Directory."};
const string ReadonlyDomainControllers = "S-1-5-21-<domain>-521"
    with Documentation
    {Description = "A global group that includes all read-only domain controllers."};
const string CloneableControllers = "S-1-5-21-<domain>-522"
    with Documentation
    {Description = "A global group that includes all domain controllers in the domain that may be cloned."};
const string RasServers = "S-1-5-<domain>-553"
    with Documentation
    {Description = "A domain local group. Servers in this group have Read Account Restrictions and Read Logon Information access to User objects in the Active Directory domain local group."};
const string BuiltinAdministrators = "S-1-5-32-544"
    with Documentation
    {Description = "A built-in group. After the initial installation of the operating system, the only member of the group is the Administrator account. When a computer joins a domain, the Domain Administrators group is added to the Administrators group. When a server becomes a domain controller, the Enterprise Administrators group also is added to the Administrators group."};
const string BuiltinUsers = "S-1-5-32-545"
    with Documentation
    {Description = "A built-in group. After the initial installation of the operating system, the only member is the Authenticated Users group. When a computer joins a domain, the Domain Users group is added to the Users group on the computer."};
const string BuiltinGuests = "S-1-5-32-546"
    with Documentation
    {Description = "A built-in group. The Guests group allows users to log on with limited privileges to a computer's built-in Guest account."};
const string PowerUsers = "S-1-5-32-547"
    with Documentation
    {Description = "A built-in group. Power users can perform the following actions."};
const string AccountOperators = "S-1-5-32-548"
    with Documentation
    {Description = "A built-in group that exists only on domain controllers. Account Operators have permission to create, modify, and delete accounts for users, groups, and computers in all containers and organizational units of Active Directory except the Built-in container and the Domain Controllers OU. Account Operators do not have permission to modify the Administrators and Domain Administrators groups, nor do they have permission to modify the accounts for members of those groups."};
const string ServerOperators = "S-1-5-32-549"
    with Documentation
    {Description = "A built-in group that exists only on domain controllers. Server Operators can perform the following actions."};
const string PrinterOperators = "S-1-5-32-550"
    with Documentation
    {Description = "A built-in group that exists only on domain controllers. Print Operators can manage printers and document queues."};
const string BackupOperators = "S-1-5-32-551"
    with Documentation
    {Description = "A built-in group. Backup Operators can back up and restore all files on a computer, regardless of the permissions that protect those files."};
const string Replicator = "S-1-5-32-552"
    with Documentation
    {Description = "A built-in group that is used by the File Replication service on domain controllers."};
const string AliasPrew2kcompacc = "S-1-5-32-554"
    with Documentation
    {Description = "A backward compatibility group which allows read access on all users and groups in the domain. Added in windows_2000."};
const string RemoteDesktop = "S-1-5-32-555"
    with Documentation
    {Description = "An alias. Members in this group are granted the right to logon remotely."};
const string NetworkConfigurationOps = "S-1-5-32-556"
    with Documentation
    {Description = "An alias. Members in this group can have some administrative privileges to manage configuration of networking features."};
const string IncomingForestTrustBuilders = "S-1-5-32-557"
    with Documentation
    {Description = "An alias. Members of this group can create incoming, one-way trusts to this forest."};
const string PerfmonUsers = "S-1-5-32-558"
    with Documentation
    {Description = "An alias. Members of this group have remote access to monitor this computer."};
const string PerflogUsers = "S-1-5-32-559"
    with Documentation
    {Description = "An alias. Members of this group have remote access to schedule logging of performance counters on this computer."};
const string WindowsAuthorizationAccessGroup = "S-1-5-32-560"
    with Documentation
    {Description = "An alias. Members of this group have access to the computed tokenGroupsGlobalAndUniversal attribute on User objects."};
const string TerminalServerLicenseServers = "S-1-5-32-561"
    with Documentation
    {Description = "An alias. A group for Terminal Server License Servers."};
const string DistributedComUsers = "S-1-5-32-562"
    with Documentation
    {Description = "An alias. A group for COM to provide computer-wide access controls that govern access to all call, activation, or launch requests on the computer."};
const string IisIusrs = "S-1-5-32-568"
    with Documentation
    {Description = "A built-in group account for IIS users."};
const string CryptographicOperators = "S-1-5-32-569"
    with Documentation
    {Description = "A built-in group account for cryptographic operators."};
const string EventLogReaders = "S-1-5-32-573"
    with Documentation
    {Description = "A built-in local group.  Members of this group can read event logs from the local machine."};
const string CertificateServiceDcomAccess = "S-1-5-32-574"
    with Documentation
    {Description = "A built-in local group. Members of this group are allowed to connect to Certification Authorities in the enterprise."};
const string RdsRemoteAccessServers = "S-1-5-32-575"
    with Documentation
    {Description = "A group that allows members use of Remote Application Services resources."};
const string RdsEndpointServers = "S-1-5-32-576"
    with Documentation
    {Description = "A group that enables member servers to run virtual machines and host sessions."};
const string RdsManagementServers = "S-1-5-32-577"
    with Documentation
    {Description = "A group that allows members to access WMI resources over management protocols (such as WS-Management via the Windows Remote Management service)."};
const string HyperVAdmins = "S-1-5-32-578"
    with Documentation
    {Description = "A group that gives members access to all administrative features of Hyper-V."};
const string AccessControlAssistanceOps = "S-1-5-32-579"
    with Documentation
    {Description = "A local group that allows members to remotely query authorization attributes and permissions for resources on the local computer."};
const string WriteRestrictedCode = "S-1-5-33"
    with Documentation
    {Description = "This SID allows objects to have an ACL that lets any service process with a write-restricted token write to the object."};
const string NtlmAuthentication = "S-1-5-64-10"
    with Documentation
    {Description = "A SID that is used when the NTLM authentication package authenticated the client."};
const string SchannelAuthentication = "S-1-5-64-14"
    with Documentation
    {Description = "A SID that is used when the SChannel authentication package authenticated the client."};
const string DigestAuthentication = "S-1-5-64-21"
    with Documentation
    {Description = "A SID that is used when the Digest authentication package authenticated the client."};
const string ThisOrganizationCertificate = "S-1-5-65-1"
    with Documentation
    {Description = "A SID that indicates that the client's Kerberos service ticket's PAC contained a NTLM_SUPPLEMENTAL_CREDENTIAL structure (as specified in [MS-PAC] section 2.6.4). If the OTHER_ORGANIZATION SID is present, then this SID MUST NOT be present."};
const string NTService = "S-1-5-80"
    with Documentation{Description = "NT Service Account prefix."};
const string UserModeDrivers = "S-1-5-84-0-0-0-0-0"
    with Documentation
    {Description = "Identifies a user-mode driver process."};
const string OtherOrganization = "S-1-5-1000"
    with Documentation
    {Description = "A group that includes all users and computers from another organization. If this SID is present, then THIS_ORGANIZATION SID MUST NOT be present.  Supported in windows_server_2003 and windows_server_2008. When the TRUST_ATTRIBUTE_CROSS_ORGANIZATION bit of the Trust Attribute ([MS-ADTS] section ) of the trusted domain object is set:If the forest boundary is crossed, DCs will add this SID.If receiving requests to authenticate to resources in their domain, DCs will check the computer object to ensure that this SID is allowed."};
const string AllAppPackages = "S-1-15-2-1"
    with Documentation{Description = "All applications running in an app package context."};
const string MLUntrusted = "S-1-16-0"
    with Documentation{Description = "Untrusted integrity level."};
const string MLLow = "S-1-16-4096"
    with Documentation{Description = "Low integrity level."};
const string MLMedium = "S-1-16-8192"
    with Documentation{Description = "Medium integrity level."};
const string MLMediumPlus = "S-1-16-8448"
    with Documentation{Description = "Medium plus integrity level."};
const string MLHigh = "S-1-16-12288"
    with Documentation{Description = "High integrity level."};
const string MLSystem = "S-1-16-16384"
    with Documentation{Description = "System integrity level."};
const string MLProtectedProcess = "S-1-16-20480"
    with Documentation{Description = "Protected process integrity level."};
const string AuthenticationAuthorityAssertedIdentity = "S-1-18-1"
    with Documentation{Description = "A SID that means the client's identity is asserted by an authentication authority based on proof of possession of client credentials."};
const string ServiceAssertedIdentity = "S-1-18-2"
    with Documentation{Description = "A SID that means the client's identity is asserted by a service."};

pattern AceHeaderAceType = enum byte
{
    AccessAllowedAceType = 0x00
        with Documentation
        {Description = "Access-allowed ACE that uses the ACCESS_ALLOWED_ACE structure."},
    AccessDeniedAceType = 0x01
        with Documentation
        {Description = "Access-denied ACE that uses the ACCESS_DENIED_ACE (section 2.4.4.4) structure."},
    SystemAuditAceType = 0x02
        with Documentation
        {Description = "System-audit ACE that uses the SYSTEM_AUDIT_ACE (section 2.4.4.10) structure."},
    SystemAlarmAceType = 0x03
        with Documentation{Description = "Reserved for future use."},
    AccessAllowedCompoundAceType = 0x04
        with Documentation{Description = "Reserved for future use."},
    AccessAllowedObjectAceType = 0x05
        with Documentation
        {Description = "Object-specific access-allowed ACE that uses the ACCESS_ALLOWED_OBJECT_ACE (section 2.4.4.3) structure.windows_nt_4_0: Not supported."},
    AccessDeniedObjectAceType = 0x06
        with Documentation
        {Description = "Object-specific access-denied ACE that uses the ACCESS_DENIED_OBJECT_ACE (section 2.4.4.5) structure.windows_nt_4_0: Not supported."},
    SystemAuditObjectAceType = 0x07
        with Documentation
        {Description = "Object-specific system-audit ACE that uses the SYSTEM_AUDIT_OBJECT_ACE (section 2.4.4.11) structure.windows_nt_4_0: Not supported."},
    SystemAlarmObjectAceType = 0x08
        with Documentation{Description = "Reserved for future use."},
    AccessAllowedCallbackAceType = 0x09
        with Documentation
        {Description = "Access-allowed callback ACE that uses the ACCESS_ALLOWED_CALLBACK_ACE (section 2.4.4.6) structure.windows_nt_4_0 and windows_2000: Not supported."},
    AccessDeniedCallbackAceType = 0x0A
        with Documentation
        {Description = "Access-denied callback ACE that uses the ACCESS_DENIED_CALLBACK_ACE (section 2.4.4.7)  structure.windows_nt_4_0 and windows_2000: Not supported."},
    AccessAllowedCallbackObjectAceType = 0x0B
        with Documentation
        {Description = "Object-specific access-allowed callback ACE that uses the ACCESS_ALLOWED_CALLBACK_OBJECT_ACE (section 2.4.4.8) structure.windows_nt_4_0 and windows_2000: Not supported."},
    AccessDeniedCallbackObjectAceType = 0x0C
        with Documentation
        {Description = "Object-specific access-denied callback ACE that uses the ACCESS_DENIED_CALLBACK_OBJECT_ACE (section 2.4.4.9) structure.windows_nt_4_0 and windows_2000: Not supported."},
    SystemAuditCallbackAceType = 0x0D
        with Documentation
        {Description = "System-audit callback ACE that uses the SYSTEM_AUDIT_CALLBACK_ACE (section 2.4.4.12) structure.windows_nt_4_0 and windows_2000: Not supported."},
    SystemAlarmCallbacnAceType = 0x0E
        with Documentation{Description = "Reserved for future use."},
    SystemAuditCallbackObjectAceType = 0x0F
        with Documentation
        {Description = "Object-specific system-audit callback ACE that uses the SYSTEM_AUDIT_CALLBACK_OBJECT_ACE (section 2.4.4.14) structure."},
    SystemAlarmCallbackObjectAceType = 0x10
        with Documentation{Description = "Reserved for future use."},
    SystemMandatoryLabelAceType = 0x11
        with Documentation
        {Description = "Mandatory label ACE that uses the SYSTEM_MANDATORY_LABEL_ACE (section 2.4.4.13) structure."},
    SystemResourceAttributeAceType = 0x12
        with Documentation
        {Description = "Resource attribute ACE that uses the SYSTEM_RESOURCE_ATTRIBUTE_ACE."},
    SystemScopedPolicyIdAceType = 0x13
        with Documentation
        {Description = "A central policy ID ACE that uses the SYSTEM_SCOPED_POLICY_ID_ACE."},
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AceHeaderAceFlags = flags byte
{
    ObjectInheritAce = 0x01
        with Documentation
        {Description = "Noncontainer child objects inherit the ACE as an effective ACE."},
    ContainerInheritAce = 0x02
        with Documentation
        {Description = "Child objects that are containers, such as directories, inherit the ACE as an effective ACE. The inherited ACE is inheritable unless the NO_PROPAGATE_INHERIT_ACE bit flag is also set."},
    NoPropagateInheritAce = 0x04
        with Documentation
        {Description = "If the ACE is inherited by a child object, the system clears the OBJECT_INHERIT_ACE and CONTAINER_INHERIT_ACE flags in the inherited ACE. This prevents the ACE from being inherited by subsequent generations of objects."},
    InheritOnlyAce = 0x08
        with Documentation
        {Description = "Indicates an inherit-only ACE, which does not control access to the object to which it is attached. If this flag is not set, the ACE is an effective ACE that controls access to the object to which it is attached."},
    InheritedAce = 0x10
        with Documentation
        {Description = "Indicates that the ACE was inherited. The system sets this bit when it propagates an inherited ACE to a child object.windows_nt_4_0: Not supported."},
    Reserved = 0x20,
    SuccessfulAccessAceFlag = 0x40
        with Documentation
        {Description = "Used with system-audit ACEs in a SACL to generate audit messages for successful access attempts."},
    FailedAcceddAceFlag = 0x80
        with Documentation
        {Description = "Used with system-audit ACEs in a system access control list (SACL) to generate audit messages for failed access attempts."},
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type AccessAllowedAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK that specifies the user rights allowed by this ACE."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8 > 0|] binary AdditionalData with BinaryEncoding{Length = (Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "This additional data is not interpreted and MUST be ignored."};
} with Documentation
    {Description = "The ACCESS_ALLOWED_ACE structure defines an ACE for the discretionary access control list (DACL) that controls access to an object. An access-allowed ACE allows access to an object for a specific trustee identified by a security identifier (SID)."}
, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type AccessAllowedObjectAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessAllowedObjectAceMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK that specifies the user rights allowed by this ACE."};
    AccessAllowedObjectAceFlags Flags
        with Documentation
        {Description = "A 32-bit unsigned integer that specifies a set of bit flags that indicate whether the ObjectType and InheritedObjectType fields contain valid data. This parameter can be one or more of the following values."};
    GUID ObjectType
        with Documentation
        {Description = "A GUID that identifies a property set, property, extended right, or type of child object. The purpose of this GUID depends on the user rights specified in the Mask field. This field is valid only if the ACE _OBJECT_TYPE_PRESENT bit is set in the Flags field. Otherwise, the ObjectType field is ignored. For information on access rights and for a mapping of the control access rights to the corresponding GUID value that identifies each right, see [MS-ADTS] sections  and ."};
    GUID InheritedObjectType
        with Documentation
        {Description = "A GUID that identifies the type of child object that can inherit the ACE. Inheritance is also controlled by the inheritance flags in the ACE_HEADER, as well as by any protection against inheritance placed on the child objects. This field is valid only if the ACE_INHERITED_OBJECT_TYPE_PRESENT bit is set in the Flags member. Otherwise, the InheritedObjectType field is ignored."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8 > 0|] binary AdditionalData with BinaryEncoding{Length = (Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "This additional data is not interpreted and MUST be ignored."};
} with Documentation
    {Description = "The ACCESS_ALLOWED_OBJECT_ACE structure defines an ACE that controls allowed access to an object, a property set, or property. The ACE contains a set of access rights, a GUID that identifies the type of object, and a SID that identifies the trustee to whom the system will grant access. The ACE also contains a GUID and a set of flags that control inheritance of the ACE by child objects."}
, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AccessAllowedObjectAceMaskFlags = flags uint
{
    GenericRead                         = 0x80000000,
    GenericWrite                        = 0x40000000,
    GenericExecute                      = 0x20000000,
    GenericAll                          = 0x10000000,
    Reserved1                           = 0x0C000000,
    MaximumAllowed                      = 0x02000000,
    AccessSystemSecurity                = 0x01000000,
    Reserved2                           = 0x00E00000,
    Synchronize                         = 0x00100000,
    WriteOwner                          = 0x00080000,
    WriteDacl                           = 0x00040000,
    ReadControl                         = 0x00020000,
    Delete                              = 0x00010000,
    AdsRightDsControlAccess             = 0x00000100,
    AdsRightDsCreateChild               = 0x00000001,
    AdsRightDsDeleteChild               = 0x00000002,
    AdsRightDsReadProp                  = 0x00000010,
    AdsRightDsWriteProp                 = 0x00000020,
    AdsRightDsSelf                      = 0x00000008,
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AccessAllowedObjectAceFlags = flags uint
{
    AceObjectTypePresent = 0x00000001
        with Documentation{Description = "ObjectType is valid."},
    AceInheritedObjectTypePresent = 0x00000002
        with Documentation
        {Description = "InheritedObjectType is valid. If this value is not specified, all types of child objects can inherit the ACE."},
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type AccessDeniedAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK that specifies the user rights denied by this ACE."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8 > 0|] binary AdditionalData with BinaryEncoding{Length = (Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "This additional data is not interpreted and MUST be ignored."};
} with Documentation
    {Description = "The ACCESS_DENIED_ACE structure defines an ACE for the DACL that controls access to an object. An access-denied ACE denies access to an object for a specific trustee identified by a SID."}
, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type AccessDeniedObjectAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK that specifies the user rights denied by this ACE."};
    AccessDeniedObjectAceFlags Flags
        with Documentation
        {Description = "A 32-bit unsigned integer that specifies a set of bit flags that indicate whether the ObjectType and InheritedObjectType fields contain valid data. This parameter can be one or more of the following values."};
    GUID ObjectType
        with Documentation
        {Description = "A GUID that identifies a property set, a property, an extended right, or a type of child object. The purpose of this GUID depends on the user rights specified in the Mask field. This field is valid only if the ACE _OBJECT_TYPE_PRESENT bit is set in the Flags field. Otherwise, the ObjectType field is ignored. For information about access rights and for a mapping of the control access rights to the corresponding GUID value that identifies each right, see [MS-ADTS] sections 5.1.3.2 and 5.1.3.2.1."};
    GUID InheritedObjectType
        with Documentation
        {Description = "A GUID that identifies the type of child object that can inherit the ACE. Inheritance is also controlled by the inheritance flags in the ACE_HEADER, as well as by any protection against inheritance placed on the child objects. This field is valid only if the ACE_INHERITED_OBJECT_TYPE_PRESENT bit is set in the Flags member. Otherwise, the InheritedObjectType field is ignored."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8 > 0|] binary AdditionalData with BinaryEncoding{Length = (Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "This additional data is not interpreted and MUST be ignored."};
} with Documentation
    {Description = "The ACCESS_DENIED_OBJECT_ACE structure defines an ACE that controls denied access to an object, a property set, or a property. The ACE contains a set of access rights, a GUID that identifies the type of object, and a SID that identifies the trustee to whom the system will deny access. The ACE also contains a GUID and a set of flags that control inheritance of the ACE by child objects."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AccessDeniedObjectAceFlags = flags uint
{
    AceObjectTypePresent = 0x00000001
        with Documentation{Description = "ObjectType is valid."},
    AceInheritedObjectTypePresent = 0x00000002
        with Documentation
        {Description = "InheritedObjectType is valid. If this value is not specified, all types of child objects can inherit the ACE."},
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type AccessAllowedCallbackAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK that specifies the user rights allowed by this ACE."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8 > 0|] binary ApplicationData with BinaryEncoding{Length = (Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "Optional application data. The size of the application data is determined by the AceSize field of the ACE_HEADER."};
} with Documentation
    {Description = "The ACCESS_ALLOWED_CALLBACK_ACE structure defines an ACE for the DACL that controls access to an object. An access-allowed ACE allows access to an object for a specific trustee identified by a SID."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type AccessDeniedCallbackAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK that specifies the user rights denied by this ACE."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8 > 0|] binary ApplicationData with BinaryEncoding{Length = (Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "Optional application data. The size of the application data is determined by the AceSize field of the ACE_HEADER."};
} with Documentation
    {Description = "The ACCESS_DENIED_CALLBACK_ACE structure defines an ACE for the DACL that controls access to an object. An access-denied ACE denies access to an object for a specific trustee identified by a SID."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type AccessAllowedCallbackObjectAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessAllowedCallbackObjectAceMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK structure that specifies the user rights allowed by this ACE."};
    AccessAllowedCallbackObjectAceFlags Flags
        with Documentation
        {Description = "A 32-bit unsigned integer that specifies a set of bit flags that indicate whether the ObjectType and InheritedObjectType fields contain valid data. This parameter can be one or more of the following values."};
    GUID ObjectType
        with Documentation
        {Description = "A GUID that identifies a property set, property, extended right, or type of child object. The purpose of this GUID depends on the user rights specified in the Mask field. This field is valid only if the ACE _OBJECT_TYPE_PRESENT bit is set in the Flags field. Otherwise, the ObjectType field is ignored."};
    GUID InheritedObjectType
        with Documentation
        {Description = "A GUID that identifies the type of child object that can inherit the ACE. Inheritance is also controlled by the inheritance flags in the ACE_HEADER, as well as by any protection against inheritance placed on the child objects. This field is valid only if the ACE_INHERITED_OBJECT_TYPE_PRESENT bit is set in the Flags member. Otherwise, the InheritedObjectType field is ignored."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8 > 0|] binary ApplicationData with BinaryEncoding{Length = (Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "Optional application data. The size of the application data is determined by the AceSize field of the ACE_HEADER."};
} with Documentation
    {Description = "The ACCESS_ALLOWED_CALLBACK_OBJECT_ACE structure defines an ACE that controls allowed access to an object, property set, or property. The ACE contains a set of user rights, a GUID that identifies the type of object, and a SID that identifies the trustee to whom the system will grant access. The ACE also contains a GUID and a set of flags that control inheritance of the ACE by child objects."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AccessAllowedCallbackObjectAceMaskFlags = flags ACCESS_MASK
{
    GenericRead                         = 0x80000000,
    GenericWrite                        = 0x40000000,
    GenericExecute                      = 0x20000000,
    GenericAll                          = 0x10000000,
    Reserved1                           = 0x0C000000,
    MaximumAllowed                      = 0x02000000,
    AccessSystemSecurity                = 0x01000000,
    Reserved2                           = 0x00E00000,
    Synchronize                         = 0x00100000,
    WriteOwner                          = 0x00080000,
    WriteDacl                           = 0x00040000,
    ReadControl                         = 0x00020000,
    Delete                              = 0x00010000,
    AdsRightDsControlAccess             = 0x00000100,
    AdsRightDsCreateChild               = 0x00000001,
    AdsRightDsReadProp                  = 0x00000010,
    AdsRightDsWriteProp                 = 0x00000020,
    AdsRightDsSelf                      = 0x00000008,
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AccessAllowedCallbackObjectAceFlags = flags uint
{
    AceObjectTypePresent = 0x00000001
        with Documentation{Description = "ObjectType is valid."},
    AceInheritedObjectTypePresent = 0x00000002
        with Documentation
        {Description = "InheritedObjectType is valid. If this value is not specified, all types of child objects can inherit the ACE."}
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type AccessDeniedCallbackObjectAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessDeniedCallbackObjectAceMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK structure that specifies the user rights denied by this ACE."};
    AccessDeniedCallbackObjectAceFlags Flags
        with Documentation
        {Description = "A 32-bit unsigned integer that specifies a set of bit flags that indicate whether the ObjectType and InheritedObjectType fields contain valid data. This parameter can be one or more of the following values."};
    GUID ObjectType
        with Documentation
        {Description = "A GUID that identifies a property set, property, extended right, or type of child object. The purpose of this GUID depends on the user rights specified in the Mask field. This field is valid only if the ACE _OBJECT_TYPE_PRESENT bit is set in the Flags field. Otherwise, the ObjectType field is ignored."};
    GUID InheritedObjectType
        with Documentation
        {Description = "A GUID that identifies the type of child object that can inherit the ACE. Inheritance is also controlled by the inheritance flags in the ACE_HEADER, as well as by any protection against inheritance placed on the child objects. This field is valid only if the ACE_INHERITED_OBJECT_TYPE_PRESENT bit is set in the Flags member. Otherwise, the InheritedObjectType field is ignored."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8 > 0|] binary ApplicationData with BinaryEncoding{Length = (Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "Optional application data. The size of the application data is determined by the AceSize field of the ACE_HEADER."};
} with Documentation
    {Description = "The ACCESS_DENIED_CALLBACK_OBJECT_ACE structure defines an ACE that controls denied access to an object, a property set, or property. The ACE contains a set of user rights, a GUID that identifies the type of object, and a SID that identifies the trustee to whom the system will deny access. The ACE also contains a GUID and a set of flags that control inheritance of the ACE by child objects."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AccessDeniedCallbackObjectAceMaskFlags = flags ACCESS_MASK
{
    GenericRead                         = 0x80000000,
    GenericWrite                        = 0x40000000,
    GenericExecute                      = 0x20000000,
    GenericAll                          = 0x10000000,
    Reserved1                           = 0x0C000000,
    MaximumAllowed                      = 0x02000000,
    AccessSystemSecurity                = 0x01000000,
    Reserved2                           = 0x00E00000,
    Synchronize                         = 0x00100000,
    WriteOwner                          = 0x00080000,
    WriteDacl                           = 0x00040000,
    ReadControl                         = 0x00020000,
    Delete                              = 0x00010000,
    AdsRightDsControlAccess             = 0x00000100,
    AdsRightDsCreateChild               = 0x00000001,
    AdsRightDsReadProp                  = 0x00000010,
    AdsRightDsWriteProp                 = 0x00000020,
    AdsrightDsSelf                      = 0x00000008,
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AccessDeniedCallbackObjectAceFlags = flags uint
{
    AceObjectTypePresent = 0x00000001
        with Documentation{Description = "ObjectType is valid."},
    AceInheritedObjectTypePresent = 0x00000002
        with Documentation
        {Description = "InheritedObjectType is valid. If this value is not specified, all types of child objects can inherit the ACE."},
    ...
} with Documentation{EmbeddedType = true},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type SystemAuditAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK structure that specifies the user rights that cause audit messages to be generated."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4. An access attempt of a kind specified by the Mask field by any trustee whose SID matches the SID field causes the system to generate an audit message. If an application does not specify a SID for this field, audit messages are generated for the specified access rights for all trustees."};
    optional [|Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8 > 0|] binary AdditionalData with BinaryEncoding{Length = (Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "This additional data is not interpreted and MUST be ignored."};
} with Documentation
    {Description = "The SYSTEM_AUDIT_ACE structure defines an access ACE for the system access control list (SACL) that specifies what types of access cause system-level notifications. A system-audit ACE causes an audit message to be logged when a specified trustee attempts to gain access to an object. The trustee is identified by a SID."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type SystemAuditObjectAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK structure that specifies the user rights that cause audit messages to be generated."};
    AccessDeniedObjectAceFlags Flags
        with Documentation
        {Description = "A 32-bit unsigned integer that specifies a set of bit flags that indicate whether the ObjectType and InheritedObjectType fields contain valid data. This parameter can be one or more of the following values."};
    GUID ObjectType
        with Documentation
        {Description = "A GUID that identifies a property set, a property, an extended right, or a type of child object. The purpose of this GUID depends on the user rights specified in the Mask field. This field is valid only if the ACE _OBJECT_TYPE_PRESENT bit is set in the Flags field. Otherwise, the ObjectType field is ignored. For information about access rights and for a mapping of the control access rights to the corresponding GUID value that identifies each right, see [MS-ADTS] sections 5.1.3.2 and 5.1.3.2.1."};
    GUID InheritedObjectType
        with Documentation
        {Description = "A GUID that identifies the type of child object that can inherit the ACE. Inheritance is also controlled by the inheritance flags in the ACE_HEADER, as well as by any protection against inheritance placed on the child objects. This field is valid only if the ACE_INHERITED_OBJECT_TYPE_PRESENT bit is set in the Flags member. Otherwise, the InheritedObjectType field is ignored."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8 > 0|] binary ApplicationData with BinaryEncoding{Length = (Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "Optional application data. The size of the application data is determined by the AceSize field of the ACE_HEADER."};
} with Documentation
    {Description = "The SYSTEM_AUDIT_OBJECT_ACE structure defines an ACE for a SACL. The ACE can audit access to an object or subobjects, such as property sets or properties. The ACE contains a set of user rights, a GUID that identifies the type of object or subobject, and a SID that identifies the trustee for whom the system will audit access. The ACE also contains a GUID and a set of flags that control inheritance of the ACE by child objects."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type SystemAuditCallbackAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK structure that specifies the user rights that cause audit messages to be generated."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4. An access attempt of a kind specified by the Mask field by any trustee whose SID matches the SID field causes the system to generate an audit message. If an application does not specify a SID for this field, audit messages are generated for the specified access rights for all trustees."};
    optional [|Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8 > 0|] binary ApplicationData with BinaryEncoding{Length = (Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "Optional application data. The size of the application data is determined by the AceSize field of the ACE_HEADER."};
} with Documentation
    {Description = "The SYSTEM_AUDIT_CALLBACK_ACE structure defines an ACE for the SACL that specifies what types of access cause system-level notifications. A system-audit ACE causes an audit message to be logged when a specified trustee attempts to gain access to an object. The trustee is identified by a SID."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern SystemMandatoryLabelAceMask = enum ACCESS_MASK
{
    SystemMandatoryLabelNoWriteUp = 0x00000001
        with Documentation
        {Description = "A principal with a lower mandatory level than the object cannot write to the object."},
    SystemMandatoryLabelNoReadUp = 0x00000002
        with Documentation
        {Description = "A principal with a lower mandatory level than the object cannot read the object."},
    SystemMandatoryLabelNoExecuteUp = 0x00000004
        with Documentation
        {Description = "A principal with a lower mandatory level than the object cannot execute the object."},
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type SystemAuditCallbackObjectAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It contains flags that control inheritance of the ACE by child objects."};
    SystemAuditCallbackObjectAceMask Mask
        where ValidationCheckEnumValueTooManyItems(InRange<SystemAuditCallbackObjectAceMask>(value), null, true, ReferenceType.Type,
                "DTYP", "Mask", "SystemAuditCallbackObjectAce", "Mask", "[MS-DTYP]")
        with Documentation
        {Description = "An ACCESS_MASK structure that specifies the user rights that cause audit messages to be generated."};
    SystemAuditCallbackObjectAceFlags Flags
        with Documentation
        {Description = "A 32-bit unsigned integer that specifies a set of bit flags that indicate whether the ObjectType and InheritedObjectType fields contain valid data. This parameter can be one or more of the following values."};
    GUID ObjectType
        with Documentation
        {Description = "A GUID that identifies a property set, property, extended right, or type of child object. The purpose of this GUID depends on the user rights specified in the Mask field. This field is valid only if the ACE_OBJECT_TYPE_PRESENT bit is set in the Flags field. Otherwise, the ObjectType field is ignored."};
    GUID InheritedObjectType
        with Documentation
        {Description = "A GUID that identifies the type of child object that can inherit the ACE. Inheritance is also controlled by the inheritance flags in the ACE_HEADER, as well as by any protection against inheritance placed on the child objects. This field is valid only if the ACE_INHERITED_OBJECT_TYPE_PRESENT bit is set in the Flags member. Otherwise, the InheritedObjectType field is ignored."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4."};
    optional [|Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8 > 0|] binary ApplicationData with BinaryEncoding{Length = (Header.AceSize - 44 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "Optional application data. The size of the application data is determined by the AceSize field of the ACE_HEADER."};
} with Documentation{Description = "The SYSTEM_AUDIT_CALLBACK_OBJECT_ACE structure defines an ACE for a SACL. The ACE can audit access to an object or subobjects, such as property sets or properties. The ACE contains a set of user rights, a GUID that identifies the type of object or subobject, and a SID that identifies the trustee for whom the system will audit access. The ACE also contains a GUID and a set of flags that control inheritance of the ACE by child objects."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern SystemAuditCallbackObjectAceMask = enum ACCESS_MASK
{
    AdsRightDsControlAccess = 0x00000100
        with Documentation
        {Description = "The ObjectType GUID identifies an extended access right."},
    AdsRightDsCreateChild = 0x00000001
        with Documentation
        {Description = "The ObjectType GUID identifies a type of child object. The ACE controls the trustee's right to create this type of child object."},
    AdsRightDsReadProp = 0x00000010
        with Documentation
        {Description = "The ObjectType GUID identifies a property set or property of the object. The ACE controls the trustee's right to read the property or property set."},
    AdsRightDsWriteProp = 0x00000020
        with Documentation
        {Description = "The ObjectType GUID identifies a property set or property of the object. The ACE controls the trustee's right to write the property or property set."},
    AdsRightDsSelf = 0x00000008
        with Documentation
        {Description = "The ObjectType GUID identifies a validated write."},
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern SystemAuditCallbackObjectAceFlags = flags uint
{
    AceObjectTypePresent = 0x00000001
        with Documentation{Description = "ObjectType is valid."},
    AceInheritedObjectTypePresent = 0x00000002
        with Documentation
        {Description = "InheritedObjectType is valid. If this value is not specified, all types of child objects can inherit the ACE."}
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type SystemResourceAttributeAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK that MUST be set to zero."};
    SID SID
        with Documentation
        {Description = "The SID corresponding to the Everyone SID (S-1-1-0) in binary form."};
    CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 AttributeData
        with Documentation
        {Description = "Data describing a resource attribute type, name, and value(s)."};
        
    optional [|Header.AceSize > 8 + SID.Length() + AttributeData.Length()|] array<byte> EntryPadding with BinaryEncoding{Length = Header.AceSize - 8 - SID.Length() - AttributeData.Length()};
} with Documentation{Description = "The SYSTEM_RESOURCE_ATTRIBUTE_ACE structure defines an ACE for the specification of a resource attribute associated with an object. A SYSTEM_RESOURCE_ATTRIBUTE_ACE is used in conditional ACEs in specifying access or audit policy for the resource."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type SystemScopedPolicyIdAce
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It contains flags that control inheritance of the ACE by child objects."};
    AccessMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK that MUST be set to zero."};
    SID SID
        with Documentation
        {Description = "A SID that identifies a central access policy."};
    optional [|Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8 > 0|] binary AdditionalData with BinaryEncoding{Length = (Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "This additional data is not interpreted and MUST be ignored."};
} with Documentation
    {Description = "The SYSTEM_SCOPED_POLICY_ID_ACE structure defines an ACE for the purpose of applying a central access policy to the resource."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AclAclRevision = enum byte
{
    ACLRevision = 0x02
        with Documentation
        {Description = "When set to 0x02, only ACE types 0x00, 0x01, 0x02, and 0x03 should be present in the ACL. An AceType of 0x11 is used for SACLs, but not DACLs. For more information on ACE types, see section ."},
    ACLRevisionDs = 0x04
        with Documentation
        {Description = "When set to 0x04, ACE types 0x05, 0x06, 0x07, and 0x08 are allowed. ACLs of revision 0x04 should be applied only to Directory Service objects. An AceType of 0x11 is used for SACLs, but not DACLs."},
    ...
} with Documentation{EmbeddedType = true}, IDL{DoNotGenerate = true};

pattern SecurityDescriptorControl = flags ushort
{
    SelfRelative                     = 0x8000,
    RMControlValid                   = 0x4000,
    SACLProtected                    = 0x2000,
    DACLProtected                    = 0x1000,
    SACLAutoInherited                = 0x0800,
    DACLAutoInherited                = 0x0400,
    SACLComputedInheritanceRequired  = 0x0200,
    DACLComputedInheritanceRequired  = 0x0100,
    DACLTrusted                      = 0x0080,
    ServerSecurity                   = 0x0040,
    SACLDefaulted                    = 0x0020,
    SACLPresent                      = 0x0010,
    DACLDefaulted                    = 0x0008,
    DACLPresent                      = 0x0004,
    GroupDefaulted                   = 0x0002,
    OwnerDefaulted                   = 0x0001,
};

// WORKAROUND: BUG: The Length aspect doesn't work correctly for array<string>
type ClaimSecurityAttributeUnicodeString
{
    string UnicodeString;
    
    override string ToString()
    {
        return UnicodeString;
    }
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern ClaimSecurityAttributeRelativeV1Flags = flags DWORD
{
    FciClaimSecurityAttributeManual             = 0x00010000,
    FciClaimSecurityAttributePolicyDerived      = 0x00020000,
    ClaimSecurityAttributeNonInheritable        = 0x00000001,
    ClaimSecurityAttributeValueCaseSensitive    = 0x00000002,
    ClaimSecurityAttributeUseForDenyOnly        = 0x00000004,
    ClaimSecurityAttributeDisabledByDefault     = 0x00000008,
    ClaimSecurityAttributeDisabled              = 0x00000010,
    ClaimSecurityAttributeMandatory             = 0x00000020,
    ...
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_RELATIVE
{
    DWORD Length;
    array<BYTE> OctetString with BinaryEncoding{Length = Length};
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};
typedef PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_RELATIVE = CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_RELATIVE with IDL{IndirectionLevel = 1};

// ============================================================== NonRpc types =================================================================

type SECURITY_DESCRIPTOR_NonRpc
{
    byte Revision where ValidationCheck(value == 1, null, DiagnosisLevel.Error, "DTYP: The Revision in type SECURITY_DESCRIPTOR_NonRpc must be set to 0x01, not " + value.ToString() + ".")
        with Documentation
        {Description = "An unsigned 8-bit value that specifies the revision of the SECURITY_DESCRIPTOR structure. This field MUST be set to one."};
    byte Sbz1
        with Documentation
        {Description = "An unsigned 8-bit value that specifies the Sbz1 field. If the Control field has the RM flag set, then this field contains the resource manager (RM) control value. For more information about resource managers, see [MS-SECO] section . Otherwise, this field is reserved and MUST be set to zero."};
    SecurityDescriptorControl Control
        with Documentation
            {Description = "An unsigned 16-bit field that specifies control access bit flags. The Self Relative (SR) bit MUST be set."};
    uint OffsetOwner
        with Documentation
        {Description = "An unsigned 32-bit integer that specifies the offset to the SID. This SID specifies the owner of the object to which the security descriptor is associated. This must be a valid offset if the OD flag is not set. If this field is set to zero, then the OwnerSid field MUST not be present."};
    uint OffsetGroup
        with Documentation
        {Description = "An unsigned 32-bit integer that specifies the offset to the SID. This SID specifies the group of the object to which the security descriptor is associated. This must be a valid offset if the GD flag is not set. If this field is set to zero, then the GroupSid field MUST not be present."};
    uint OffsetSacl
        with Documentation
        {Description = "An unsigned 32-bit integer that specifies the offset to the ACL that contains system ACEs. Typically, the system ACL contains auditing ACEs (such as SYSTEM_AUDIT_ACE, SYSTEM_AUDIT_CALLBACK_ACE, or SYSTEM_AUDIT_CALLBACK_OBJECT_ACE), and at most one Label ACE (as specified in section ). This must be a valid offset if the SP flag is set; if the SP flag is not set, this field MUST be set to zero. If this field is set to zero, then the Sacl field MUST not be present."};
    uint OffsetDacl
        with Documentation
        {Description = "An unsigned 32-bit integer that specifies the offset to the ACL that contains ACEs that control access. Typically, the DACL contains ACEs that grant or deny access to principals or groups. This must be a valid offset if the DP flag is set; if the DP flag is not set, this field MUST be set to zero. If this field is set to zero, then the Dacl field MUST not be present."};
    
    optional [|OffsetOwner > 0|] SID OwnerSid with Encoding{Offset = OffsetOwner};
    optional [|OffsetGroup > 0|] SID GroupSid with Encoding{Offset = OffsetGroup};
    optional [|(Control & SecurityDescriptorControl.SACLPresent) > 0 && OffsetSacl > 0|] ACL_NonRpc Sacl with Encoding{Offset = OffsetSacl};
    optional [|(Control & SecurityDescriptorControl.DACLPresent) > 0 && OffsetDacl > 0|] ACL_NonRpc Dacl with Encoding{Offset = OffsetDacl};

    optional [|Length() - 20 > 0|] binary dataBuffer with BinaryEncoding{Length = Length() - 20},
        // do not show this field on the UI
        Encoding{Decoder = DataBufferDecoder, SourcePattern = TypeOf<binary>()};

    uint Length()
    {
        uint max1 = OffsetOwner > OffsetGroup ? OffsetOwner : OffsetGroup;
        uint max2 = OffsetSacl > OffsetDacl ? OffsetSacl : OffsetDacl;

        if (max1 > max2)
        {
            return OffsetOwner > OffsetGroup ? (OwnerSid as SID).Length() + OffsetOwner : (GroupSid as SID).Length() + OffsetGroup;
        }
        else
        {
            if (max2 == 0)
            {
                return 20;
            }

            return OffsetSacl > OffsetDacl ? (Sacl as ACL_NonRpc).AclSize + OffsetSacl : (Dacl as ACL_NonRpc).AclSize + OffsetDacl;
        }
    }

    optional binary DataBufferDecoder(binary data)
    {
        // do not should this field on the UI
        return nothing;
    }
} with Documentation
    {NameInDocumentation = "SECURITY_DESCRIPTOR", Description = "The SECURITY_DESCRIPTOR structure defines an object's security attributes. These attributes specify who owns the object, who can access the object and what they can do with it, what level of audit logging should be applied to the object, and what kind of restrictions apply to the use of the security descriptor."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type ACL_NonRpc
{
    AclAclRevision AclRevision where InRange<AclAclRevision>(value) // keep this strict enum matching, because it has compete condition with type SID, which Revision must be 1. // where ValidationCheck(InRange<AclAclRevision>(value), null, "DTYP: The AclRevision in type ACL_NonRpc is an undefined value. Please refer to ACL in the Technical Document MS-DTYP.")
        with Documentation
        {Description = "An unsigned 8-bit value that specifies the revision of the ACL structure. This field MUST be set to one of the following values."};
    BYTE Sbz1 where ValidationCheck(value == 0, null, "DTYP: The Sbz1 in type ACL_NonRpc is reserved and must be set to zero, not " + value.ToString() + ".")
        with Documentation
        {Description = "An unsigned 8-bit value. This field is reserved and MUST be set to zero."};
    USHORT AclSize
        with Documentation
        {Description = "An unsigned 16-bit integer that specifies the size of the complete ACL, including all ACEs, in bytes."};
    USHORT AceCount
        // The maximum size of an ACL is 64K, or approximately 1,820 ACEs. from http://support.microsoft.com/kb/166348
        where ValidationCheck(value <= 1820, null, "DTYP: The AceCount in type ACL_NonRpc must be less than or equal to 1820, not " + value.ToString() + ".")
        with Documentation
        {Description = "An unsigned 16-bit integer that specifies the count of the number of ACE records in the ACL."};
    USHORT Sbz2 where ValidationCheck(value == 0, null, "DTYP: The Sbz2 in type ACL_NonRpc is reserved and must be set to zero, not " + value.ToString() + ".")
        with Documentation
        {Description = "An unsigned 16-bit integer. This field is reserved and MUST be set to zero."};
    array<AceList> AceRecords with BinaryEncoding{Length = AceCount};
} with Documentation
    {NameInDocumentation = "ACL", Description = "The access control list (ACL), is used to specify a list of individual access control entries (ACEs)."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

pattern AceList =   [|stream.RemainingByteLength() > 0|]
    ([|stream.CurrentByte() == AceHeaderAceType.AccessAllowedAceType|] AccessAllowedAce |
    [|stream.CurrentByte() == AceHeaderAceType.AccessAllowedObjectAceType|] AccessAllowedObjectAce |
    [|stream.CurrentByte() == AceHeaderAceType.AccessDeniedAceType|] AccessDeniedAce |
    [|stream.CurrentByte() == AceHeaderAceType.AccessDeniedObjectAceType|] AccessDeniedObjectAce |
    [|stream.CurrentByte() == AceHeaderAceType.AccessAllowedCallbackAceType|] AccessAllowedCallbackAce |
    [|stream.CurrentByte() == AceHeaderAceType.AccessDeniedCallbackAceType|] AccessDeniedCallbackAce |
    [|stream.CurrentByte() == AceHeaderAceType.AccessAllowedCallbackObjectAceType|] AccessAllowedCallbackObjectAce |
    [|stream.CurrentByte() == AceHeaderAceType.AccessDeniedCallbackObjectAceType|] AccessDeniedCallbackObjectAce |
    [|stream.CurrentByte() == AceHeaderAceType.SystemAuditAceType|] SystemAuditAce |
    [|stream.CurrentByte() == AceHeaderAceType.SystemAuditObjectAceType|] SystemAuditObjectAce |
    [|stream.CurrentByte() == AceHeaderAceType.SystemAuditCallbackAceType|] SystemAuditCallbackAce |
    [|stream.CurrentByte() == AceHeaderAceType.SystemMandatoryLabelAceType|] SYSTEM_MANDATORY_LABEL_ACE_NonRpc |
    [|stream.CurrentByte() == AceHeaderAceType.SystemAuditCallbackObjectAceType|] SystemAuditCallbackObjectAce |
    [|stream.CurrentByte() == AceHeaderAceType.SystemResourceAttributeAceType|] SystemResourceAttributeAce |
    [|stream.CurrentByte() == AceHeaderAceType.SystemScopedPolicyIdAceType|] SystemScopedPolicyIdAce)
with IDL{DoNotGenerate = true},
Encoding{EncodingKind = EncodingKind.Binary};

type SYSTEM_MANDATORY_LABEL_ACE_NonRpc
{
    ACE_HEADER Header
        with Documentation
        {Description = "An ACE_HEADER structure that specifies the size and type of ACE. It also contains flags that control inheritance of the ACE by child objects."};
    SystemMandatoryLabelAceMaskFlags Mask
        with Documentation
        {Description = "An ACCESS_MASK structure that specifies the access policy for principals with a mandatory integrity level lower than the object associated with the SACL that contains this ACE."};
    SID SID
        with Documentation
        {Description = "The SID of a trustee. The length of the SID MUST be a multiple of 4. The identifier authority of the SID must be SECURITY_MANDATORY_LABEL_AUTHORITY. The RID of the SID specifies the mandatory integrity level of the object associated with the SACL that contains this ACE. The RID must be one of the following values."};
    optional [|Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8 > 0|] binary AdditionalData with BinaryEncoding{Length = (Header.AceSize - 8 - SID.SubAuthorityCount * 4 - 8)},
        Documentation
        {Description = "This additional data is not interpreted and MUST be ignored."};
} with Documentation
    {NameInDocumentation = "SYSTEM_MANDATORY_LABEL_ACE", Description = "The SYSTEM_MANDATORY_LABEL_ACE structure defines an ACE for the SACL that specifies the mandatory access level and policy for a securable object.<31> This construct is supported only by Windows Server 2008, Windows Vista, and Windows 7."},
    IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

